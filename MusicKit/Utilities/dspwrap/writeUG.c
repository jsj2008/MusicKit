/*  	writeUG.c - 
	write unit-generator allocation include file 
	Copyright 1988-1992, NeXT Inc.  All rights reserved.

Modification history:
	01/19/88/daj - File created
	02/20/88/daj - Split up into leaf/master files.
	05/10/88/daj - Added support for UGs with no leaf classes
	01/10/89/daj - Upgraded for 0.9 release
	05/12/89/mtm - Created from writeUG.c by daj
	06/19/89/mtm - Added computeRunTime().
	06/27/89/mtm - Added support for lua, movep and bit instructions in
		       computeRunTime().
	08/31/89/mtm - Disable DO loop tick size warning unless _DSPTrace.
		       Fix write of line that imports UnitGenerator.h.
	01/02/90/jos - Added support for parallel memory moves to computeRunTime().
	01/08/90/jos/mtm - Added support for on-chip instr access to computeRunTime().
	01/15/90/mtm - Changed "generated by dsploadwrap" comments to
		       "generated by dspwrap."
        03/17/90/daj - Added dummy idleSelf method.
        03/21/90/daj - Added @end to writeUGMasterStub() and removed 
	               "if (!isMaster)" from writing of @end in 
		       writeUGLeafClass()
        05/01/90/jos - Removed "r" prefix from rData, rWordCount, rRepeatCount
        06/02/90/jos - Added writeDefaultMethods() and subordinates.
        06/02/90/jos - Converted to procedure prototypes in some cases
        06/02/90/jos - Changed **symbolSizeArr to *symbolSizeArr
        06/02/90/jos - writeUGMasterStub() now emits import for
		       UnitGenerator.h rather than musickit.h.
        06/02/90/jos - Eliminated redundant imports of UnitGenerator.h
	06/11/90/jos - Modified emitted comments per David's suggestions.
	06/13/90/jos - Fixed off by 1 in malloc call
	08/12/90/daj - Change -init to -initialize
	10/19/90/jos - added the following from dspwrap-10:
	08/02/90/jos - Fixed "(null pointer)" in idleSelf method emission 
	   		  when there were no output signals.
	07/22/91/daj - Added \n after @end in header file.  Put back (!)
	               check for isMaster in writeUGMasterStub().
		       Fixed "(null pointer)" in header file emission 
		          when there are no memory arguments.
        03/30/96/daj - Fixed bug in writeFixups to support subrs
	07/07/98/sb  - Changed initialize to a void method for OpenStep	  
*/

#import <libc.h>
#import <strings.h>
#import <c.h>
#import <ctype.h>
#import <sys/file.h>
#import <MKDSP/dsp.h>

/* private functions from libdsp */
extern int _DSPError();
extern int _DSPTrace;

/* Same as DSP_MALLOC in _dsp.h */
#define	 MY_MALLOC( VAR, TYPE, NUM ) \
  if(((VAR) = (TYPE *) malloc( (unsigned)(NUM)*sizeof(TYPE) )) == NULL) \
  _DSPError(-1,"malloc: insufficient memory");

#define INT(_x) ((int)_x)
#define FOREACHLC(_i) for (_i = INT(DSP_LC_N); _i < INT(DSP_LC_Num); _i++) 
#define CONDITIONALCOMMA(_i) ((_i == INT(DSP_LC_Num)-1) ? "" : ",")

#define NOARGINITIALIZATION 

#define	ONCHIP	TRUE
#define	OFFCHIP	FALSE

static int	computeRunTime(DSPDataRecord *progData,
			DSPAddress progAddress, int onChip);

static int nArgs;
static int globalSymCount[DSP_LC_Num];

static char includeMsg[] = 
"/* This source file was auto-generated by dspwrap from dsp macro %s.\n"
"   It is included by unit generator %s. It should not be edited.*/\n";

/*
 * computeRunTime
 *	Calculate approx. number of clock cycles for UG.
 * 	Notes:
 *		- DO must be of format DO #xxx,expr.
 *		- REP must be of format REP #xxx.
 *		- The second word of a two word instruction gets
 *		  treated as a new opcode (except for DO).  This should
 *		  be ok (2 cycles charged) as long as the leading byte is zero.
 *		- Instructions not handled correctly:
 *			All jumps, reset, stop, wait, rti, rts, swi
 */
#   define	OUTER		0	/* states */
#   define	INNER_DO	1
#   define	INNER_REP	2
#   define	DO_INSTR	((instr & 0xFF00F0) == 0x060080)
#   define	REP_INSTR	((instr & 0xFF00F0) == 0x0600A0)
#   define	LUA_INSTR	((instr & 0xFFE0F0) == 0x044010)
#   define	MOVEP_INSTR	((instr & 0xFE4000) == 0x084000)
#   define	BCHG_INSTR	((instr & 0xFF00A0) == 0x0b0000)
#   define	BCLR_INSTR	((instr & 0xFF00A0) == 0x0a0000)
#   define	BSET_INSTR	((instr & 0xFF00A0) == 0x0a0020)
#   define	BTST_INSTR	((instr & 0xFF00A0) == 0x0b0020)
#   define	BIT_INSTR	(BCHG_INSTR || BCLR_INSTR || BSET_INSTR || \
				 BTST_INSTR)
#   define	FOUR_CYCLE_INSTR (LUA_INSTR || MOVEP_INSTR || BIT_INSTR)

/*
 * We detect parallel X and Y moves, adding 2 cycles for each.
 * This gives worst-case timing obtained by assuming everything is off-chip.
 * Since the instruction itself is assumed off chip, any parallel move will
 * take an extra pair of cycles.  This is independent of the extra pair of cycles
 * required to read a long absolute address from the 2nd word of the instruction.
 * Note that MOVEC, MOVEP, and MOVEM are not considered (nor should they occur).
 * Parallel moves cannot occur along with a FOUR_CYCLE_INSTR as defined above.
 */
#   define	X_AND_Y_MOVE	((instr & 0x800000) == 0x800000) /* add 4 cycles */
#   define	LONG_MOVE	((instr & 0xF40000) == 0x400000) /* add 4 cycles */
#   define	X_OR_Y_MOVE	((instr & 0xC00000) == 0x400000) /* add 2 cycles */
#   define	X_Y_REG_MOVE_1	((instr & 0xF00000) == 0x100000) /* add 2 cycles */
#   define	X_Y_REG_MOVE_2	((instr & 0xFE4000) == 0x080000) /* add 2 cycles */
#   define	X_Y_REG_MOVE	(X_Y_REG_MOVE_1 || X_Y_REG_MOVE_2)
#   define	FOUR_CYCLE_MOVE	(X_AND_Y_MOVE || LONG_MOVE)
#   define	TWO_CYCLE_MOVE	(X_Y_REG_MOVE || X_OR_Y_MOVE)

static int	runTimeForWord(DSPDatum instr, int onChip)
{
	register int cyc;
	if (FOUR_CYCLE_INSTR)
	    return 4;		/* No parallel move possible. */
	cyc = 2; 		/* Time assumed to actually execute the instruction. */
	if (TWO_CYCLE_MOVE)
	  cyc += (onChip? 0 : 2); /* onChip means the instruction itself is on-chip */
	else if (FOUR_CYCLE_MOVE)
	  cyc += (onChip? 2 : 4);
	return cyc;
}

static int	computeRunTime(DSPDataRecord *progData, DSPAddress progAddress,
			       int onChip)
{
    int	curAddress = 0;
    int	endDoAddress = 0;
    int doCount = 0;
    int instr;
    int	numCycles = 0;	/* number of clock cycles */
    int	state = OUTER;
    
    while (curAddress < progData->wordCount) {
	instr = progData->data[curAddress];
        switch (state) {
	    case OUTER:
	    	if (DO_INSTR) {
		    state = INNER_DO;
		    numCycles += 6;
		    doCount = ((instr & 0xF)<<12) | ((instr & 0xFF00)>>8);
		    if ((doCount != DSPMK_NTICK) && _DSPTrace)
		      fprintf(stderr,"*** Warning: Found DO loop tick size = %d and "
			      "expected %d ***\n",doCount,DSPMK_NTICK);
		    endDoAddress = progData->data[++curAddress] - progAddress;
		}
		else if (REP_INSTR) {
		    state = INNER_REP;
		    numCycles += 4;
		    doCount = ((instr & 0xF)<<12) | ((instr & 0xFF00)>>8);
		    if ((doCount != DSPMK_NTICK) && _DSPTrace)
		      fprintf(stderr,"*** Warning: Found REP tick size = %d and "
			      "expected %d ***\n",doCount,DSPMK_NTICK);
		}
		else numCycles += runTimeForWord(instr, onChip);
		break;
	    case INNER_REP:
		state = OUTER;
	    case INNER_DO:
	        if (curAddress == endDoAddress)
		    state = OUTER;
		numCycles += runTimeForWord(instr, onChip) * doCount;
		break;
	    default:
	        break;
	}
	curAddress++;
    }
    return numCycles;
}

static char isLocalSymbol(symbolPtr)
DSPSymbol *symbolPtr;
{
    return symbolPtr->type[0] == 'L';
}

static int computeGlobalSymCount(symbolsPtr,nSymbols)
    DSPSymbol *symbolsPtr;
    int nSymbols;
{
    int i;
    int count = 0;
    if (!symbolsPtr || nSymbols == 0)
      return 0;
    for (i = 0; i < nSymbols; symbolsPtr++, i++) 
      if (symbolsPtr && !isLocalSymbol(symbolsPtr)) 
	count++;
    return count;
}	

static int nWds(dataRecPtr)
    DSPDataRecord *dataRecPtr;
{
    if (!dataRecPtr)
      return 0;
    return dataRecPtr->wordCount;
}

static void 
  writeLeafUGStruct(dataArr,fp)
    DSPDataRecord **dataArr;
    FILE *fp;
{
    fprintf(fp,"\n"
"static MKLeafUGStruct _leafUGStruct = {\n"
"    {%d/* xArg  */,  %d/* yArg  */,  %d/* lArg */,\n"
"     %d/* pLoop */,  %d/* pSubr */,\n"
"     %d/* xData */,  %d/* yData */} /* memory requirements */, COMPUTETIME};\n",
        nWds(dataArr[(int)DSP_LC_X]),nWds(dataArr[(int)DSP_LC_Y]),
/* 
  See <dsp/dspstructs.h> on DSPDataRecord for an explanation of
  the divide by 2 below.  Basically, l: words are stored interleaved
  and the wordcount equals the number of 24 bit words which is twice
  the number of 48-bit l: words
*/
        nWds(dataArr[(int)DSP_LC_L])/2,
		     /* all loops will be on chip. The orchestra may move
			them off chip, however. */
	nWds(dataArr[(int)DSP_LC_P]),nWds(dataArr[(int)DSP_LC_PH]), 
		     /* all subrs will be off chip. */
	nWds(dataArr[(int)DSP_LC_XH]),nWds(dataArr[(int)DSP_LC_YH]));
}  

static void writeData(dataRecPtr,fp)
    DSPDataRecord *dataRecPtr;
    FILE *fp;
{
    int isP = 0;
    int i;
    if (!dataRecPtr)
      return;
#   ifdef NOARGINITIALIZATION
    switch (INT(dataRecPtr->locationCounter)) {
      case DSP_LC_X:
      case DSP_LC_Y:
      case DSP_LC_L: 
 	return;
      case DSP_LC_P:
	isP = 1;
      default:
	break;
    }
#   else
    NEED TO REVERSE L ARGUMENT DATA 
#   endif
    fprintf(fp,"\
   static DSPDataRecord _dataRec%s = {NULL, DSP_LC_%s, 0, %d, %d}; \n",
	    DSPLCNames[INT(dataRecPtr->locationCounter)],
	    DSPLCNames[INT(dataRecPtr->locationCounter)],
	    dataRecPtr->repeatCount,
	    dataRecPtr->wordCount);
    fprintf(fp,
	    "   static int _data%s[] = {",
	    DSPLCNames[INT(dataRecPtr->locationCounter)]);
#   define MAYBE_ADD_NEW_LINE if (((i % 5) == 0) && (i != 0)) \
	  fprintf(fp,"\n                          ")
    for (i = 0; i < dataRecPtr->wordCount; i++) {
	MAYBE_ADD_NEW_LINE;
	fprintf(fp,"0x%x%s",dataRecPtr->data[i],
		(i == dataRecPtr->wordCount - 1) ? "" : ",");
    }
    fprintf(fp,"};\n");

    if (dataRecPtr->next)
      fprintf(stderr,"Error: \n"
"writeUG assumes only one DSPDataRecord per location counter.\n"
"Location counter DSP_LC_%s contains more than one DSPDataRecord.\n",
	      DSPLCNames[(int)dataRecPtr->locationCounter]);
}

static void writeFixups(fixupsPtr,fp,nFixups,fixupLC)
    DSPFixup *fixupsPtr;
    FILE *fp;
    int nFixups;
    int fixupLC;
{
    int i;
    char firstOne = TRUE;
    if (!fixupsPtr || nFixups == 0)
      return;
    fprintf(fp,"   static DSPFixup _fixups%s[] = {",
	    DSPLCNames[INT(fixupLC)]);
    for (i = 0; i < nFixups; i++, fixupsPtr++) 
      if (fixupsPtr) {
	  fprintf(fp,"\n   %s{DSP_LC_%s, NULL, %d /* decrement */, %d /* refOffset */,  %d /* relAddress */}",
		  (firstOne) ? "" : ",",
		  DSPLCNames[INT(fixupsPtr->locationCounter)],
		  fixupsPtr->decrement,
		  fixupsPtr->refOffset,fixupsPtr->relAddress);
	  firstOne = FALSE;
      }
    fprintf(fp,"\n   };\n");
}	

static char *upCase(s) 
    char *s;
{
    /* Return upper case copy of s */
    char *rtn;
    char *sp;
    int len = strlen(s)+1;
    MY_MALLOC(rtn, char, len);
    for (sp = rtn; *sp; sp++,s++)
      if (islower(*s)) 
	*sp = toupper(*s);
      else *sp = *s;
    return rtn;
}

static char *argName(char *s)
{
    /* Dig argName out of s. */
    char *rtn,*sp,*endPtr,*startPtr;
    for (startPtr = s; *startPtr; startPtr++)
      ;  /* Get to end */
    endPtr = startPtr;
    for (; *startPtr != '_' && startPtr != s; startPtr--)
      ; /* Get to last '_'  */
    if (*startPtr == '_')
      startPtr++; /* Back up to character right before last '_' */
    else fprintf(stderr,
		 "writeUG.c: Missing '_' in dsp macro argument %s.\n",s);
    MY_MALLOC(rtn, char, endPtr - startPtr + 1);
    for (sp = rtn; startPtr <= endPtr; )
      *sp++ = *startPtr++;
    *sp = '\0';
    return rtn;
}

static void writeArgSpace(symbolPtr,fp,nSymbols,commaNeeded)
    DSPSymbol *symbolPtr;
    FILE *fp;
    int nSymbols;
    char *commaNeeded;
{
    int i;
    register DSPSymbol *sp = symbolPtr;
    char *s1;
    char c;
    for (i = 0; i < nSymbols; i++, sp++) {
	s1 = (*commaNeeded) ? "," : "";
	*commaNeeded = 1;
	c = (strlen(sp->type) < 4) ? 'N' : sp->type[3];
	/* type[4] is O, I or A for ouptput, input or address */
	if (islower(c))
	  c = toupper(c);
	fprintf(fp,"%sDSP_MS_%c",s1,c);
    }
}

static void writeArgSpaces(symbolArr,symbolSizeArr,fp)
    DSPSymbol **symbolArr;
    int *symbolSizeArr;
    FILE *fp;
{
    DSPSymbol *sp;
    char commaNeeded = 0;
    int startVal;
    if (nArgs == 0)
      return;
    fprintf(fp,"   static DSPMemorySpace _argSpaces[] = {");
    writeArgSpace(symbolArr[(int)DSP_LC_X],fp,
		    symbolSizeArr[(int)DSP_LC_X],&commaNeeded);
    writeArgSpace(symbolArr[(int)DSP_LC_Y],fp,
		    symbolSizeArr[(int)DSP_LC_Y],&commaNeeded);
    writeArgSpace(symbolArr[(int)DSP_LC_L],fp,
		    symbolSizeArr[(int)DSP_LC_L],&commaNeeded);
    fprintf(fp,"};\n");
    return;
}
    
static void writeDataInits(dataRecPtr,fp)
    DSPDataRecord *dataRecPtr;
    FILE *fp;
{
    fprintf(fp,"\
   _dataRec%s.data = _data%s;\n",
	      DSPLCNames[INT(dataRecPtr->locationCounter)],
	      DSPLCNames[INT(dataRecPtr->locationCounter)]);
}
    
static
  char *stripTail(srcStr,delimiter)
char *srcStr;
char delimiter;
/* Peels off last extension and delimiter. */
{
    char *s,*rtnStr;
    int i,j;
    for (s = srcStr; *s; s++)
      ;
    while (*s != delimiter && s != srcStr)
      s--;
    if (s == srcStr) {
	fprintf(stderr,"File name missing %c delimiter.\n",delimiter);
	return srcStr;
    }
    MY_MALLOC(rtnStr,char, (j = s - srcStr) + 1); /* added +1, 6/13/90/jos */
    for (i = 0, s = rtnStr; i < j; i++)
      *s++ = *srcStr++;
    *s = '\0';
    return rtnStr;
}
    
static void writeEnum(DSPSymbol **symbolArr, int *symbolSizeArr, FILE *fp);
static void writeUGMasterInit(DSPLoadSpec *nxtPtr,FILE *fp);
static void writeUGMasterGetPtr(FILE *fp);
    
static void writeLeafUGInitFunc(
    DSPLoadSpec *nxtPtr,
    char *fileName,
    FILE *fp,
    char isMaster)
{
    int i,j;
    DSPSection *sp = nxtPtr->userSection;
    fileName = stripTail(fileName,'.'); /* ends with '.m' */
    fprintf(fp,"\n"
"+(MKLeafUGStruct *)classInfo  \n"
"{   if (_leafUGStruct.master == NULL)\n"
"      _leafUGStruct.master = [self masterUGPtr];\n"
"    return &_leafUGStruct; }\n");
   if (isMaster) 
      writeUGMasterGetPtr(fp);
   fprintf(fp,"\n"
"+(void)initialize /* Sent once on factory start-up. */\n"
"{");
   if (!isMaster)
      writeEnum(sp->symbols,globalSymCount,fp);
   writeArgSpaces(sp->symbols,globalSymCount,fp);
   FOREACHLC(i) writeData(sp->data[i],fp);
   for (i = 0; i < INT(DSP_LC_NUM_P); i++) 
      writeFixups(sp->fixups[i],fp,sp->fixupCount[i],i+DSP_LC_P);
   if (isMaster) 
       writeUGMasterInit(nxtPtr,fp);
   fprintf(fp,"   _leafUGStruct.master = NULL;\n");
   if (nArgs)
       fprintf(fp,"   _leafUGStruct.argSpaces = _argSpaces;\n");
   FOREACHLC(i) 
      if (sp->data[i]) {
   switch (i) {
               case DSP_LC_X:
               case DSP_LC_Y:
               case DSP_LC_L:
#          ifdef NOARGINITIALIZATION
     	          break;
#          endif
               default:
	          fprintf(fp,"   _leafUGStruct.data[(int)DSP_LC_%s] = &_dataRec%s;\n",
		          DSPLCNames[i],DSPLCNames[i]);
	         writeDataInits(sp->data[i],fp);
               }
      }
    for (i = 0; i < INT(DSP_LC_NUM_P); i++) {
	j = INT(DSP_LC_P) + i;
	if (sp->fixups[i] && (sp->fixupCount[i] > 0))
	  fprintf(fp,"   _leafUGStruct.fixups[(int)DSP_LC_%s - (int)DSP_LC_P_BASE] = _fixups%s;\n",
		  DSPLCNames[j],DSPLCNames[j]);
    }
    fprintf(fp,"   MKInitUnitGeneratorClass(&_leafUGStruct);\n");
    fprintf(fp,"   _leafUGStruct.reserved1 = MK_2COMPUTETIMES;\n");
    fprintf(fp,"   _leafUGStruct.offChipComputeTime = OFFCHIP_COMPUTETIME;\n");
/*    fprintf(fp,"   return self;\n}\n"); */
/*sb: OS conversion: initialization is void */
    fprintf(fp,"}\n");
}

static void writeMasterStruct(nxtPtr,fp)
    DSPLoadSpec *nxtPtr;
    FILE *fp;
{
    int i;
    DSPSection *sect = nxtPtr->userSection;
    fprintf(fp,"\n"
"static MKMasterUGStruct _masterUGStruct = {\
\n"
"   %d /* nArgs */,\n"
"   {",nArgs);
    FOREACHLC(i) fprintf(fp,"%d%s",globalSymCount[i],CONDITIONALCOMMA(i));
    fprintf(fp,"} /* globalSymCount */,\n   {");
    for (i = 0; i < INT(DSP_LC_NUM_P); i++) 
      fprintf(fp,"%d%s",sect->fixupCount[i],
	      (i == INT(DSP_LC_NUM_P)-1) ? "" : ",");
    fprintf(fp,"} /* fixupCount */\n};\n");
}  

static void writeSymbols(symbolsPtr,fp,nSymbols)
    DSPSymbol *symbolsPtr;
    FILE *fp;
    int nSymbols;
  /* Writes symbols but omits 4th character from 'type' field, since it
     is written out to Master file and the master cannot specify memory
     space. */
{
    int i,j;
    register DSPSymbol *sp = symbolsPtr;
    char first;
    if (!sp || nSymbols == 0)
      return;
    fprintf(fp,"   static DSPSymbol _symbols%s[] = {\n",
	    DSPLCNames[INT(sp->locationCounter)]);
    for (i = 0; i < nSymbols; sp++) 
      if (sp && !isLocalSymbol(sp)) {
	  fprintf(fp,"      {DSP_LC_%s,\"%s\",\"",
		  DSPLCNames[INT(sp->locationCounter)],
		  sp->name
		  );			
	  for (j = 0; sp->type[j] && j < 3; j++) 
	    fprintf(fp,"%c",sp->type[j]); /*** FIXME: Omits 4th character. */
	  fprintf(fp,"\"}");
	  if (i++ != nSymbols - 1)
	    fprintf(fp,",\n");
      }				
    fprintf(fp,"\n   };\n");
}	


static void writeSymbolUnionInits(symbolsPtr,fp,nSymbols,lc)
    DSPSymbol *symbolsPtr;
    FILE *fp;
    int nSymbols;
    DSPLocationCounter lc;
{
    int i;
    DSPSymbol *sp = symbolsPtr;
    char first;
    if (!sp || nSymbols == 0)
      return;
    for (i = 0; i < nSymbols; sp++) 
      if (sp && !isLocalSymbol(sp)) {
	  fprintf(fp,"   ");
	  if (strlen(sp->type) >= 3 && sp->type[2] == 'F')
	    fprintf(fp,"_symbols%s[%d].value.f = %f;\n",DSPLCNames[INT(lc)],i,
		    sp->value.f); /* Type is floating point */
	  else fprintf(fp, "OFFSET(_symbols%s[%d]) = %d;\n",
		       DSPLCNames[INT(lc)],i,sp->value.i);
	  i++;
      }
}	

static void writeArgSymbolRefs(symbolsPtr,fp,nSymbols,lc)
    DSPSymbol *symbolsPtr;
    FILE *fp;
    int nSymbols;
    DSPLocationCounter lc;
{
    int i;
    DSPSymbol *sp = symbolsPtr;
    char first;
    if (!sp || nSymbols == 0)
      return;
    for (i = 0; i < nSymbols; i++, sp++) 
      if (sp) 
	fprintf(fp,"   _argSymbols[(int)%s] = _symbols%s[%d];\n",
		argName(sp->name),DSPLCNames[INT(lc)],i);
}	

/*
  HACK!  All UG arguments which are "output addresses"
  are collected into the following global string for emission
  in to the default "idleSelf" method.
*/
static char *idleSelfString;

/*
  SIMILAR HACK! The method declarations which go into the master .h file
  get collected in the following string.
*/
static char *methodDeclString;

static void writeOneDefaultMethod(DSPSymbol *sp, FILE *fp)
{
    char *arg = argName(sp->name); /* copied */
    extern char *_DSPCopyStr(char *arg);
    char *Arg = _DSPCopyStr(arg);
    int isAddress;
    char *argType;
    char *methodName;
    char *superMethodName;
    char *formalName;
    char *methodDecl;

    if(islower(*Arg)) 
      *Arg=toupper(*Arg); /* capitalize arg name */
    if (sp->type[3]) {		/* address arg */
	char *typeStr = sp->type;
	isAddress = 1;
	argType = "id";
	if (typeStr[4]=='I')
	  methodName = "setInput";
	else if (typeStr[4]=='A')
	  methodName = "setAddress";
	else {
	    if (typeStr[4]=='O') {
		methodName = "setOutput";
		idleSelfString = DSPCat(idleSelfString,
			  	 DSPCat("\t[self setAddressArgToSink:",
			         DSPCat(arg,"];\n")));
	    } else {
		fprintf(stderr,"\n"
"*** Error: dspwrap:writeUG:writeOneDefaultMethod: UG arg %s is type '%s'. \n"
"I will interpret it as an output!\n",
			arg,typeStr);
		methodName = "setOutput";
	    } 
	}
	methodName = DSPCat(methodName,Arg);
	superMethodName = "setAddressArg";
	formalName = "aPatchPoint";
    } else {			/* datum arg */
	isAddress = 0;
	methodName = DSPCat("set",Arg);
	argType = "DSPDatum";
	superMethodName = "setDatumArg";
	formalName = "aFix24";
    }

    methodDecl = DSPCat("- ",
			DSPCat(methodName,
			       DSPCat(":(",
				      DSPCat(argType,
					     DSPCat(")",formalName)))));
    methodDeclString = DSPCat(methodDeclString,
			      DSPCat(methodDecl,";\n"));
    
    fprintf(fp,"\n"
"%s {\n"
"	return [self %s:%s to:%s];\n"
"}\n"
"",methodDecl,superMethodName,arg,formalName);

}

static void writeDefaultMethodsAux(DSPSymbol *sp, FILE *fp, int nSymbols)
{
    int i;
    nSymbols = MAX(nSymbols,0);
    for (i = 0; i < nSymbols; i++,sp++)
      if (sp && !isLocalSymbol(sp)) /* DO loop labels are local symbols */
	writeOneDefaultMethod(sp,fp);
}

static void writeDefaultMethods(DSPSymbol **symbolArr, 
				int *symbolSizeArr, FILE *fp)
{
    idleSelfString = 0;		/* filled in during 'set' method emission */
    methodDeclString = 0;	/* filled in during 'set' method emission */
    if (nArgs == 0)
      return;

    fprintf(fp,"\n"
"/*------- Default methods for poking unit generator memory arguments ----------\n"
" * \n"
" * A default method has been written by dspwrap for every memory argument\n"
" * defined in the unit-generator DSP source file.\n"
" * Each method name is created from the symbolic name specified in\n"
" * the second argument to the new_xarg or new_yarg macro in the DSP\n"
" * source code.  This is also the same name that is used in the \n"
" * DSPWRAP ARGUMENT INFO comment field to declare the memory argument type.\n"
" * \n"
" * A UG memory argument may be either a datum or a DSP memory address.\n"
" * At present, a DSPDatum is 24 bits, right justified in a 32-bit int.\n"
" * An address argument is passed as a SynthData object.\n"
" * The method names distinguish between input and output addresses\n"
" * if the \"(input)\" and \"(output)\" type qualifiers are used in the\n"
" * DSPWRAP ARGUMENT INFO comment field.\n"
" * \n"
" * We recommend that you re-implement the datum-setting methods to accept\n"
" * abstract parameters as floating-point numbers between 0 and 1.0, and \n"
" * physically meaningful parameters as floating-point numbers in natural \n"
" * physical units such as Hertz, seconds, etc.  Note that only those \n"
" * arguments which the user needs to set should be exported; internally \n"
" * managed \"state variables\" need not be exported.\n"
" */\n\n");

    /* UnitGenerator.h imports dsp.h so the following is redundant: 
       fprintf(fp,"typedef int DSPDatum;\n\n"); */

    writeDefaultMethodsAux(symbolArr[(int)DSP_LC_X],fp,
			   symbolSizeArr[(int)DSP_LC_X]);
    writeDefaultMethodsAux(symbolArr[(int)DSP_LC_Y],fp,
			   symbolSizeArr[(int)DSP_LC_Y]);
    writeDefaultMethodsAux(symbolArr[(int)DSP_LC_L],fp,
			   symbolSizeArr[(int)DSP_LC_L]);

    fprintf(fp,"\n"
"/*----------------- Default unit-generator control methods --------------------\n"
" * \n"
" * Only the \"idleSelf\" method below is actually required, and then\n"
" * only when the unit generator has at least one output.\n"
" */\n");

    fprintf(fp,"\n"
"/* \n"
" * The \"init\" method is called once just after the unit generator\n"
" * is instantiated.  Instantiation implies loading of the DSP code.  After\n"
" * instantiation, a unit generator may be allocated and deallocated many\n"
" * times by the Orchestra object in the process of building and freeing\n"
" * SynthPatches.  Initialization happens only the first time.  A nil return\n"
" * normally means there was not sufficient room on the DSP to load the\n"
" * unit generator.\n"
" */\n"
"- init {\n"
"	if (![super init])\n"
"		return nil;\n"
"	/* Initialize instance variables here */\n"
"	return self;\n"
"}\n");

    fprintf(fp,"\n"
"/* \n"
" * The \"idleSelf\" method places the UnitGenerator in a \"turned off\"\n"
" * state. This happens every time a unit generator is \"deallocated\".\n"
" * At the very least, all outputs must be patched to the special \n"
" * patchpoint \"sink\". In rare cases, inputs should be patched to \"zero\",\n"
" * e.g., Out2sum.\n"
" */\n"
"- idleSelf {\n"
"%s\
	return self;\n"
"}\n",(idleSelfString?idleSelfString:"\t/* No outputs! */\n"));

    fprintf(fp,"\n"
"/* \n"
" * The \"runSelf\" method is invoked when the unit generator is sent the\n"
" * \"run\" message.  This is done each time before the unit generator is\n"
" * used.  The \"runSelf\" method should set any default initial state in\n"
" * the unit generator.  For envelopes, as an example, the envelope\n"
" * is triggered (or retriggered) from the beginning by this method.\n"
" * For oscillators, the phase may be reset to zero here.\n"
" * \n"
" * While \"init\" happens only once, \"run\" happens every time \n"
" * the unit generator is reactivated after an \"idle\" message.\n"
" * Note that a unit generator may remain loaded on the DSP\n"
" * and belong to several different SynthPatches in succession.\n"
" * Each usage is bracketed by \"run\" and \"idle\".\n"
" */\n"
"- runSelf {\n"
"	return self;\n"
"}\n");


}

static int writeEnumAux(DSPSymbol *sp, FILE *fp, int nSymbols, int startVal)
{
    int i;
    int endVal;
    nSymbols = MAX(nSymbols,0);
    endVal = startVal + nSymbols;
    for (i = startVal; i < endVal; sp++,i++) 
      if (sp && !isLocalSymbol(sp))
	fprintf(fp,"%s %s",((i == 0) ? "" : ","),argName(sp->name));
    return endVal;
}

static void writeEnum(DSPSymbol **symbolArr, int *symbolSizeArr, FILE *fp)
{
    int startVal;
    if (nArgs == 0)
      return;
    fprintf(fp,"\nenum args {");
    startVal = writeEnumAux(symbolArr[(int)DSP_LC_X],fp,
				      symbolSizeArr[(int)DSP_LC_X],0);
    startVal = writeEnumAux(symbolArr[(int)DSP_LC_Y],fp,
				      symbolSizeArr[(int)DSP_LC_Y],
				      startVal);
    startVal = writeEnumAux(symbolArr[(int)DSP_LC_L],fp,
				      symbolSizeArr[(int)DSP_LC_L],
				      startVal);
    fprintf(fp," };\n");
}

static void writeArgInitAux(symbolPtr,fp,nSymbols,space)
    DSPSymbol *symbolPtr;
    FILE *fp;
    int nSymbols;
    char *space;
{
    int i;
    DSPSymbol *sp = symbolPtr;
    nSymbols = MAX(nSymbols,0);
    for (i = 0; i < nSymbols; i++, sp++) 
      fprintf(fp,"_argSymbols[(int)%s] = _symbols%s[%d];\n",
	      argName(sp->name),space,i);
}

static void writeArgInits(symbolArr,symbolSizeArr,fp)
    DSPSymbol **symbolArr;
    int *symbolSizeArr;
    FILE *fp;
{
    DSPSymbol *sp;
    int startVal;
    if (nArgs) 
      fprintf(fp,"   _masterUGStruct.argSymbols = _argSymbols;\n");
    writeArgInitAux(symbolArr[(int)DSP_LC_X],fp,
				      symbolSizeArr[(int)DSP_LC_X],"X");
    writeArgInitAux(symbolArr[(int)DSP_LC_Y],fp,
				      symbolSizeArr[(int)DSP_LC_Y],"Y");
    writeArgInitAux(symbolArr[(int)DSP_LC_L],fp,
				      symbolSizeArr[(int)DSP_LC_L],"L");
}

static void writeUGMasterInit(nxtPtr,fp)
    DSPLoadSpec *nxtPtr;
    FILE *fp;
{
    int i;
    DSPSection *sp = nxtPtr->userSection;
    if (nArgs) 
	fprintf(fp,"\n#  define OFFSET(_x) _x.value.i\n"
"   static DSPSymbol _argSymbols[%d];\n",nArgs);
    FOREACHLC(i) 
      writeSymbols(sp->symbols[i],fp,globalSymCount[i]);
    FOREACHLC(i) 
      if (globalSymCount[i])
	fprintf(fp,"   _masterUGStruct.symbols[(int)DSP_LC_%s] = _symbols%s;\n",
		DSPLCNames[i],DSPLCNames[i]);
    FOREACHLC(i)
      if (globalSymCount[i])
	writeSymbolUnionInits(sp->symbols[i],fp,globalSymCount[i],i);
    for (i = (int)DSP_LC_X; i <= (int)DSP_LC_L; i++)
      if (globalSymCount[i])
	writeArgSymbolRefs(sp->symbols[i],fp,globalSymCount[i],i);
    if (nArgs)
      fprintf(fp,"   _masterUGStruct.argSymbols = _argSymbols;\n");
}

static void writeUGMasterGetPtr(fp)
    FILE *fp;
{
    fprintf(fp,"\n"
"+(MKMasterUGStruct *)masterUGPtr { return &_masterUGStruct; }\n");
}

static void writeUGMasterInitFunc(nxtPtr,fileName,fp)
    DSPLoadSpec *nxtPtr;
    char *fileName;
    FILE *fp;
{
    int i,j;
    DSPSection *sp = nxtPtr->userSection;
    writeUGMasterGetPtr(fp);
    fprintf(fp,"\n"
"+(void)initialize  /* Sent once on class start-up. */\n"
"{");
   writeUGMasterInit(nxtPtr,fp);
   fprintf(fp,"}\n");
}

static char *writeUGMasterHeader(nxtPtr,fileName,fp)
    DSPLoadSpec *nxtPtr;
    char *fileName;
    FILE *fp;
{
    char *objName;
    char *macroName;
    objName = stripTail(fileName,'I'); /* ends with 'Include.m' */
    if (islower(objName[0]))
      objName[0] = toupper(objName[0]);
    macroName = stripTail(objName,'U'); /* ends with 'UG' */
    if (isupper(macroName[0]))
      macroName[0] = tolower(macroName[0]);
    fprintf(fp,includeMsg,macroName,objName);
    fprintf(fp,"#import <MK/UnitGenerator.h>\n");
    return objName;
}

static void writeUGMasterStub(nxtPtr,fileName,fp)
    DSPLoadSpec *nxtPtr;
    char *fileName;
    FILE *fp;
    /* Writes a stub file for Master ug. */
{
    FILE *headerFp;
    char *headerFileName;
    char *objName;
    char *inclFileRoot;
    objName = stripTail(fileName,'.'); /* ends with '.m' */
    if (islower(objName[0]))
      objName[0] = toupper(objName[0]);
    inclFileRoot = DSPCat(objName,"Include.m");
    if (isupper(inclFileRoot[0]))
      inclFileRoot[0] = tolower(inclFileRoot[0]);

    fprintf(fp,"\
/* This is a minimal implementation of %s.m, a subclass of UnitGenerator.\n"
"   It was auto-generated by dspwrap from DSP source code.\n"
"   This file and %s.h should be extended and rewritten to provide a \n"
"   higher level, device-independent interface to the SynthPatch programmer.\n"
"   See /usr/include/musickit/UnitGenerator.h and the UnitGenerator spec\n"
"   for more information regarding unit-generator method design.\n"
"*/\n\n",objName,objName);

    fprintf(fp,"\
#import \"%s.h\"\n"
"\n"
"@implementation %s:UnitGenerator\n"
"{\n"
"	/* Instance variables go here */\n"
"}\n"
"",objName,objName);
    writeEnum((DSPSymbol **)nxtPtr->userSection->symbols,globalSymCount,fp);
    fprintf(fp,"\n"
"#import \"%s\"\n"
"",inclFileRoot);

    writeDefaultMethods((DSPSymbol **)nxtPtr->userSection->symbols,
			globalSymCount,fp);

  fprintf(fp,"\n"
"@end\n");

    headerFp = fopen(headerFileName = DSPCat(objName,".h"),"w");
    if (!headerFp)
	fprintf(stderr,"*** Can't open %s ***\n.",headerFileName);
    else {
	    printf(" Writing unit-generator stub interface file:\t%s\n",
		   headerFileName);
            fprintf(headerFp,"\
/* This is a prototype of the class interface you will write.\n"
"   Generated by dspwrap.*/\n\n");
	    fprintf(headerFp,"#import <MK/UnitGenerator.h>\n\n");
	    fprintf(headerFp,"@interface %s : UnitGenerator\n",objName);
	    fprintf(headerFp,"{\n /* Instance variables go here */\n}\n\n");
	    fprintf(headerFp,"\
/*\n"
" * Methods for poking the unit generator's DSP memory arguments\n"
" * once it is loaded into the DSP orchestra.\n"
" */\n"
"%s\n"
"/*\n"
" * Method for \"turning off\" a unit generator by patching all its "
		    "outputs to \"sink\" */\n"
"- idleSelf;\n\n\n",
	    methodDeclString?methodDeclString:"/* No DSP arguments. */");
	    fprintf(headerFp,"@end\n");
            fclose(headerFp);
	}
}

static char *writeUGMasterDecls(nxtPtr,fileName,fp)
    DSPLoadSpec *nxtPtr;
    char *fileName;
    FILE *fp;
    /* Writes an include file for unit generator master objects. */
{
    char *objName = writeUGMasterHeader(nxtPtr,fileName,fp);
/*  writeEnum(nxtPtr->userSection->symbols,globalSymCount,fp); */
    writeMasterStruct(nxtPtr,fp);
    return objName;
}

static void writeUGMasterInclude(nxtPtr,fileName,fp)
    DSPLoadSpec *nxtPtr;
    char *fileName;
    FILE *fp;
    /* Writes an include file for unit generator master objects. */
{
    writeUGMasterInitFunc(nxtPtr,writeUGMasterDecls(nxtPtr,fileName,fp),fp);
}

static void  writeUGLeafClass(nxtPtr,fileName,fp,isMaster)
    DSPLoadSpec *nxtPtr;
    char *fileName;
    FILE *fp;
    char isMaster;
{
    /* 
    */
    int i;
    if (!isMaster) {
	char *macroName,*className,*superclassName,*headerFileName,*s;
	char c;
	FILE *headerFp;
	className = stripTail(fileName,'.');
	macroName = stripTail(fileName,'U'); /* Ends with UG[xyl]* */
	if (isupper(macroName[0]))
	  macroName[0] = tolower(macroName[0]);
	for (s = className + strlen(className); *s != 'G'; s--)
	  ;       /* Back up to the 'UG' portion of class name. */
	c = *++s; /* Save this char */
	*s = '\0'; /* Clobber it temporarily */
	MY_MALLOC(superclassName,char,strlen(className)+1);
	strcpy(superclassName,className);
	*s = c;   /* Now fix it. */
	fprintf(fp,"\
/* This class was auto-generated by dspwrap from macro %s. \n"
"   It should not be edited. */\n\n",macroName);
	fprintf(fp,"#import \"%s.h\"\n\n",className);
	fprintf(fp,"@implementation %s : %s\n",className,superclassName);
	headerFp = fopen(headerFileName = DSPCat(className,".h"),"w");
	if (!headerFp)
	  fprintf(stderr,"*** Can't open %s ***\n.",headerFileName);
	else {
	    printf(" Writing unit-generator leaf class interface file:\t%s\n",
		   headerFileName);
	    fprintf(headerFp,"\
/* This header file was auto-generated by dspwrap from macro %s. \n"
"   It need not be edited. */\n\n",macroName);
	    fprintf(headerFp,"#import \"%s.h\"\n",superclassName);
	    fprintf(headerFp,"@interface %s : %s \n",className,superclassName);
	    fprintf(headerFp,"@end");
            fclose(headerFp);
	}
    }
    else writeUGMasterDecls(nxtPtr,fileName,fp);
    fprintf(fp, "\n/* times in seconds/sample */\n");
    fprintf(fp,"#define COMPUTETIME (%d * "
	    "(DSP_CLOCK_PERIOD / DSPMK_I_NTICK))\n",
       computeRunTime(nxtPtr->userSection->data[DSP_LC_P],
           nxtPtr->userSection->loadAddress[DSP_LC_P], ONCHIP));
    fprintf(fp,"#define OFFCHIP_COMPUTETIME (%d * (DSP_CLOCK_PERIOD / DSPMK_I_NTICK))\n",
       computeRunTime(nxtPtr->userSection->data[DSP_LC_P],
           nxtPtr->userSection->loadAddress[DSP_LC_P], OFFCHIP));
    writeLeafUGStruct(nxtPtr->userSection->data,fp);
    writeLeafUGInitFunc(nxtPtr,fileName,fp,isMaster);
    if (!isMaster)
	fprintf(fp,"@end\n");
}

int writeUG(DSPLoadSpec *nxtPtr, char *fileName, FILE *fp, int mode)
/* 
 * Create unit-generator Objective C files from DSP load spec.
 * mode: 0 = leaf, 1 = master, 2 = leaf and master, 3 = master stub 
 */
{
    int i;
    DSPSection *userSection = nxtPtr->userSection;
    FOREACHLC(i) 
      globalSymCount[i] = computeGlobalSymCount(userSection->symbols[i],
						userSection->symCount[i]);
    nArgs = globalSymCount[(int)DSP_LC_X] + globalSymCount[(int)DSP_LC_Y] +
      globalSymCount[(int)DSP_LC_L];
    switch (mode) {
      case 1:
	writeUGMasterInclude(nxtPtr,fileName,fp);
	break;
      case 0:
      case 2:
	/* In the case where mode == 2 (no args), writeUGLeafClass(), not
	 * writeUGMasterInclude(), is used to write the UGInclude.m file. */
	writeUGLeafClass(nxtPtr,fileName,fp,(mode == 2));
	break;
      case 3:
	writeUGMasterStub(nxtPtr,fileName,fp);
	break;
    }
    return 0;
}

