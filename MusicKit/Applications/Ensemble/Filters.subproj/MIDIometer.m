
/* Generated by Interface Builder */

#import "MIDIometer.h"
#import "QuickText.h"
#import "MeterView.h"
#import "ParamInterface.h"
#import <musickit/musickit.h>
#import <appkit/appkit.h>
#import <mididriver/midi_spec.h>

@implementation MIDIometer

+ initialize
 /*
  * Set the version. This can be used in a later version to distinguish older
  * formats when unarchiving documents. 
  */
{
	[MIDIometer setVersion:3];
	return self;
}

- loadNibFile
{
	[NXApp loadNibSection:"MIDIometer.nib" owner:self];
	return self;
}

- setDefaults
{
	int i;
	[super setDefaults];
	for (i = 0; i < 4; i++)
		controller[i] = -1;
	return self;
}

- init
 /* Called automatically when an instance is created. */
{
	[super init];
	conductor = [Conductor clockConductor];
	return self;
}

- awakeFromNib
{
	int i;
	[super awakeFromNib];
	[peakButton1 setState:showPeak[0]];
	[peakButton2 setState:showPeak[1]];
	[peakButton3 setState:showPeak[2]];
	[peakButton4 setState:showPeak[3]];
	[controlInterface setMode:CONTROLS];
	for (i = 0; i < 4; i++)
		[controlInterface setIntValueAt:i to:controller[i]];
	return self;
}

- takePeakFrom:sender
{
	id cell = [sender selectedCell];
	showPeak[[cell tag]] = [cell state];
	peak[[cell tag]] = 0;
    return self;
}

- takeControllerFrom:sender
{
	int meterNum = [sender selectedCol];
	controller[meterNum] = [sender intValue];
	peak[meterNum] = 0;
	[document setEdited];
	return self;
}

- zeroDisplay:meter
{
	[meter setFloatValue:0];
	return self;
}

- display:(int)n value:(short)value
{
	if (showPeak[n] && (value > peak[n])) peak[n] = value;
	switch (n) {
		case 0:
			[valueField1 setShortValue:(showPeak[0])?peak[0]:value];
			[meterView1 setFloatValue:(float)value/127.0];
			break;
		case 1:
			[valueField2 setShortValue:(showPeak[1])?peak[1]:value];
			[meterView2 setFloatValue:(float)value/127.0];
			break;
		case 2:
			[valueField3 setShortValue:(showPeak[2])?peak[2]:value];
			[meterView3 setFloatValue:(float)value/127.0];
			break;
		case 3:
			[valueField4 setShortValue:(showPeak[3])?peak[3]:value];
			[meterView4 setFloatValue:(float)value/127.0];
			break;
		default:
			break;
	}
	return self;
}

- realizeNote:aNote fromNoteReceiver:aNoteReceiver
{
	int i, control;

	[noteSender sendNote:aNote];
	[inspectorPanel disableFlushWindow];
	for (i=0; i<4; i++) {
		control = controller[i];
		if (control < 0) continue;
		if (isControlPresent(aNote, control)) {
			int val = getControlValAsInt(aNote, control);
			if (control == MK_PAR_START+MK_pitchBend) val >>= 7;
			[self display:i value:val];
		}
	}
	[[inspectorPanel reenableFlushWindow] flushWindow];
	return self;
}

- write:(NXTypedStream *) stream
 /* Archive the NoteFilter to a typed stream. */
{
	[super write:stream];
	NXWriteArray(stream, "i", 4, controller);
	NXWriteArray(stream, "c", 4, showPeak);
	return self;
}

- read:(NXTypedStream *) stream
 /* Unarchive the NoteFilter from a typed stream. */
{
	int version;
	[super read:stream];
	version = NXTypedStreamClassVersion(stream, "MIDIometer");
	if (version == 2) {
		id foo;
		NXReadTypes(stream, "@@@@@@@@@@@@",
			&foo, &foo, &foo, &foo,
			&meterView1, &meterView2, &meterView3, &meterView4,
			&valueField1, &valueField2, &valueField3, &valueField4);
		NXReadArray(stream, "c", 4, showPeak);
	}
	else if (version == 3) {
		NXReadArray(stream, "i", 4, controller);
		NXReadArray(stream, "c", 4, showPeak);
	}
	return self;
}

- awake
 /* Initialize certain non-archived data */
{
	[super awake];
	conductor = [Conductor clockConductor];
	return self;
}

@end
