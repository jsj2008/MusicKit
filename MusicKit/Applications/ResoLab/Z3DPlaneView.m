
/* Generated by Interface Builder */

/* This Object Creates a 3D Image of the ZPlane with hidden surface removal. Only the first two quadrants are drawn The Unit Circle is also drawn on the graph */

#import "Z3DPlaneView.h"
#import "ResoController.h"
#import "Xforms.h"
#import <appkit/appkit.h>
#import <math.h>

#define PI 3.141592654782
#define TWO_PI 6.283185309564
#define SRATE 22050

#define ANGLE 0.70710678119
#define IMAGESCALE 0.94
#define SKIPPIXELSX 8.0
#define SKIPPIXELSY  (SKIPPIXELSX * ANGLE)
#define CUTOFF 30.0
#define VIEWSIZE 1.7

@implementation Z3DPlaneView

+ newFrame:(NXRect*)frameRect
{    
    self = [super newFrame:frameRect];
    yRad = bounds.size.width / 2.0 * IMAGESCALE * ANGLE;
    
    data3D.num_poles = 0;
    gain = 1;
}

/* This VIEW, because it takes so long to calculate, keeps a copy of the poles and zeros. Only when
the user presses the "graph" button is the data updated and this method called.*/
- setPoles: (P_ZRec *) thePandZ
{
	register int i;
	
	data3D.num_poles = thePandZ->num_poles;
	for(i = 0; i < MAXPOLES*2; i++) {
		data3D.cen_res[i] = thePandZ->cen_res[i];
	}
}

/* Drawself: this function draws the graph */
- drawSelf: (NXRect *) rects : (int) rectCount
{    
    float zValue();
    register int i;
    register float stepIm;
    register float x ,y,z,ang;
    float cen,res;
    float base = bounds.size.width / 2.0 - yRad / ANGLE;
    id xform;
    float f[(int) (yRad * 2.0 + 0.5)];
    float oldf[(int) (yRad * 2.0 + 0.5)];    
    
    
    PSsetgray(NX_BLACK);
    NXRectFill(&bounds);
    PSsetgray(NX_WHITE);
    
    /* if data not set, make sure it is */
    if (!data3D.num_poles) {
    		[self setPoles:[NXApp data]];
    }
    
   /*  for(x = 0; x < yRad * 2.0;  x++) oldf[(int) x] = 0; */

    xform = [NXApp xform];
    for(y =yRad; y > 0; y -= SKIPPIXELSY) {
    
    	/* step one -- collect z values for onw row (row means y is constant)  -- this will be much faster
	when done on the DSP chip, with the 3DPorjections done with matrices */
	
    	for(x = 0; x < yRad * 2.0;  x++) {
		z =     gain * zValue(x,y,&data3D,yRad)  /*  sin((double) (x - yRad)/yRad * TWO_PI) + 
			sin((double) y/yRad * TWO_PI) */;
		if (z > CUTOFF) z = CUTOFF;
		if (z <= 0) z = 0.00000000001;
		f[(int) x] = z;
	}
	
	/* step two: do log mag on z values */
	[xform logMag: (int) (yRad * 2.0 - 1) array: f floor: -60.0 norm: (float) CUTOFF];
	
	/* step three: draw it ! */
    	PSnewpath();
    	PSmoveto((float) 1.0 + y * ANGLE + base,(float) y + base);
    	for(x = 1.0; x < (yRad * 2.0 - 2.0) ;  x++) {
		PSlineto((float) x + y * ANGLE + base, (float) y + f[(int) x] * yRad * 1.75 + base);
		PSstroke();

	        PSsetgray(NX_BLACK);
	        PSmoveto((float) x + y * ANGLE + base, (float) y + f[(int) x] * yRad * 1.75 + base - 1);
	        PSlineto((float) x + y * ANGLE + base, (float) y + base);
	        PSstroke();
	        PSsetgray(NX_WHITE);

	        PSmoveto((float) x + y * ANGLE + base, (float) y + f[(int) x] * yRad * 1.75 + base);
	}
    }
    PSstroke();
    
    /* step 4: draw unit circle */
    PSmoveto((float) base + yRad  +  (yRad / VIEWSIZE), base + z);
    for(ang = 0.0; ang < PI; ang += PI / 40.0) {
		y = sin((double) ang) * yRad / VIEWSIZE * ANGLE;
		x = cos((double) ang) * yRad / VIEWSIZE;
		z = gain * zValue(x + yRad,y,&data3D,yRad);
		if (z > CUTOFF) z = CUTOFF;
		if (z <= 0) z = 0.00000000001;
		z = log(z*z/(CUTOFF * CUTOFF));
		if (z< -60/5.0)
	   		z = 0;
		else z = 1 - z/(-60/5);
		
    		if (ang == 0.0) PSmoveto((float) base + x + yRad + y, 
			(float) base + y + z * yRad * 1.75);
		PSlineto((float) base + x + yRad + y, 
			(float) base + y + z * yRad * 1.75);
    }
    PSstroke();
    PSflushgraphics();
    return self;
}

- setGainField:anObject
{
    gainField = anObject;
    return self;
}

- setGainSlid:anObject
{
	gainSlid = anObject;
	return self;
}

- updateGain: sender
{
	gain = [sender floatValue];
	[gainField setFloatValue: gain];
	[gainSlid setFloatValue: gain];
	return self;
}

@end

/* zValue calculates the response of the filter on the zPlane using the filter coefficients */
float zValue(x,y,data,yRad)
float x,y;
P_ZRec *data;
float yRad;
{
	register int i;
	double b1,b2;
	double f = 1.0,r,rr,x1,y1,angle,t;
	
	x1 = (double) (x - yRad) * VIEWSIZE / (yRad);
	y1 = VIEWSIZE * fabs((double) (y)) / (yRad);
	r = sqrt((double) (x1 * x1 + y1 * y1));
	rr = r*r;
	angle =  atan2(y1,x1);
	for(i = 0; i <  data->num_poles; i++) {
		b1 = -2.0 * data->cen_res[(i << 1) + 1] *  
			cos((double) data->cen_res[(i << 1)] * TWO_PI / SRATE);
		b2 = (double) (data->cen_res[(i << 1) + 1] * data->cen_res[(i << 1) + 1]);
		t = sqrt( pow( (1.0 + b1 * cos(angle) / r + b2 * cos (2.0 * angle) / (rr)), (double) 2.0 ) +
			pow( (b1 * sin(angle) / r + b2 * sin(2.0 * angle) / rr ), (double) 2.0 ));
		if (t == 0) t = 0.0000000001;
		if (i < ZEROSBEGIN) f  *= 1.0/t;
		else f *= t;
	}
	return (float) f;
}


