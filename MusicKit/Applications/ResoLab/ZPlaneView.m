
/* Generated by Interface Builder */

/* Daniel Culbert : NEW ZPLANE Object */
/* 
The regular ZPlane: this Object draws a two-dimensional view of the ZPlane and places the poles
on this plane as X's and Poles as O's. These poles and zeros can be picked up and moved around
the ZPlane -- they are constrained to locations inside the unit circle.
In Polar Coord, the radius is the resonance of the pole or zero, angle is the center in frequency.
The vertical axis is imaginary, the horiz is real.
NOTE: Representation of the radius or resonance of the pole or zero is not linear -- its scaled
by a power of 4 so that resolution near radii close to one is better.
*/
#import "ZPlaneView.h"
#import <appkit/appkit.h>
#import <math.h>

#define RADSCALE 0.80
#define PI 3.141592654782
#define TWO_PI 6.283185309564
#define SRATE 22050
#define PZIMAGERAD 2.0
#define RADNONLINFACTOR 4.0

#define TO_ZRAD(res) ( (double) pow((double) res,(double) RADNONLINFACTOR))

#define TO_ZANG(cen) ((double) cen / SRATE * TWO_PI)

float zback_ground = 0.0/3.0, zdraw_gray = 3.0/3.0;


@implementation ZPlaneView

/* set up data: store circle in cache */
+ newFrame:(NXRect*)frameRect
{    
    register int i;
    float radius, x, y;
    id circle_cache;
	void findXandY();
	
    self = [super newFrame:frameRect];
    circle_cache = [Window newContent:frameRect style:NX_PLAINSTYLE
    			backing:NX_RETAINED buttonMask:0  
			defer:NO];
    drag_cache = [Window newContent:frameRect style:NX_PLAINSTYLE
    			backing:NX_RETAINED buttonMask:0  
			defer:NO];
	[[circle_cache contentView] lockFocus];
	PSsetgray(NX_BLACK);
	NXRectFill(frameRect);

    [[circle_cache contentView] setOpaque: TRUE];
    PSnewpath();
    PSgsave();
    PSsetgray(zdraw_gray);
    PSsetalpha(1.0);
    PSsetlinewidth(0.0);
    yRad = ((float) bounds.size.height  )/ 2.0;
    PSarc((float) (bounds.origin.x + yRad),
    	   (float) (bounds.origin.y + yRad),(float) (yRad * RADSCALE),
	   (float) 0,(float) 360);
    PSstroke();
    
    PSnewpath();
    PSmoveto((float) (bounds.origin.x + bounds.size.width / 2.0),(float) 
              (bounds.origin.y));
    PSlineto((float) (bounds.origin.x + bounds.size.width / 2.0),(float) 
              (bounds.origin.y + bounds.size.height));
    PSstroke();
    PSnewpath();
    PSmoveto((float) (bounds.origin.x),(float) 
              (bounds.origin.y + bounds.size.height / 2.0));
    PSlineto((float) (bounds.origin.x + bounds.size.width),(float) 
              (bounds.origin.y + bounds.size.height / 2.0));
    PSstroke();
   
   /* For later use: marking half or perhaps 3db points for non-linear scaling of zPlane */
   /*
    findXandY(&x,&y,(float) SRATE / 4.0, (float) 0.5, yRad);
    PSarc((float) (bounds.origin.x + yRad),
    	   (float) (bounds.origin.y + yRad),
	   	   (float) (((x - yRad)/ yRad) * RADSCALE),
	   (float) 0,(float) 360);
    PSstroke();
	
    findXandY(&x,&y,(float) SRATE / 4.0, (float) 1.0, yRad);
	PSmoveto(x,y);
	PSlineto(2.0 * yRad-x,2.0 * yRad - y);
    PSstroke();
    */

    PSgrestore();
    [[circle_cache contentView] unlockFocus];
    circle_gState = [circle_cache gState];
    P_Zdata = NULL;
    weBeCaching = -1;
    return self;
}

- drawZeroAt: (float) x : (float) y
{
	float y2;

        PSnewpath();
        PSarc((float) x, (float) y ,(float) PZIMAGERAD + 2.0, (float) 0,(float) 360);

	y2 = (2.0 * (bounds.origin.y + bounds.size.height / 2.0) - y);
	
	PSstroke();
        PSnewpath();
        PSarc((float) x, (float) y2 ,(float) PZIMAGERAD + 2.0, (float) 0,(float) 360);
	PSstroke();
}

- drawPoleAt: (float) x : (float) y
{
	float  y2;
	
	 PSnewpath();
	PSmoveto((float) (x - PZIMAGERAD),(float) (y - PZIMAGERAD));
	PSlineto((float) (x + PZIMAGERAD),(float) (y + PZIMAGERAD));
	PSmoveto((float) (x - PZIMAGERAD),(float) (y + PZIMAGERAD));
	PSlineto((float) (x + PZIMAGERAD),(float) (y - PZIMAGERAD));
	
	y2 = (2.0 * (bounds.origin.y + bounds.size.height / 2.0) - y);
	PSmoveto((float) (x - PZIMAGERAD),(float) (y2 - PZIMAGERAD));
	PSlineto((float) (x + PZIMAGERAD),(float) (y2 + PZIMAGERAD));
	PSmoveto((float) (x - PZIMAGERAD),(float) (y2 + PZIMAGERAD));
	PSlineto((float) (x + PZIMAGERAD),(float) (y2 - PZIMAGERAD));
	PSstroke();
}

/* draw pole number pz_num: if pz_num is higher than the ZEROSBEGIN #define, then
a zero is drawn. When more poles or zeros are added, their images should be cached.
*/
- drawPoles: (int) pz_num
{
/* (float) radius angle: (float) angle */
    register int i;
    register float radius, angle;
    float x,y;
    register double xmax,ymax,r,y2;
    void findXandY();
    
    [self setOpaque: TRUE];
    PSsetlinewidth(0.1);
    PSsetgray(zdraw_gray);
    
	findXandY(&x,&y,P_Zdata->cen_res[(pz_num << 1)], 
			P_Zdata->cen_res[(pz_num << 1) + 1], yRad);
	if (pz_num < ZEROSBEGIN) {
		[self drawPoleAt: x :y];
	} else [self drawZeroAt: x :y];
    PSflushgraphics();
    return self;
}

/* drawSelf: composite circle and draw Poles:
*/
- drawSelf: (NXRect *) rects : (int) rectCount
{     
    register int i;
    
     if (!P_Zdata) P_Zdata = [NXApp data];
     PScomposite((float) 0.0,(float) 0.0, (float)
	   	  	bounds.size.width,(float) bounds.size.height,circle_gState,
			(float) 0.0,(float) 0.0,NX_COPY);
    for(i = 0; i <P_Zdata->num_poles; i++) {
    		if (weBeCaching != i) {
			    [self drawPoles: i];
		}
    }
    return self;
}

#define MOVEMASK \
    (NX_MOUSEUPMASK|NX_MOUSEDRAGGEDMASK|NX_MOUSEDOWNMASK|NX_NULLEVENT)

/* Move circle or pole pz_num -- everything except the dragged zero or pole is cached, and composited
onto the screen. Then the dragged pole or zero is redrawn in its new location */

- (BOOL) dragP_Z: (int) pz_num
{
    NXPoint p;
    register int i;
    NXEvent* event;
    float cen,res;
    void findCenandRes();
	
    event = [NXApp getNextEvent:MOVEMASK];

    if (event->type == NX_MOUSEUP) return NO;
    
    [[drag_cache contentView] lockFocus];
    weBeCaching = pz_num;
    [self drawSelf:&bounds :1];
    weBeCaching = -1;
    [drag_cache flushWindow];
    [[drag_cache contentView] unlockFocus];
       
    while (event->type != NX_MOUSEUP) {
         [self lockFocus];
	p = event->location;
	[self convertPoint:&p fromView:nil];

	PScomposite((float) 0.0, (float) 0.0,(float) bounds.size.width,
		    (float) bounds.size.height, [drag_cache gState],
		    (float) bounds.origin.x, (float) bounds.origin.y, 
		    NX_COPY);
	findCenandRes(&cen, &res, (float) p.x, (float) p.y, (float) yRad, (float) RADSCALE);
	if (res > 1) res = 1;
	P_Zdata->cen_res[pz_num << 1] = cen;
	P_Zdata->cen_res[(pz_num << 1) + 1] = res;
	[self drawPoles: pz_num];
	[window flushWindow];
	event = [NXApp getNextEvent:MOVEMASK];
	[self unlockFocus];
	[NXApp update];
    }
    
    return YES;
}

/* Mousedown! Check is we hit a zero or pole, and if so, call drag routine dragP_Z */
- mouseDown: (NXEvent *) theEvent
{
    NXPoint p;
    NXRect Image1, Image2;
    register int i;
    float x,y;
	void findXandY();

    [window addToEventMask:MOVEMASK];

    p = theEvent->location;
    [self convertPoint:&p fromView:nil];

    if (!P_Zdata) P_Zdata = [NXApp data];
    for(i = 0; i < P_Zdata->num_poles; i++) {
    	findXandY(&x,&y,P_Zdata->cen_res[i << 1],
			P_Zdata->cen_res[(i << 1) + 1], yRad);
		NXSetRect(&Image1,(NXCoord) (x - PZIMAGERAD),
			(NXCoord) (y - PZIMAGERAD),
			(NXCoord) (PZIMAGERAD * 2.0), (NXCoord) (PZIMAGERAD * 2.0));
		NXSetRect(&Image2,(NXCoord) (x - PZIMAGERAD), 
  (NXCoord) ((2.0 * bounds.origin.y + bounds.size.height - y )- PZIMAGERAD),
		(NXCoord) (PZIMAGERAD * 2.0), (NXCoord) (PZIMAGERAD * 2.0));
	if (NXPointInRect(&p,&Image1) || NXPointInRect(&p,&Image2)) {
		[self dragP_Z:  i];
	}
    }
}

@end


/* C Functions:
   these functions convert between X and Y coordinates and the Center and Radius of the ZPlane. The Nonlinearity of the radius of the ZPlane is accounted for. (These functions could be placed in either the view or Xform class if implemented as methods)
   */
   
void findXandY(x, y,cen, res,yRad) 
float *x;
float *y;
float cen;
float res;
float yRad;
{
	register double radius;
	register double angle;
	register double r;
	
	radius = TO_ZRAD(res);
	angle = TO_ZANG(cen);
	r = radius * yRad * RADSCALE;
	*x = yRad + r * cos(angle);
	*y = yRad + r * sin(angle);
}

void findCenandRes(cen,res, x, y, yRad,radScale)
float *cen;
float *res;
float x;
float  y;
float yRad;
float radScale;
{
	register double radius;
	register double angle;
	register double x1,y1;
	
	x1 = (double) (x - yRad) / (yRad * radScale);
	y1 = fabs((double) (y - yRad)) / (yRad * radScale);
	radius = sqrt((double) (x1 * x1 + y1 * y1));
	angle =  atan2(y1,x1) / TWO_PI ;
	*cen = angle * SRATE;
	*res = pow(radius, (double) 1.0/RADNONLINFACTOR);
}

