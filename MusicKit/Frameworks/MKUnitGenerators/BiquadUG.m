/* Copyright 1988-1992, NeXT Inc.  All rights reserved. */
#ifdef SHLIB
#include "shlib.h"
#endif

/* BiquadUG.m - subclass of UnitGenerator supporting a two-pole, two-zero 
   digital filter.   Based on code auto-generated by dspwrap from DSP source.
   
   Modification history:

   Jun 9, 1991/jos - Created by dspwrap and the following methods added by
                     Julius Smith, on his own time:

- clearState;
- setFirstDelay:(double)d1;
- setSecondDelay:(double)d2;
- setFirstDelay:(double)d1 SecondDelay:(double)d2;
- setA1:(double)newA1;
- setA2:(double)newA2;
- setB1:(double)newB1;
- setB2:(double)newB2;
- setGain:(double)g;

- setComplexPolesRadius:(double)r angle:(double)t;
- setComplexZerosRadius:(double)r angle:(double)t;
- setComplexPolesFrequency:(double)f bandwidth:(double)b
	forSamplingRate:(double)fs;
- setComplexPolesFrequency:(double)f t60:(double)t60;
	forSamplingRate:(double)fs; 
- setComplexZerosFrequency:(double)f bandwidth:(double)b
	forSamplingRate:(double)fs;

   Jun 10, 1991/daj - Flushed auto-generated dspwrap methods.  flushed
                      samplingRate arg from some of Julius' methods, since
		      it's derivable from the UG itself.
*/

#import "BiquadUG.h"
#import <math.h>
#import <MusicKit/MKOrchestra.h>

@implementation BiquadUG:MKUnitGenerator

enum args { ainp, aout, s1, s2, a1o2, a2o2, b1o2, b2o2, go2 };

#import "biquadUGInclude.m"

- idleSelf 
{
    [self setAddressArgToSink:aout];
    return self;
}

- setInput:(id)aPatchPoint 
{
    return [self setAddressArg:ainp to:aPatchPoint];
}

- setOutput:(id)aPatchPoint 
{
    return [self setAddressArg:aout to:aPatchPoint];
}


/******************** Low-level methods ******************/

+(BOOL)shouldOptimize:(unsigned) arg;
/* Specifies that all arguments are to be optimized if possible except the
   filter state. */
{
    return (arg != s1 && arg != s2);
}

- clear
{
    [self setDatumArg:s1 to:0];
    [self setDatumArg:s2 to:0];
    return self;
}

- setFirstDelayedSample:(double)d1
    /* Set filter internal state */
{
    [self setDatumArg:s1 to:DSPDoubleToFix24(d1)];
    return self;
}

- setSecondDelayedSample:(double)d2
    /* Set filter internal state */
{
    [self setDatumArg:s2 to:DSPDoubleToFix24(d2)];
    return self;
}

- setA1:(double)a1
{
    return [self setDatumArg:a1o2 to:DSPDoubleToFix24(0.5*a1)];
}

- setA2:(double)a2
{
    return [self setDatumArg:a2o2 to:DSPDoubleToFix24(0.5*a2)];
}

- setB1:(double)b1
{
    return [self setDatumArg:b1o2 to:DSPDoubleToFix24(0.5*b1)];
}

- setB2:(double)b2
{
    return [self setDatumArg:b2o2 to:DSPDoubleToFix24(0.5*b2)];
}

- setGain:(double)gain
{
    return [self setDatumArg:go2 to:DSPDoubleToFix24(0.5*gain)];
}

/******************** Mid-level methods ******************/

- setComplexPolesRadius:(double)r angle:(double)t /* t in radians */
{
    [self setA1:-2.0*r*cos(t)];
    [self setA2:r*r];
    return self;
}

- setComplexZerosRadius:(double)r angle:(double)t /* t in radians */
{
    [self setB1:-2.0*r*cos(t)];
    [self setB2:r*r];
    return self;
}

- setComplexPolesFrequency:(double)f bandwidth:(double)b 
{
    double r,t,fsi;
    double fs = [orchestra samplingRate];
    fsi = 1.0/fs;
    r = exp(-M_PI * b * fsi);
    t = 2.0 * M_PI * f * fsi;
    [self setA1:-2.0*r*cos(t)];
    [self setA2:r*r];
    return self;
}

- setComplexZerosFrequency:(double)f bandwidth:(double)b 
{
    double r,t,fsi;
    double fs = [orchestra samplingRate];
    fsi = 1.0/fs;
    r = exp(-M_PI * b * fsi);
    t = 2.0 * M_PI * f * fsi;
    [self setB1:-2.0*r*cos(t)];
    [self setB2:r*r];
    return self;
}

- setComplexPolesFrequency:(double)f t60:(double)t60 
    /* t60 is time to decay -60 dB */
{
    double r,t;
    double fs = [orchestra samplingRate];
    r = exp( -log(1000.0) / (fs * t60) );
    t = 2.0 * M_PI * f / fs;
    [self setA1:-2.0*r*cos(t)];
    [self setA2:r*r];
    return self;
}

@end

