<!Doctype chapter PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<chapter id="MusicSynthAndProc">
  <title>Music Synthesis and Processing</title>

<!--
<para><emphasis role="bold">4-3	The Orchestra Class</emphasis></para>
<para>4-4	Sharing Allocations</para>
<para>4-4	Orchestra's Device Status</para>
<para>4-5	Orchestra Output</para>
<para>4-5	Using the DSP Serial Port</para>
<para><emphasis role="bold">4-5	The Music Kit SynthPatch Subclasses</emphasis></para>
<para>4-5	Pluck</para>
<para>4-6	Wavetable Synthesis</para>
<para>4-6	Frequency Modulation</para>
<para>4-6	Waveshaping Synthesis</para>
<para><emphasis role="bold">4-7	Building a SynthPatch</emphasis></para>
<para>4-7	A Simple SynthPatch</para>
<para>4-7	Designing the Patch Specification</para>
<para>4-9	Simplicity's SynthElements Examined</para>
<para>4-12	Playing the Patch</para>
<para>4-13	The <emphasis role="bold">noteOnSelf:</emphasis> Method</para>
<para>4-14	The <emphasis role="bold">noteUpdateSelf:</emphasis> Method</para>
<para>4-15	The <emphasis role="bold">noteOffSelf:</emphasis> and <emphasis role="bold">noteEndSelf</emphasis> Methods</para>
<para>4-16	Applying Parameters</para>
<para>4-17	A Better SynthPatch</para>
<para>4-17	Designing the Patch</para>
<para>4-19	Oscgafi</para>
<para>4-20	Asymp and Asympenv</para>
<para>4-21	Playing the Patch</para>
<para>4-21	Declaring the Parameters</para>
<para>4-23	The <emphasis role="bold">noteOnSelf:</emphasis> and <emphasis role="bold">noteUpdateSelf:</emphasis> Methods</para>
<para>4-23	The <emphasis role="bold">noteOffSelf:</emphasis> and <emphasis role="bold">noteEndSelf</emphasis> Methods</para>
<para>4-24	Phrase Status</para>
<para>4-25	Applying Parameters</para>
<para>4-28	Adding a WaveTable</para>
<para><emphasis role="bold">4-29	Doing Real-time Sound Processing</emphasis></para>
<para>4-30	Making a SynthPatch to do Sound Processing</para>
<para><emphasis role="bold">4-31	Creating a UnitGenerator Subclass</emphasis></para>
<para>4-32	Using <emphasis role="bold">dspwrap</emphasis></para>
<para>4-33	Modifying the Class</para>
<para>4-34	Setting the Arguments</para>
<para>4-35	Defining the Class's Response</para>
-->

<para>In this document "synthesis" refers to creating sound from scratch, while "processing" refers to modifying sound from elsewhere.  However, the MusicKit  provides a unified model of synthesis and processing.  Thus, nearly all operations that apply to synthesis can also be used in sound processing. </para>

<para>There are four levels of MusicKit classes involved in synthesizing and processing music on the DSP:</para>

<listitem><para>At the top level is the <classname>MKSynthInstrument</classname> class; an inheritor from Instrument, it provides an interface between the MusicKit performance mechanism and DSP synthesis/processing.  A <classname>MKSynthInstrument</classname> distributes Notes that it receives during a performance to individual <classname>MKSynthPatch</classname> objects that control the actual synthesis/processing.</para>

<listitem><para><classname>MKSynthPatch</classname>, an abstract class, embodies the principles of music synthesis.  Each subclass of <classname>MKSynthPatch</classname> represents a particular synthesis/processing strategy; each <classname>MKSynthPatch</classname> object synthesizes one <classname>MKNote</classname> at a time, using the strategy defined by its class.</para>

<listitem><para>The <classname>MKUnitGenerator</classname> class is also abstract; each of its subclasses represents a signal processing function that runs on the DSP.  These are the basic building blocks of music synthesis/processing that a <classname>MKSynthPatch</classname> subclass configures to define its synthesis/processing strategy.  At the same level as <classname>MKUnitGenerator</classname> is the <classname>MKSynthData</classname> class.  Instances of <classname>MKSynthData</classname> represent portions of DSP memory that hold synthesis/processing data such as wavetables and delay memory.  In addition, <classname>MKSynthData</classname> objects are used to transmit data between <classname>MKUnitGenerator</classname> objects.</para>

<listitem><para>The <classname>MKOrchestra</classname> represents the DSP itself.  It manages the allocation of DSP resources and controls communication between the DSP and the host.  Requests for use of the DSP are always made through messages to the <classname>MKOrchestra</classname>; this includes requests made by a <classname>MKSynthInstrument</classname> for more <classname>MKSynthPatch</classname>es, and those of a <classname>MKSynthPatch</classname> for <classname>MKUnitGenerator</classname>s and <classname>MKSynthData</classname> objects.</para>

<para>Synthesis.eps &#172;</para>

<para>The <classname>MKSynthInstrument</classname> class is described in <xref
linkend="MusicPerformance">. The rest of this chapter is devoted to
the other classes listed above.</para>

<title>The <classname>MKOrchestra</classname> Class</title>

<para>The <classname>MKOrchestra</classname> class manages DSP resources used in music synthesis/processing.  Each instance of <classname>MKOrchestra</classname> represents a single DSP; in the basic NeXT configuration, there's only one DSP so you create only one <classname>MKOrchestra</classname> object.</para>

<para>The methods defined by the <classname>MKOrchestra</classname> class let you manage a DSP by allocating portions of its memory for specific synthesis/processing modules and by setting its processing characteristics. </para>

<para>You can allocate entire <classname>MKSynthPatch</classname>es or individual <classname>MKUnitGenerator</classname> and <classname>MKSynthData</classname> objects through <classname>MKOrchestra</classname> methods.  Primary among these are:</para>

<listitem><para><emphasis role="bold">allocSynthPatch:</emphasis> allocates an instance of the given <classname>MKSynthPatch</classname> subclass.</para>

<listitem><para><emphasis role="bold">allocUnitGenerator:</emphasis> does the same for a <classname>MKUnitGenerator</classname> subclass.</para>

<listitem><para><emphasis role="bold">allocSynthData:length:</emphasis> allocates a portion of DSP memory of a given length.</para>

<para>Keep in mind, however, that similar methods defined in other classes&horbar;specifically, the <classname>MKSynthPatch</classname> allocation methods defined in <classname>MKSynthInstrument</classname>, and the <classname>MKUnitGenerator</classname> and <classname>MKSynthData</classname> allocation methods defined in <classname>MKSynthPatch</classname>&horbar;are built upon and designed to usurp the allocation methods defined by <classname>MKOrchestra</classname>.  You only to need to allocate synthesis/processing objects directly if you want to assemble sound-making modules at a low level.</para>

<title>Interactivity versus Dependability</title>

<para>Different applications have different needs. When playing a sequence or scorefile, it is essential that the timing of the notes be precise and a bit of latency is tolerable. On the other hand, when playing the DSP from a MIDI keyboard, the critical element is to keep response time to a minimum. In the first case, you should set the <classname>MKOrchestra</classname> to "timed mode" by sending <emphasis role="bold">[orchestra setTimed:YES]</emphasis>, while in the second case, you should set the <classname>MKOrchestra</classname> to "untimed mode" by sending <emphasis role="bold">[orchestra setTimed:NO]</emphasis>.  In addition, when performing from a keyboard, you should call <emphasis role="bold">MKSetRealTimeEnvelopes(YES) </emphasis>before allocating your <classname>MKSynthPatch</classname>es.  This has the effect of setting the MusicKit <classname>MKSynthPatch</classname>es to use a version of the envelope handler that is best-suited to the interactive situation. Actually, <emphasis role="bold">MKSetRealTimeEnvelopes(YES) </emphasis>may be used for either case; its only drawback is that it does not allow for arbitrarily long envelopes. In timed mode, the fixed latency is set by the function <emphasis role="bold">MKSetDeltaT()</emphasis>.  For example, <emphasis role="bold">MKSetDeltaT(.1) </emphasis>sets a fixed latency of a tenth of a second.</para>

<title>Sharing Allocations</title>

<para>To avoid creating duplicate synthesis/processing modules on the DSP, each instance of <classname>MKOrchestra</classname> maintains a shared object table.  Objects on the table are <classname>MKSynthPatch</classname>es, <classname>MKSynthData</classname>s, and <classname>MKUnitGenerator</classname>s; each is indexed by some other object that represents the shared object.  For example, the OscgafUG <classname>MKUnitGenerator</classname> (a family of oscillators) lets you specify its waveform-generating wave table as a <classname>MKPartials</classname> object (you can also set it as a Samples object; for the purposes of this example we only consider the <classname>MKPartials</classname> case).  When its wave table is set through the <emphasis role="bold">setTable:length:</emphasis> method, the oscillator allocates a <classname>MKSynthData</classname> object from the <classname>MKOrchestra</classname> to represent the DSP memory that will hold the waveform data computed from the <classname>MKPartials</classname>.  It also places the <classname>MKSynthData</classname> on the shared object table using the <classname>MKPartials</classname> as an index by sending the message</para>

<programlisting>
[MKOrchestra installSharedSynthData: theSynthData for: thePartials];
</programlisting>

<para>If another oscillator's wave table is set as the same
<classname>MKPartials</classname> object, the already allocated
<classname>MKSynthData</classname> can be returned by sending the
message:</para>

<programlisting>
id aSynthData = [MKOrchestra sharedObjectFor: thePartials];
</programlisting>

<para>The method <emphasis role="bold">installSharedObject:for:</emphasis> is provided for installing <classname>MKSynthPatch</classname>es and <classname>MKUnitGenerator</classname>s.</para>

<title>Orchestra's Device Status</title>

<para>Before you can do anything with an
<classname>MKOrchestra</classname>&horbar;particularly, before you can
allocate synthesis/processing objects&horbar;you must create and open
it.  As usual, creation is done through the <emphasis
role="bold">alloc </emphasis>and<emphasis role="bold"> init</emphasis>
methods; to open an <classname>MKOrchestra</classname>, you send it
the <emphasis role="bold">open</emphasis> message.  This provides a
channel of communication with the DSP that the
<classname>MKOrchestra</classname> represents.  The DSP can be opened
by only one application at a time, so you should always check the
value returned by open; the method returns <emphasis
role="bold">nil</emphasis> if the DSP couldn't be opened.</para>

<para>Once you've allocated the objects that you want, either through
the methods described above or through those defined by
<classname>MKSynthInstrument</classname> and
<classname>MKSynthPatch</classname>, you can start the
synthesis/processing by sending the <emphasis
role="bold">run</emphasis> message to the
<classname>MKOrchestra</classname>.  The <emphasis
role="bold">stop</emphasis> method halts synthesis/processing and
<emphasis role="bold">close</emphasis> breaks communication with the
DSP.  These methods change the <classname>MKOrchestra</classname>'s
status, which is always one of the following MKDeviceStatus
values:</para>

<para><emphasis role="bold">Status	Meaning</emphasis></para>

<para>MK_devOpen	The <classname>MKOrchestra</classname> is open but not running.</para>

<para>MK_devRunning	The <classname>MKOrchestra</classname> is open and running.</para>

<para>MK_devStopped	The <classname>MKOrchestra</classname> has been running but is now stopped.</para>

<para>MK_devClosed	The <classname>MKOrchestra</classname> is closed.</para>

<para>You can query an Orchestra's status through the <emphasis role="bold">deviceStatus</emphasis> method.</para>

<title><classname>MKOrchestra</classname> Output</title>

<para>When the <classname>MKOrchestra</classname> is running it produces a stream of samples that, by default, are sent to the stereo digital to analog converter (DAC), which converts the samples into an audio signal.  But there are two other options:</para>

		<orderedlist>
		  <listitem><para>You can tell the <classname>MKOrchestra</classname> to write the samples to a soundfile by invoking the method <emphasis role="bold">setOutputSoundfile:</emphasis> (you must set the soundfile before sending <emphasis role="bold">run</emphasis> to the <classname>MKOrchestra</classname>).</para>
		  </listitem>
		  <listitem><para>You can tell the <classname>MKOrchestra</classname> to write the samples to the DSP serial port by invoking the method <emphasis role="bold">setSerialSoundOut:</emphasis> (you must set this before sending <emphasis role="bold">run</emphasis> to the <classname>MKOrchestra</classname>).   For more information, see Using the DSP Serial Port below.</para>
		  </listitem>
		</orderedlist>

<para>Note that  you may not combine these output routes&horbar;the sound can only go to one destination at a time.  </para>

<title>Using the DSP Serial Port</title>

<para>One of the most powerful aspects of the MusicKit is its seamless integration with the NeXT DSP serial port.  There are three main uses for the serial port:</para>

<para>1. Direct to DAT transfers of sound in or out of the MusicKit</para>

<para>2. For very high quality digital-to-analog conversion.</para>

<para>3. For high quality analog-to-digital conversion.</para>

<para>The standard NeXT configuration (at the time of this writing) does not include a high-quality sound input.  Therefore, in order to do real-time high-quality sound processing, you need to obtain a device that plugs into the DSP serial port.  Similarly, you may want to use the DSP serial port for high-quality sound output to an outboard digital-to-analog converter or for direct digital transfer to or from a DAT machine.  </para>

<para>A number of such devices are commercially available.  Metaresearch sells the DigitalEars, an analog-to-digital converter.  Ariel has an analog-to-digital converter called the Digital Microphone.  Ariel also sells the ProPort analog-to-digital and digital-to-analog converter, as well as the DatPort DAT interface.  Stealth sells the DAI2400 DAT interface.  Singular Solutions sells the AD64x, which is a combination analog-to-digital converter and DAT interface.  </para>

<para>To set up the <classname>MKOrchestra</classname> to do sound input via the DSP serial port, you send it the message:	</para>

<para>	[orchestra setSerialSoundIn:YES];</para>

<para>To set up the <classname>MKOrchestra</classname> to do sound output via the DSP serial port, you send it the message:	</para>

<para>	[orchestra setSerialSoundOut:YES];</para>

<para>You may simultaneously do serial port input and output.  Alternatively, you may combine serial port input with normal NeXT sound output.  </para>

<para>You may additionally provide an object that tells the MusicKit  about the kind of device you have connected to the DSP serial port.  To do this you send the message 	</para>

<para>[orchestra setSerialPortDevice:aSerialPortDevice];</para>

<para>aSerialPortDevice must be an instance of the MusicKit class DSPSerialPortDevice or one of its subclasses.  The class DSPSerialPortDevice itself provides a general-purpose interface to a number of common devices.  It supports DigitalEars, the Ariel Digital Microphone, DatPort and ProPort.  However, some devices have special requirements and features.  The Stealth DAI2400 is supported by the StealthDAI2400 class, which is a subclass of DSPSerialPortDevice;  similarly, the Singular Solutions AD64x is supported by the SSAD64x class.  You must use these subclasses when using these devices.  The devices are not compatible with the generic interface provided by DSPSerialPortDevice.   For example, to use the AD64x,	</para>

<para>#import &lt;musickit/DSPSerialPortDevice.h&gt;	</para>

<para>[orchestra setSerialPortDevice:[[SSAD64x alloc] init]];</para>

<para>For details on implementing your own DSPSerialPortDevice subclass, see the DSPSerialPortDevice class description in the file </para>

<para><emphasis role="bold">&#172;</emphasis> /LocalLibrary/Documentation/MusicKit/Classes/DSPSerialPortDevice.rtf</para>

<title>The MusicKit <classname>MKSynthPatch</classname> Subclasses</title>

<para>The MusicKit provides a number of
<classname>MKSynthPatch</classname> subclasses, instances of which you
can use in your application.  <classname>MKSynthPatch</classname>
objects are &#170;data-driven&#186;; during a performance, they're
sent <classname>MKNote</classname> objects (through methods described
in the next section) from which they pluck the parameters of interest.
Thus, in order to use a <classname>MKSynthPatch</classname>, you must
know not only what sort of synthesis/processing it embodies, but which
parameters it expects to see in the <classname>MKNote</classname>s it
receives.  A table of the MusicKit parameters organized by
<classname>MKSynthPatch</classname> synthesis/processing technique is
given in <xref linkend="MusicTables">. Below, some of the MusicKit
<classname>MKSynthPatch</classname> subclasses are listed and briefly
described. For a complete list, see <emphasis
role="bold">&lt;musickit/synthpatches/synthpatches.h&gt;</emphasis>.</para>

<para>Note: When doing synthesis in a realtime interactive context,
such as when playing it from a MIDI keyboard, you should invoke
<emphasis role="bold">[orchestra setTimed:NO]</emphasis> and
call<emphasis role="bold">MKUseRealTimeEnvelopes(YES)
</emphasis> before allocating the
<classname>MKSynthPatch</classname>.</para>

<title>Pluck</title>

<para>Pluck employs physical modelling to synthesize the sound of a plucked string, using a technique developed by Alex Strong, Kevin Karplus, David Jaffe and Julius Smith.  The real-world mechanics of a plectrum plucking a string are replaced on the DSP by a burst of noise filling a length of delay memory.  The delay memory is looped and filtered, causing the initial noise burst to gradually become more harmonic as the spectral energy subsides towards the fundamental, emulating the strike-and-fade characteristics of a real plucked string.</para>

<title>Wavetable Synthesis</title>

<para>Wavetable synthesis is a technique in which a length of memory is filled with one or more periods of a waveform; the memory is then looped during playback to produce a continuous signal.  While wavetable synthesis is extremely easy to use&horbar;no messy formulas are needed to create a musical timbre&horbar;it's somewhat limited to the extent that you don't have control over the individual elements that create the timbre (which you do with techniques such as frequency modulation).  </para>

<para>The MusicKit's wavetable synthesis <classname>MKSynthPatch</classname>es use single-period wavetables; they are:</para>

<para><emphasis role="bold"><classname>MKSynthPatch</classname>	Description</emphasis></para>

<para>Wave1	One wavetable</para>

<para>Wave1v	One wavetable with vibrato</para>

<para>Wave1i	One wavetable with frequency interpolation</para>

<para>Wave1vi	One wavetable with vibrato and interpolation</para>

<para>DBWave1v	One database wavetable with vibrato</para>

<para>DBWave1vi	One database wavetable with vibrato and interpolation</para>

<para>DBWave2vi	Two database wavetables with vibrato and interpolation</para>

<para>The database wavetable <classname>MKSynthPatch</classname>es access the MusicKit's <classname>MKWaveTable</classname> Database, a library of predefined timbres.  These are listed in the &#170;Music Tables&#186; appendix. </para>

<title>Frequency Modulation</title>

<para>In frequency modulation (FM) synthesis, the output of one oscillator controls the frequency of another oscillator.  If the frequency of the controlling oscillator (or &#170;modulator&#186;) is subaudio, the tone produced by the controlled oscillator (or &#170;carrier&#186;) will exhibit vibrato.  However, as the modulator's frequency is increased, the carrier's vibrato also increases until the individual undulation become indistinguishable and sidebands, or reflections of the modulator's frequency around the carrier's frequency, appear.  If the oscillators are producing sine waves with identical or harmonically-related frequencies, the sidebands produce a harmonic series.  As the oscillators' waveforms become more complex, the sidebands become more numerous, but they may still produce a harmonic series.  However, if the oscillators' frequencies aren't harmonically related, the result can be a clangorous mess (which is good if you're trying to make bell sounds, one of the more popular and occasionally unavoidable results of FM synthesis).</para>

<title><classname>MKSynthPatch</classname>	Description</emphasis></para>

<para>Fm1	Simple (one-modulator) FM</para>

<para>Fm1i	Simple FM with frequency interpolation</para>

<para>Fm1v	Simple FM with vibrato</para>

<para>Fm1vi	Simple FM with interpolation and vibrato</para>

<para>Fm2cvi	Cascade FM</para>

<para>Fm2cnvi	Cascade FM with random modulation (noise) on the modulators</para>

<para>Fm2pvi	Parallel FM</para>

<para>Fm2pnvi	Parallel FM with noise</para>

<title>Waveshaping Synthesis</title>

<para>There are two waveshaping <classname>MKSynthPatch</classname>es, <emphasis role="bold">Shape </emphasis>and <emphasis role="bold">Shapev</emphasis>.  They differ in that the vibrato parameters are supported only by <emphasis role="bold">Shapev</emphasis>.  </para>

<para>These <classname>MKSynthPatch</classname>es implement non-linear distortion synthesis, which means that they produce sound by using an  oscillator to drive a lookup table.   Normally, the oscillator is a sine wave and the complexity of the resulting waveform is a function of the lookup table.  However, for added flexibility, you may set the oscillator waveform to anything you want.   </para>

<title>Building a <classname>MKSynthPatch</classname></title>

<para>The <classname>MKSynthPatch</classname> class is abstract; each subclass of <classname>MKSynthPatch</classname> describes a unique strategy for creating a musical sound.  It does this by implementing methods that provide two things:</para>

<listitem><para>A <emphasis>patch</emphasis> specification.  A patch is a configuration of DSP synthesis/processing elements.</para>

<listitem><para>A scheme for playing the patch.  This consists of defining the conditions in which the patch is turned on and off and how <classname>MKNote</classname> parameters are used to control it while it's running.</para>

<para>Designing a patch is actually quite simple:  The MusicKit provides an object-oriented interface to the DSP, thus protecting the <classname>MKSynthPatch</classname> designer from the rigors of programming directly in DSP56000 assembly code.  While concern for efficiency makes some knowledge of DSP memory organization necessary, <classname>MKSynthPatch</classname> design makes greater demands of your imagination in creating new sound-making schemes than of your ability to examine and grasp the small print of signal processing.</para>

<para>The MusicKit defines a number of conventions for controlling a patch.  Most of these conventions are manifested as methods that are declared as subclass responsibilities by the <classname>MKSynthPatch</classname> class.  Other conventions are given as general guidelines that should be followed to maintain consistency with the <classname>MKSynthPatch</classname> subclasses provided by the MusicKit.</para>

<title>A Simple <classname>MKSynthPatch</classname></title>

<para>This section describes, by example, the basic steps for creating
a <classname>MKSynthPatch</classname> subclass.  The example
<classname>MKSynthPatch</classname> produces a single sine wave (with
a settable frequency, amplitude, and bearing) for each
<classname>MKNote</classname> it receives.  The design is broken into
two parts: designing the patch specification, and playing the patch.
While the methodology shown for playing the patch introduces a number
of <classname>MKSynthPatch</classname> design conventions, it lacks
some important features that enhance musical flexibility.  These
features are shown in the more complex
<classname>MKSynthPatch</classname> design demonstrated in 
<xref id="ABetterMKSynthPatch">, later in this chapter.</para>

<!-- TODO needs annote setting -->
<para><emphasis>&lt;&lt;Please see the programming example /LocalDeveloper/Examples/MusicKit/exampsynthpatch.  It illustrates a variety of <classname>MKSynthPatch</classname>es.  These range from a sophisticated FM <classname>MKSynthPatch</classname> with vibrato and a wide variety of parameters settable at any time, to a simple <classname>MKSynthPatch</classname> designed for applications that assume traditional computer music scorefile semantics (such as are assumed by MUSIC-5, CMUSIC, CSOUND, etc.).  Much of the complexity of <classname>MKSynthPatch</classname> design is eliminated if the traditional restrictions are adopted.&gt;&gt;</emphasis></para>

<para>Designing the Patch Specification</para>

<para>Every <classname>MKSynthPatch</classname> contains a recipe for creating a patch.  The ingredients of the patch are <classname>MKUnitGenerator</classname> and <classname>MKSynthData</classname> objects (collectively referred to as <emphasis>synthElements</emphasis>):</para>

<listitem><para>Each <classname>MKUnitGenerator</classname> subclass represents a specific signal processing function.  The MusicKit supplies a number of <classname>MKUnitGenerator</classname> subclasses that perform functions such as creating and combining signals, filtering, and adding the finished product to the output sample stream.</para>

<listitem><para><classname>MKSynthData</classname> objects represent data.  These objects can be used for downloading information to the DSP; for example, a <classname>MKWaveTable</classname> is represented on the DSP as a <classname>MKSynthData</classname>.  Another important use of a <classname>MKSynthData</classname> is to provide a location through which one <classname>MKUnitGenerator</classname> can send data to another <classname>MKUnitGenerator</classname>.  This type of <classname>MKSynthData</classname> object is called a <emphasis>patchpoint</emphasis>.</para>

<para>The list of synthElement specifications and instructions for connecting these elements to each other are encapsulated in a PatchTemplate object.  Every <classname>MKSynthPatch</classname> subclass creates at least one PatchTemplate&horbar;most create only one.  A PatchTemplate is created and returned by the <classname>MKSynthPatch</classname> class method <emphasis role="bold">patchTemplateFor:</emphasis>, a subclass responsibility.  In the following example, a single sine wave <classname>MKSynthPatch</classname> is declared and its <emphasis role="bold">patchTemplateFor:</emphasis> method is implemented:</para>

<programlisting>
/* The following files must be imported. */
#import &lt;musickit/musickit.h&gt;
#import &lt;musickit/unitgenerators.h&gt;
#import &lt;objc/List.h&gt;
/* We call our simple SynthPatch 'Simplicity'. */
@implementation Simplicity
/* A static integer is created for each synthElement. */
static int  osc,              /* sine wave UnitGenerator */
            stereoOut,        /* sound output UnitGenerator */
            outPatchpoint;    /* SynthData */
+ patchTemplateFor:aNote
/* The argument is ignored in this implementation. */
{
    /*
     * Step 1:  Create an instance of the PatchTemplate class.  This 
     * method is automatically invoked each time the <classname>MKSynthPatch</classname> 
     * receives a Note.  However, the PatchTemplate should only be 
     * created the first time this method is invoked.  If the object 
     * has already been created, it's immediately returned.
     */
    static id theTemplate = nil;
    if (theTemplate)
        return theTemplate;
    theTemplate = [PatchTemplate new];
    /*
     * Step 2:  Add synthElement specifications to the PatchTemplate.
     * The first two are UnitGenerators; the last is a SynthData 
     * that's used as a patchpoint.
     */
    osc = [theTemplate addUnitGenerator:[OscgUGxy class]];
    stereoOut = [theTemplate addUnitGenerator:[Out2sumUGx class]];
    outPatchpoint = [theTemplate addPatchpoint:MK_xPatch];
    /* Step 3:  Specify the connections between synthElements. */
    [theTemplate to:osc sel:@selector(setOutput:) arg:outPatchpoint];
    /* Always return the PatchTemplate. */
    return theTemplate;
}
</programlisting>

<para>After creating the PatchTemplate instance (step 1 in the example), synthElement specifications are added to it (step 2) using methods defined by the PatchTemplate class.  There are three basic methods to do this (a fourth method will be discussed later):</para>

<listitem><para>addUnitGenerator:</para>

<listitem><para>addSynthData:length:</para>

<listitem><para>addPatchpoint:</para>

<para>Each of these methods returns an integer value that's used as an index to the added synthElement.  Subsequent references to the synthElements are always made through these indices.  Since all instances of a particular <classname>MKSynthPatch</classname> subclass use the same set of indices, the variables that store the values returned by these methods must be declared statically and be made global to the entire class.</para>

<para>Finally, instructions for connecting the synthElements are specified by invoking PatchTemplate's <emphasis role="bold">to:sel:arg:</emphasis> method (step 3).  The arguments to this method are the receiver, selector, and argument, respectively, of a message that will be sent when a <classname>MKSynthPatch</classname> instance is created.  Simplicity specifies a single connection:</para>

<para>[theTemplate to:osc sel:@selector(setOutput:)</para>

<para>    arg:outPatchpoint]</para>

<para>When an instance of Simplicity is created and played, the output of the <classname>MKUnitGenerator</classname> indexed by <emphasis role="bold">osc</emphasis> will be set to the <classname>MKSynthData</classname> indexed by <emphasis role="bold">outPatchpoint</emphasis>.</para>

<para><emphasis>Simplicity's SynthElements Examined</emphasis></para>

<para>To understand the synthElements used in the example, you need to be familiar with a simple detail of DSP memory organization.  DSP memory is divided into three sections, x, y, and p.  x and y memory are used for data; p memory is used for program code.  Thus, <classname>MKSynthData</classname> objects represent data in either x or y memory, while <classname>MKUnitGenerator</classname>s represent DSP functions that always reside in p memory.  This is illustrated in Figure 4-1.</para>

<para>EPS0.eps ,</para>

<para>Figure 4-1.  DSP Memory Division</para>

<para>The MusicKit further divides DSP memory into logical segments, represented as integer constants.  In designing a <classname>MKSynthPatch</classname>, you only need to be concerned with four of these segments:</para>

<listitem><para><emphasis role="bold">MK_xPatch</emphasis> is used for patchpoints in x memory.  </para>

<listitem><para><emphasis role="bold">MK_yPatch</emphasis> is for patchpoints in y memory.  </para>

<listitem><para><emphasis role="bold">MK_xData</emphasis> is for non-patchpoint <classname>MKSynthData</classname> objects in x memory.  </para>

<listitem><para><emphasis role="bold">MK_yData</emphasis> is for non-patchpoint <classname>MKSynthData</classname> objects in y memory.</para>

<para>A <classname>MKSynthData</classname> object is specified by its segment.  For example, Simplicity's patch contains a single <classname>MKSynthData</classname> (a patchpoint) that resides in x memory, as set in the message</para>

<programlisting>
/* Add an x segment patchpoint. */
[theTemplate addPatchpoint:MK_xPatch]
</programlisting>

<para><classname>MKUnitGenerator</classname>s also refer to x and y memory in order to properly read and write data.  Recall the first <classname>MKUnitGenerator</classname> added to Simplicity's patch:</para>

<para>[theTemplate addUnitGenerator:[OscgUGxy class]]</para>

<para>The &#170;x&#186; and &#170;y&#186; in the class name OscgUGxy refer to x and y memory spaces, respectively.  OscgUGxy is a simple <classname>MKUnitGenerator</classname> that has a single input for reading data and a single output for writing data.  The order of these data spigots, or <emphasis>memory arguments</emphasis>, is given in the <classname>MKUnitGenerator</classname> name as output followed by input.  Thus, OscgUGxy's writes data to x memory (output) and reads it from y memory (input).  The MusicKit provides a class for each memory permutation:  OscgUGyy, OscgUGyx, OscgUGxy, and OscgUGxx.  These are called <emphasis>leaf classes</emphasis> of the <emphasis>master class</emphasis> OscgUG.  Aside from the differing memory references, the leaf classes are exactly the same.  Every <classname>MKUnitGenerator</classname> function provided by the MusicKit is similarly organized into a master class and a complete set of leaf classes.</para>

<para><emphasis role="bold">Note:  </emphasis>When describing a subclass of <classname>MKUnitGenerator</classname>, it's convenient to refer to the master class rather than a specific leaf class.  Furthermore, the &#170;UG&#186; (which stands for &#170;<classname>MKUnitGenerator</classname>&#186;) is often dropped from the master class name.</para>

<para>The Oscg family of <classname>MKUnitGenerator</classname>s provides a general oscillator function (the &#170;g&#186; in Oscg stands for &#170;general&#186;).  An oscillator is a module that creates a signal by cycling over a table of values, called a <emphasis>lookup table</emphasis>, that represents a single period of a waveform.  In a general oscillator, the lookup table isn't part of the <classname>MKUnitGenerator</classname>.  You can supply the oscillator with a lookup table by using a <classname>MKWaveTable</classname> object (this will be demonstrated in a subsequent example).  Alternatively, the oscillator can use the built-in sineROM, a read-only section of y memory that contains a single period of a sine wave.  Simplicity's OscgUGxy does the latter:  It reads the sineRom, therefore its input <emphasis>must</emphasis> read from y memory.  In the example, the connection between the sineROM and OscgUGxy is made by default&horbar;it needn't be specified through the <emphasis role="bold">to:sel:arg:</emphasis> method.</para>

<para>One of the conventions of designing a patch is to balance, as much as possible, the use of x and y memory.  Since Simplicity's oscillator must read from y memory in order to read the sineROM, its output is set to x memory.  So of the four Oscg leaf classes, OscgUGxy is chosen.</para>

<para>The other <classname>MKUnitGenerator</classname> in Simplicity's patch, Out2sumUGx, is a special <classname>MKUnitGenerator</classname> that adds a stream of (two-channel) sample data to the stereo output sample stream.  The single memory argument (the &#170;x&#186; in Out2sumUGx) is the <classname>MKUnitGenerator</classname>'s input.  Simplicity uses the Out2sumUGx leaf class so the <classname>MKUnitGenerator</classname> can read the MK_xPatch patchpoint that's written to by OscgUGxy.  Figure 4-2 shows a diagram of the complete patch, superimposed on the DSP memory layout.	</para>

<para>																																																				EPS1.eps ,	</para>

<para>																																																			Figure 4-2.  Simplicity's Patch</para>

<para>Notice that Figure 4-2 shows a connection between the patchpoint and the input of Out2Sum, a connection that isn't specified in Simplicity's PatchTemplate.  By convention, the connection to the output <classname>MKUnitGenerator</classname> is implemented in a method that's invoked when the <classname>MKSynthPatch</classname> receives a noteOn.  This method, called <emphasis role="bold">noteOnSelf:</emphasis>, is examined in the next section.</para>

<para><emphasis role="bold">Note:  </emphasis>The illustration in Figure 4-2 introduces schematic conventions that will be used throughout this section:</para>

<listitem><para><classname>MKUnitGenerator</classname>s are drawn as half-circles (oscillators) or as inverted triangles (everything else).</para>

<listitem><para>A <classname>MKUnitGenerator</classname>'s inputs are at the top of the icon, its outputs are on the bottom.</para>

<listitem><para>Patchpoints are drawn as diamonds.  Other <classname>MKSynthData</classname> objects, including the predefined <classname>MKSynthData</classname> that represents the DSP sineROM, are rectangles.</para>

<listitem><para>Data written to a <classname>MKSynthData</classname> arrives at the left side of the icon.  Data is read from the right.</para>

<para>It's often convenient to represent a patch without including the patchpoints and without superimposing the schematic on the DSP memory diagram.  Figure 4-3 shows Simplicity's patch in an abbreviated form.  A <classname>MKSynthData</classname>'s memory space is indicated by an x or y inside the icon.  The spaces from which and to which a <classname>MKUnitGenerator</classname> reads and writes data is similarly indicated just to the right of each input and output.	</para>

<para>																																					EPS2.eps ,</para>

<para>Figure 4-3.  Conventional Patch Diagram</para>

<title>Playing the Patch</title>

<para>Keep in mind that a <classname>MKSynthPatch</classname> object is ordinarily created and controlled by an instance of <classname>MKSynthInstrument</classname>.  During a MusicKit performance, the <classname>MKSynthInstrument</classname> distributes the Notes it receives to the various <classname>MKSynthPatch</classname> objects that it controls through the methods <emphasis role="bold">noteOn:</emphasis>, <emphasis role="bold">noteUpdate:</emphasis>, and <emphasis role="bold">noteOff:</emphasis> (the <classname>MKSynthInstrument</classname> treats a noteDur as a noteOn and manufactures a noteOff to balance it; also, the <classname>MKSynthInstrument</classname> normally suppresses mutes).  The design of a <classname>MKSynthPatch</classname> subclass must include a methodology to control the patch in response to these messages.  This is done by implementing the following methods:</para>

<listitem><para>noteOnSelf:</para>

<listitem><para>noteUpdateSelf:</para>

<listitem><para>noteOffSelf:</para>

<listitem><para>noteEndSelf</para>

<para>As their names imply, the first three of these methods are invoked automatically when the <classname>MKSynthPatch</classname> receives a <emphasis role="bold">noteOn:</emphasis>, <emphasis role="bold">noteUpdate:</emphasis>, or <emphasis role="bold">noteOff:</emphasis> message, respectively.  <emphasis role="bold">noteEndSelf</emphasis> is automatically invoked when the <classname>MKNote</classname> is completely finished and is provided to accommodate the release portion of the <classname>MKSynthPatch</classname>'s <classname>MKEnvelope</classname>s.</para>

<para><emphasis role="bold">Note:  </emphasis>While these four methods aren't subclass responsibilities, the default implementations provided by the <classname>MKSynthPatch</classname> class do nothing.  Thus, if you don't provide an implementation of, for example, <emphasis role="bold">noteUpdateSelf:</emphasis>, your <classname>MKSynthPatch</classname> won't respond to noteUpdates.</para>

<para><emphasis>The noteOnSelf: Method</emphasis></para>

<para>Simplicity, our example <classname>MKSynthPatch</classname>, implements <emphasis role="bold">noteOnSelf:</emphasis> as follows:</para>

<programlisting>
- noteOnSelf:aNote
{
    /* Step 1:  Read the parameters in the Note and apply them to the 
       patch. */ 
    [self applyParameters:aNote];
    /*
     * Step 2:  Turn on the patch by connecting the Out2sumUGx object 
     * to the patchpoint and sending the run message to all the 
     * synthElements.
     */
    [[self synthElementAt:stereoOut]
            setInput:[self synthElementAt:outPatchpoint]];
    [synthElements makeObjectsPerform:@selector(run)];
    return self;
}
</programlisting>

<para>The first of the two steps, applying the <classname>MKNote</classname> parameters to the patch, is performed in the <emphasis role="bold">applyParameters:</emphasis> method.  The implementation of this method is described in a later section.</para>

<para>The second step, turning on the patch, distinguishes the <emphasis role="bold">noteOnSelf:</emphasis> method from the others.  The first message in step 2 sets the input of <emphasis role="bold">stereoOut</emphasis> (the Out2Sum <classname>MKUnitGenerator</classname>) to the patchpoint <emphasis role="bold">outPatchpoint</emphasis> (recall that this connection was purposely left unspecified in the PatchTemplate).  The final message sends <emphasis role="bold">run</emphasis> to each of the <classname>MKSynthPatch</classname>'s synthElements.  This causes the <classname>MKUnitGenerator</classname>s to begin operating.</para>

<para><emphasis role="bold">Note:  </emphasis>While it isn't necessary to send <emphasis role="bold">run</emphasis> to the patch's patchpoint, it's convenient to send it to all synthElements as shown in the example.  <classname>MKSynthData</classname> implements <emphasis role="bold">run</emphasis> to do nothing, so there's no harm in sending this message to a patchpoint.</para>

<para>The extremely important step of actually creating and connecting the objects that make up Simplicity's patch is performed automatically.  As described in the next chapter, part of a <classname>MKSynthInstrument</classname>'s duties when it receives a <classname>MKNote</classname> is to allocate an appropriate <classname>MKSynthPatch</classname> object to synthesize the <classname>MKNote</classname>.  It does this by sending <emphasis role="bold">patchTemplateFor:</emphasis> to its <classname>MKSynthPatch</classname> subclass with the received <classname>MKNote</classname> as the argument.  As we have seen, this method returns a PatchTemplate object.  It then allocates a <classname>MKSynthPatch</classname> according to the specifications in the PatchTemplate and forwards the <classname>MKNote</classname> to the <classname>MKSynthPatch</classname> through the <emphasis role="bold">noteOn:</emphasis> method.  Thus, by the time the <classname>MKSynthPatch</classname> receives the <emphasis role="bold">noteOnSelf:</emphasis> message (which is sent by <emphasis role="bold">noteOn:</emphasis>) the patch has already been created.</para>

<para>A <classname>MKSynthPatch</classname> contains a List of the objects that make up its patch in its <emphasis role="bold">synthElements</emphasis> instance variable.  In the example above, a use of this instance variable is given as the receiver of the message that causes the <classname>MKUnitGenerator</classname>s to start running:</para>

<para>[synthElements makeObjectsPerform:@selector(run)];</para>

<para>You can retrieve a particular object from the <emphasis role="bold">synthElements</emphasis> List by invoking the <emphasis role="bold">synthElementAt:</emphasis> method, passing the index of the synthElement as the argument.  This is demonstrated in the example above in the line</para>

<para>[[self synthElementAt:stereoOut]</para>

<para>        setInput:[self synthElementAt:outPatchpoint]];</para>

<para><emphasis role="bold">synthElementAt:stereoOut</emphasis> returns an instance of the object indexed by <emphasis role="bold">stereoOut</emphasis>.  In other words, it returns an instance of the Out2sumUGx class, as specified in Simplicity's <emphasis role="bold">patchTemplateFor:</emphasis> method.  Similarly, <emphasis role="bold">synthElementAt:outPatchpoint</emphasis> returns Simplicity's patchpoint.</para>

<para>Finally, the return value of <emphasis role="bold">noteOnSelf:</emphasis> is significant:  If the method returns <emphasis role="bold">nil</emphasis>, the argument <classname>MKNote</classname> isn't synthesized.  Simplicity's implementation always returns <emphasis role="bold">self</emphasis> so all noteOns that it receives are synthesized.</para>

<para><emphasis>The noteUpdateSelf: Method</emphasis></para>

<para>Simplicity's implementation of <emphasis role="bold">noteUpdateSelf:</emphasis> is straightforward; it simply applies its argument's parameters to the patch:</para>

<programlisting>
- noteUpdateSelf:aNote
{
    [self applyParameters:aNote];
    return self;
}
</programlisting>

<para>The value returned by <emphasis role="bold">noteUpdateSelf:</emphasis> is ignored.</para>

<para><emphasis>The noteOffSelf: and noteEndSelf Methods</emphasis></para>

<para>noteOffSelf: and <emphasis role="bold">noteEndSelf</emphasis> work together to wind down and deactivate a <classname>MKSynthPatch</classname>.  As mentioned earlier, <emphasis role="bold">noteOffSelf:</emphasis> is automatically sent when a noteOff is forwarded to the <classname>MKSynthPatch</classname> through the <emphasis role="bold">noteOff:</emphasis> method.  When a noteOff arrives, the <classname>MKSynthPatch</classname> doesn't stop; rather, the noteOff is taken as a signal to begin the release portions of any <classname>MKEnvelope</classname>s that are part of the patch.  The value returned by <emphasis role="bold">noteOffSelf:</emphasis> is taken as the amount of time, in seconds, to wait before invoking <emphasis role="bold">noteEnd</emphasis>; this value is usually the release time of the <classname>MKSynthPatch</classname>'s amplitude envelope.  Since Simplicity doesn't have any <classname>MKEnvelope</classname>s, its implementation of <emphasis role="bold">noteOffSelf:</emphasis> always returns 0.0 (an example of a <classname>MKSynthPatch</classname> that uses <classname>MKEnvelope</classname>s is given later):</para>

<programlisting>
- (double)noteOffSelf:aNote
{
    [self applyParameters:aNote];
    /* No Envelopes, so no release time is needed. */
    return 0.0;
}
</programlisting>

<para>Even though a noteOff is the beginning of the end of a <classname>MKSynthPatch</classname>'s activity, the <classname>MKNote</classname> may contain some parameters; these parameters are applied just as in the other methods, by invoking <emphasis role="bold">applyParameters:</emphasis>.</para>

<para>After waiting the prescribed amount of time, the <emphasis role="bold">noteEnd</emphasis> message is sent.  <emphasis role="bold">noteEnd</emphasis> invokes <emphasis role="bold">noteEndSelf</emphasis>, a method that deactivates the <classname>MKSynthPatch</classname>:</para>

<programlisting>
- noteEndSelf
{
    /* Deactivate the SynthPatch by idling the output. */
    [[self synthElementAt:stereoOut] idle];
    return self;
}
</programlisting>

<para>The <emphasis role="bold">idle</emphasis> method is implemented by all subclasses of <classname>MKUnitGenerator</classname>.  In its implementation of <emphasis role="bold">idle</emphasis>, Out2sum connects its input to a predefined patchpoint that always contains zero data (the data in the patchpoint consists wholly of zeroes).  This effectively turns off the patch.  Notice that the <classname>MKSynthPatch</classname> isn't freed, nor is its patch (as specified in the PatchTemplate) dismantled.  An important convention of <classname>MKSynthPatch</classname> design is to perform the minimum amount of work necessary when deactivating the object.  This makes both the deactivation itself and a subsequent reactivation (when another noteOn arrives) as efficient as possible.</para>

<para>It should be noted that <emphasis role="bold">noteEnd</emphasis> (and, thus, <emphasis role="bold">noteEndSelf</emphasis>) is also invoked when the <classname>MKSynthPatch</classname> is created, thereby ensuring that the patch is silent until the first <classname>MKNote</classname> is received.  This also explains why the final connection to Out2sum isn't specified in the PatchTemplate&horbar;if it was so specified, the connection would be made only to be immediately severed upon reception of the <emphasis role="bold">noteEnd</emphasis> message (the patch is created before <emphasis role="bold">noteEnd</emphasis> is sent).</para>

<para><emphasis>Applying Parameters</emphasis></para>

<para>The final step in our <classname>MKSynthPatch</classname> design is to supply it with parameter values.  As mentioned earlier, Simplicity has three settable attributes:  frequency, amplitude, and bearing.  Simplicity implements the method <emphasis role="bold">applyParameters:</emphasis> to read the appropriate parameters from its argument <classname>MKNote</classname> and apply their values to the patch:</para>

<programlisting>
- applyParameters:aNote
{
    /* Retrieve and store the parameters. */
    double  myFreq = [aNote freq];
    double  myAmp = [aNote parAsDouble:MK_amp];
    double  myBearing = [aNote parAsDouble:MK_bearing];
    /* Apply frequency if present. */
    if ( !MKIsNoDVal(myFreq) )
        [[self synthElementAt:osc] setFreq:myFreq];
    /* Apply amplitude if present. */
    if ( !MKIsNoDVal(myAmp) )
        [[self synthElementAt:osc] setAmp:myAmp];
    /* Apply bearing if present. */
    if ( !MKIsNoDVal(myBearing) )
        [[self synthElementAt:stereoOut] setBearing:myBearing];
}
</programlisting>

<para>First, the parameters are retrieved from the argument <classname>MKNote</classname>.  Notice that the <emphasis role="bold">freq</emphasis> method is used to retrieve frequency; recall from the description of the <classname>MKNote</classname> class that this method returns the value of <emphasis role="bold">MK_freq</emphasis> or, in <emphasis role="bold">MK_freq</emphasis>'s absence, a value converted from <emphasis role="bold">MK_keyNum</emphasis>.</para>

<para>To apply a parameter value to the patch, you send a message to the <classname>MKUnitGenerator</classname> that controls that aspect of the patch.  The Oscg <classname>MKUnitGenerator</classname> controls frequency and amplitude, so <emphasis role="bold">setFreq:</emphasis> and <emphasis role="bold">setAmp:</emphasis> are sent to the patch's OscgUGxy object.  Out2sum controls bearing, so it receives <emphasis role="bold">setBearing:</emphasis>.  These methods are defined in the <classname>MKUnitGenerator</classname>s' master classes.</para>

<para>The complete source code for Simplicity is provided as an example <classname>MKSynthPatch</classname> in the files <emphasis role="bold">Simplicity.m</emphasis> and <emphasis role="bold">Simplicity.h</emphasis> in the directory	</para>

<para>/LocalDeveloper/Examples/MusicKit/exampsynthpatch</para>

<title>A Better <classname>MKSynthPatch</classname></title>

<para>Build a better <classname>MKSynthPatch</classname> and the world will beat a path to your door.  This section improves the <classname>MKSynthPatch</classname> design shown in the previous sections.  Of greatest significance is the envelope control that's added to both frequency and amplitude.  The patch specification is accordingly more complex than in Simplicity.  In addition, a number of conventions are introduced in the methods that play the patch, not only to accommodate envelope control but, more important, to make the <classname>MKSynthPatch</classname> more efficient and more adaptable to the caprice of musical performance.</para>

<para>The <classname>MKSynthPatch</classname> designed here is called Envy.  Like Simplicity, it produces a single sine wave with a settable frequency, amplitude, and bearing.</para>

<title>Designing the Patch</title>

<para>The following example shows the implementation of Envy's <emphasis role="bold">patchTemplateFor:</emphasis> method:</para>

<programlisting>
/* Statically declare the synthElement indices. */
static int  ampAsymp,      /* amplitude envelope UG */
            freqAsymp,     /* frequency envelope UG */
            osc,           /* oscillator UG */
            stereoOut,     /* output UG */
            ampPp,         /* amplitude patchpoint */
            freqPp,        /* frequency patchpoint */
            outPp;         /* output patchpoint */
+ patchTemplateFor:aNote
{
    /* Step 1: Create (or return) the PatchTemplate. */
    static id theTemplate = nil;
    if (theTemplate)
        return theTemplate;
    theTemplate = [PatchTemplate new];
    /* Step 2:  Add the SynthElement specifications. */
    ampAsymp = [theTemplate addUnitGenerator:[AsympenvUGx class]];
    freqAsymp = [theTemplate addUnitGenerator:[AsympenvUGy class]];
    osc = [theTemplate addUnitGenerator:[OscgafiUGxxyy class]];
    stereoOut = [theTemplate addUnitGenerator:[Out2sumUGx class]];
    ampPp = [theTemplate addPatchpoint:MK_xPatch];
    freqPp = [theTemplate addPatchpoint:MK_yPatch];
    outPp = ampPp;
    /* Step 3:  Specify the connections. */
    [theTemplate to:ampAsymp sel:@selector(setOutput:) arg:ampPp];
    [theTemplate to:freqAsymp sel:@selector(setOutput:) arg:freqPp];
    [theTemplate to:osc sel:@selector(setAmpInput:) arg:ampPp];
    [theTemplate to:osc sel:@selector(setIncInput:) arg:freqPp];
    [theTemplate to:osc sel:@selector(setOutput:) arg:outPp];
    /* Return the PatchTemplate. */
    return theTemplate;
}
</programlisting>

<para>The three-step design outline is the same as in Simplicity:  The PatchTemplate is created, the synthElement specifications are added to the PatchTemplate, and the connections between SynthElements are specified.  However, two new <classname>MKUnitGenerator</classname> families, Oscgafi and Asymp, are introduced.  These are examined in the next sections; briefly, Oscgafi is a general oscillator that allows another <classname>MKUnitGenerator</classname> to its amplitude and frequency.  Asymp is an envelope handler; it's used to apply <classname>MKEnvelope</classname> objects to the patch.  Asympenv is a variant of Asymp that is better-suited to interactive real-time applications. The patch is illustrated in Figure 4-4.</para>

<para>EPS3.eps ,</para>

<para>Figure 4-4.  Envy's Patch</para>

<para>Returning to the code example, notice that <emphasis role="bold">ampPp</emphasis> and <emphasis role="bold">outPp</emphasis> are given the same value:</para>

<para>ampPp = [theTemplate addPatchpoint:MK_xPatch];</para>

<para>. . .</para>

<para>outPp = ampPp;</para>

<para>When the patch is created, these two synthElement indices will refer to the same object.  In other words, the patchpoint that's used in the connection between <emphasis role="bold">ampAsymp</emphasis> and <emphasis role="bold">osc</emphasis> is reused in the connection between <emphasis role="bold">osc</emphasis> and <emphasis role="bold">stereoOut</emphasis>.  Reusing patchpoints makes the patch smaller and more efficient.  However, you can only reuse patchpoints if the patch's <classname>MKUnitGenerator</classname>s are executed in a predictable order.  Consider how Envy's <classname>MKUnitGenerator</classname>s use the shared patchpoint:</para>

<para>1.	<emphasis role="bold">ampAsymp</emphasis> writes to <emphasis role="bold">ampPp</emphasis>.  </para>

<para>2.	<emphasis role="bold">osc</emphasis> reads from <emphasis role="bold">ampPp</emphasis> and writes to <emphasis role="bold">outPp</emphasis>.  </para>

<para>3.	<emphasis role="bold">stereoOut</emphasis> reads from <emphasis role="bold">outPp</emphasis>.</para>

<para>For the shared patchpoint scheme to work, the <classname>MKUnitGenerator</classname>s must be executed in the order given&horbar;chaos would reign should <emphasis role="bold">stereoOut</emphasis> read from <emphasis role="bold">outPp</emphasis> before <emphasis role="bold">osc</emphasis> writes to it.  The order in which a <classname>MKSynthPatch</classname>'s <classname>MKUnitGenerator</classname>s are executed is the order in which their specifications are added to the PatchTemplate.  Thus, Envy's <classname>MKUnitGenerator</classname>s are executed in the following order:</para>

<para>1.	ampAsymp </para>

<para>2.	freqAsymp </para>

<para>3.	osc </para>

<para>4.	stereoOut</para>

<para>Since <emphasis role="bold">ampAsymp</emphasis> is executed before <emphasis role="bold">osc</emphasis>, and <emphasis role="bold">osc</emphasis> before <emphasis role="bold">stereoOut</emphasis>, the patchpoint between <emphasis role="bold">ampAsymp</emphasis> and <emphasis role="bold">osc</emphasis> can be reused as the patchpoint between <emphasis role="bold">osc</emphasis> and <emphasis role="bold">stereoOut</emphasis>.</para>

<para><emphasis role="bold">Note:  </emphasis>For some patches, the order in which the <classname>MKUnitGenerator</classname>s are executed doesn't matter.  You can add <classname>MKUnitGenerator</classname>s and declare their execution to be unordered by using the <emphasis role="bold">addUnitGenerator:ordered:</emphasis> method, passing NO as the second argument (the <emphasis role="bold">addUnitGenerator:</emphasis> is actually a shorthand; it invokes <emphasis role="bold">addUnitGenerator:ordered:</emphasis> with YES as the second argument).  While you can't share patchpoints in a patch that uses unordered <classname>MKUnitGenerator</classname>s, allocating the patch is somewhat more efficient.</para>

<para><emphasis>Oscgafi</emphasis></para>

<para>The Oscgafi <classname>MKUnitGenerator</classname> is the most flexible oscillator provided by the MusicKit.  In addition to allowing envelope control of amplitude and frequency, it also performs an interpolation, minimizing the noise that's sometimes introduced when reading the lookup table.  The components of the <classname>MKUnitGenerator</classname>'s name summarize these features:</para>

<para><emphasis role="bold">Component	Meaning</emphasis> </para>

<para>Osc	Oscillator</para>

<para>g	General</para>

<para>a	Amplitude control</para>

<para>f	Frequency control </para>

<para>i	Interpolation</para>

<para>Oscgafi has four memory arguments, in this order:</para>

<para>1.	output </para>

<para>2.	amplitude control input </para>

<para>3.	frequency control input </para>

<para>4.	lookup table input</para>

<para>The permutations of a <classname>MKUnitGenerator</classname> with four memory arguments results in 16 leaf classes.  Envy uses the xxyy version (OscgafiUGxxyy), so the memory arguments correspond to memory space as follows:</para>

<para><emphasis role="bold">Argument	Space</emphasis> </para>

<para>output	x</para>

<para>amplitude control	x </para>

<para>frequency control	y </para>

<para>lookup table	y</para>

<para>A notable difference between Oscg and Oscgafi is that in the latter, frequency and amplitude aren't set directly through messages to the oscillator.  To control these attributes, you affect the <classname>MKUnitGenerator</classname>s that are connected to Oscgafi's inputs.  The MusicKit provides a C function, called <emphasis role="bold">MKUpdateAsymp()</emphasis> that does this for you.  This function is described later as it's used to apply parameter values to Envy's patch.</para>

<para>In addition, Oscgafi's frequency input is actually an increment input&horbar;the oscillator's frequency is defined by the increment, or step size, that it uses when reading its lookup table.  This explains why <emphasis role="bold">osc</emphasis> is connected to the <emphasis role="bold">freqPp</emphasis> patchpoint through the <emphasis role="bold">setIncInput:</emphasis> method:</para>

<para>[theTemplate to:osc sel:@selector(setIncInput:) arg:freqPp];</para>

<para>Oscgafi's <emphasis role="bold">incAtFreq:</emphasis> method is provided to translate frequencies into increments.  This, too, will be used when applying parameter values.</para>

<para><emphasis>Asymp and Asympenv</emphasis></para>

<para>The Asymp and Asympenv <classname>MKUnitGenerator</classname>s are envelope handlers; they translates the data in an <classname>MKEnvelope</classname> object and load it onto the DSP.  An <classname>MKEnvelope</classname> object is associated with an Asymp  or Asympenv through the <emphasis role="bold">MKUpdateAsymp()</emphasis> function. The only difference between Asymp and Asympenv is that the former allows for arbitrarily long envelopes and the latter is better-suited to interactive real-time applications.</para>

<para>Envy uses two Asympenvs, one to control the frequency of Oscgafi and the other to control its amplitude.  The leaf classes are chosen to match the memory arguments in Oscgafi:  The Asympenv leaf class that controls amplitude is AsympenvUGx; for frequency, it's AsympenvUGy.</para>

<title>Playing the Patch</title>

<para>A number of new conventions for playing and controlling a <classname>MKSynthPatch</classname> are introduced in the following sections.  In particular, the conventions regarding preemption, rearticulation, and &#170;sticky&#186; parameters are demonstrated.</para>

<sectx id="DeclaringTheParameters">
<title>Declaring the Parameters</title>

<para>A convention of <classname>MKSynthPatch</classname> design (one that wasn't followed in the implementation of Simplicity) is to create an instance variable for each parameter the <classname>MKSynthPatch</classname> responds to.  The variables are used to maintain the state of the object's patch.</para>

<para>Because of the introduction of envelope control into the patch, Envy responds to several more parameters than did Simplicity.  These are shown as they are declared as instance variables in the <classname>MKSynthPatch</classname>'s interface file (<emphasis role="bold">Envy.h</emphasis>):</para>

<programlisting>
@interface Envy:SynthPatch
{
    /* Amplitude parameters. */
    id      ampEnv;         /* the Envelope object for amplitude */
    double  amp1,           /* amplitude at y=1 */
            amp0,           /* amplitude at y=0 */
            ampAtt,         /* ampEnv attack duration in seconds */
            ampRel;         /* ampEnv release duration in seconds*/
    /* Frequency parameters. */ 
    id      freqEnv;        /* the Envelope object for frequency */
    double  freq1,          /* frequency at y=1 */
            freq0,          /* frequency at y=0 */
            freqAtt,        /* freqEnv attack duration in seconds*/
            freqRel;        /* freqEnv release duration in seconds */
    /* Other parameters. */
    double  portamento;     /* transition time in seconds */ 
    double  bearing;        /* stereo location */
}
</programlisting>

<para>A set of defaults for the parameter instance variables should also be included in a <classname>MKSynthPatch</classname> design.  Envy implements a method called <emphasis role="bold">setDefaults</emphasis> to provide this:</para>

<programlisting>
- setDefaults
{
    ampEnv     = nil;
    amp0       = 0.0;
    amp1       = MK_DEFAULTAMP;         /* 0.1 */
    ampAtt     = MK_NODVAL;             /* parameter not present */
    ampRel     = MK_NODVAL;             /* parameter not present */
    freqEnv    = nil;
    freq0      = 0.0;
    freq1      = MK_DEFAULTFREQ;        /* 440.0 */
    freqAtt    = MK_NODVAL;             /* parameter not present */
    freqRel    = MK_NODVAL;             /* parameter not present */
    portamento = MK_DEFAULTPORTAMENTO;  /* 0.1 */
    bearing    = MK_DEFAULTBEARING;     /* 0.0 (center) */
    return self;
}
</programlisting>

<para>By convention, a <classname>MKSynthPatch</classname>'s parameter instance variables should be set to their default values before the <classname>MKSynthPatch</classname> begins a new phrase.  This is done by invoking <emphasis role="bold">setDefaults</emphasis> from the <emphasis role="bold">noteEndSelf</emphasis> method.  Keep in mind that <emphasis role="bold">noteEnd</emphasis>, which invokes <emphasis role="bold">noteEndSelf</emphasis>, is invoked when a new <classname>MKSynthPatch</classname> is created, so <emphasis role="bold">setDefaults:</emphasis> will be invoked before the first <classname>MKNote</classname> arrives as well as after the end of each phrase.</para>

<para>However, one other condition must be considered&horbar;that of the preempted <classname>MKSynthPatch</classname>&horbar;which, by definition, isn't sent the <emphasis role="bold">noteEnd</emphasis> message.  The <classname>MKSynthPatch</classname> class defines a method <emphasis role="bold">preemptFor:</emphasis> that you can redefine in your subclass to reset the parameter instance variables to their default values and to provide any other special behavior for a preempted <classname>MKSynthPatch</classname>.  The method is invoked just before the <classname>MKSynthPatch</classname> receives, in a <emphasis role="bold">noteOn:</emphasis> message, the <classname>MKNote</classname> for which it was preempted (the argument to <emphasis role="bold">preemptFor:</emphasis> is this same <classname>MKNote</classname>).  Envy implements <emphasis role="bold">preemptFor:</emphasis> to preempt the amplitude <classname>MKEnvelope</classname> and invoke <emphasis role="bold">setDefaults:</emphasis>.  It ignores the argument:</para>

<programlisting>
- preemptFor:aNote
{
    [[self synthElementAt:ampAsymp] preemptEnvelope];
    [self setDefaults];
    return self;
}
</programlisting>

<para><emphasis>The noteOnSelf: and noteUpdateSelf: Methods</emphasis></para>

<para>These two methods follow the same form as those in Simplicity:</para>

<programlisting>
- noteOnSelf:aNote
{
    /* Apply the parameters to the patch. */
    [self applyParameters:aNote];
    /* Make the final connection to the output sample stream.*/
    [[self synthElementAt:stereoOut] setInput:outPp];
    /* Tell the UnitGenerators to begin running. */
    [synthElements makeObjectsPerform:@selector(run)];
    return self;
}
- noteUpdateSelf:aNote
{
    /* Apply the parameters to the patch. */
    [self applyParameters:aNote];
    return self;
}
</programlisting>

<para>Once again, both methods invoke <emphasis role="bold">applyParameters:</emphasis> to apply the Note's parameters to the patch.  In addition, <emphasis role="bold">noteOnSelf:</emphasis> completes the connection between Oscgafi and Out2sum, and it tells the <classname>MKUnitGenerator</classname>s to run by sending <emphasis role="bold">run</emphasis> to each of the synthElements.</para>

<para><emphasis>The noteOffSelf: and noteEndSelf Methods</emphasis></para>

<para>Recall that the value returned by <emphasis role="bold">noteOffSelf:</emphasis> is taken as the amount of time to wait (in seconds) before <emphasis role="bold">noteEnd</emphasis> is invoked.  Typically, this value is the release time of the <classname>MKSynthPatch</classname>'s amplitude <classname>MKEnvelope</classname>:</para>

<programlisting>
- (double)noteOffSelf:aNote
{
    /* Apply the parameters. */
    [self applyParameters: aNote];
    /* Signal the release portion of the frequency Envelope. */
    [[self synthElementAt:freqAsymp] finish];
    /* Same for amplitude, but also return the release duration. */
    return [[self synthElementAt:ampAsymp] finish];
}
</programlisting>

<para>An Asympenv responds to the <emphasis role="bold">finish</emphasis> message by signaling the release portion of its <classname>MKEnvelope</classname>; the method returns the duration of the release.</para>

<para>As in Simplicity, <emphasis role="bold">noteEndSelf</emphasis>
sends <emphasis role="bold">idle</emphasis> to the Out2sum object to
remove it from the output sample stream.  It also aborts the frequency
<classname>MKEnvelope</classname> (we're assured that the amplitude
<classname>MKEnvelope</classname> has finished since its demise is
what causes this method to be invoked) and then invokes the <emphasis
role="bold">setDefaults</emphasis> method, as dictated in <xref
linkend="DeclaringTheParameters">, above.</para>

<programlisting>
- noteEndSelf
{
     /* Remove the patch's Out2sum from the output sample stream. */
    [[self synthElementAt:stereoOut] idle];
    /* Abort the frequency Envelope. */
    [[self synthElementAt:freqAsymp] abortEnvelope];
    /* Set the instance variables to their default values. */
    [self setDefaults];
    return self;
}
</programlisting>

<para><emphasis>Phrase Status</title>

<para>The manner in which a Note's parameters are applied to a patch can depend on the performance context in which the <classname>MKSynthPatch</classname> receives the <classname>MKNote</classname>.  This context, called <emphasis>phrase status</emphasis>, is represented as an MKPhraseStatus constant and is automatically set when the <classname>MKSynthPatch</classname> receives a phrase event message (such as <emphasis role="bold">noteOn:</emphasis> and <emphasis role="bold">noteUpdate:</emphasis>).  There are seven phrase states:</para>

<listitem><para><emphasis role="bold">MK_phraseOn</emphasis> means that the received <classname>MKNote</classname> is a noteOn and the <classname>MKSynthPatch</classname> has been freshly allocated to synthesize the <classname>MKNote</classname>.  This status indicates the beginning of a new phrase.</para>

<listitem><para><emphasis role="bold">MK_phraseRearticulate</emphasis> indicates a noteOn that rearticulates an existing phrase.</para>

<listitem><para><emphasis role="bold">MK_phraseOnPreempt</emphasis> is also used for noteOns, but it indicates that the <classname>MKSynthPatch</classname> has been preempted to synthesize the <classname>MKNote</classname>.  Like <emphasis role="bold">MK_phraseOn</emphasis>, this status means that a new phrase is beginning.</para>

<listitem><para><emphasis role="bold">MK_phraseUpdate</emphasis> means that the <classname>MKNote</classname> is a noteUpdate and the <classname>MKSynthPatch</classname> is in the attack or stickpoint portions of its <classname>MKEnvelope</classname>s (the <classname>MKSynthPatch</classname>'s synthStatus is <emphasis role="bold">MK_running</emphasis>).</para>

<listitem><para><emphasis role="bold">MK_phraseOff</emphasis> indicates a noteOff.</para>

<listitem><para><emphasis role="bold">MK_phraseOffUpdate</emphasis> is for a noteUpdate that arrives during the release portion of the <classname>MKEnvelope</classname>s (synthStatus is <emphasis role="bold">MK_finishing</emphasis>).</para>

<listitem><para><emphasis role="bold">MK_phraseEnd</emphasis> is used to indicate the end of a phrase.</para>

<para>A <classname>MKSynthPatch</classname>'s phrase status, which is retrieved by sending <emphasis role="bold">phraseStatus</emphasis> to the <classname>MKSynthPatch</classname>, is provided solely as a convenience to <classname>MKSynthPatch</classname> designers and is only valid within the implementations of the <emphasis role="bold">noteOnSelf:</emphasis>, <emphasis role="bold">noteUpdateSelf:</emphasis>, <emphasis role="bold">noteOffSelf:</emphasis>, and <emphasis role="bold">noteEndSelf</emphasis> methods.  Sent to a <classname>MKSynthPatch</classname> from outside these methods, <emphasis role="bold">phraseStatus</emphasis> returns <emphasis role="bold">MK_noPhraseActivity</emphasis>.</para>

<para>You can use phrase status in the design of your <classname>MKSynthPatch</classname> in a test that leads to specialized behavior.  For example, you may want to apply certain noteUpdate parameters differently, depending on whether the phrase status is <emphasis role="bold">MK_phraseUpdate</emphasis> or <emphasis role="bold">MK_phraseOffUpdate</emphasis>.  Two conventional uses of phrase status&horbar;as an argument to the <emphasis role="bold">MKUpdateAsymp()</emphasis> function and to determine if a <classname>MKNote</classname> is the beginning of a new phrase&horbar;are demonstrated in the next section.</para>

<para><emphasis>Applying Parameters</title>

<para>The way that Envy applies a Note's parameters is more sophisticated than the manner employed by Simplicity.  A convention ignored in the design of Simplicity holds that a noteOn that rearticulates a phrase should inherit, if necessary, the values of the parameters in the phrase so far.  For example, if a rearticulating noteOn doesn't contain an amplitude <classname>MKEnvelope</classname>, it uses the one set in the previous noteOn.  The implementation of Envy accommodates this by storing its parameter values as instance variables:  It can supply a &#170;missing&#186; parameter by using the value stored in the appropriate variable.</para>

<para>Determining the correct value for amplitude and frequency is more complicated in the implementation of Envy than in that of Simplicity.  Because of its use of <classname>MKEnvelope</classname> objects, Envy's amplitude and frequency depend on the values of a number of related parameters.  The MusicKit provides a C function called <emphasis role="bold">MKUpdateAsymp()</emphasis> that helps to untangle this web.  The function takes, as arguments, all the objects and parameter values associated with a particular <classname>MKEnvelope</classname> and applies them in a predictable manner to the attribute that the <classname>MKEnvelope</classname> controls.  </para>

<para><emphasis role="bold">MKUpdateAsymp()</emphasis> takes eight arguments:</para>

<para>1.	An Asymp or Asympenv object </para>

<para>2.	An <classname>MKEnvelope</classname> object </para>

<para>3.	The <classname>MKEnvelope</classname>'s value when y = 0.0</para>

<para>4.	The <classname>MKEnvelope</classname>'s value when y = 1.0</para>

<para>5.	The <classname>MKEnvelope</classname>'s attack time </para>

<para>6.	The <classname>MKEnvelope</classname>'s release time </para>

<para>7.	The portamento value (not currently supported for Asympenv)</para>

<para>8.	The current phrase status</para>

<para>The function's behavior is described in the Volume 2, Chapter 3.  Briefly, it applies an <classname>MKEnvelope</classname> (argument 2) to an Asymp or Asympenv (argument 1) after properly scaling the <classname>MKEnvelope</classname>'s value range (arguments 3 and 4) and setting its attack and release times (arguments 5 and 6).  Portamento (argument 7) is used only if the phrase status (argument 8) is <emphasis role="bold">MK_phraseRearticulate</emphasis>.</para>

<para>Envy's implementation of the <emphasis role="bold">applyParameters:</emphasis> method demonstrates the conventional way to apply parameters to a patch that includes <classname>MKEnvelope</classname>s:</para>

<programlisting>
- applyParameters:aNote
{
    /* Retrieve and store the parameters. */
    id     myAmpEnv     = [aNote parAsEnvelope:MK_ampEnv];
    double myAmp0       = [aNote parAsDouble:MK_amp0];
    double myAmp1       = [aNote parAsDouble:MK_amp1];
    double myAmpAtt     = [aNote parAsDouble:MK_ampAtt];
    double myAmpRel     = [aNote parAsDouble:MK_ampAtt];
    id     myFreqEnv    = [aNote parAsEnvelope:MK_freqEnv];
    double myFreq0      = [aNote parAsDouble:MK_freq0];
    double myFreq1      = [aNote freq];
    double myFreqAtt    = [aNote parAsDouble:MK_freqAtt];
    double myFreqRel    = [aNote parAsDouble:MK_freqRel];
    double myPortamento = [aNote parAsDouble:MK_portamento];
    double myBearing    = [aNote parAsDouble:MK_bearing];
    /* Store the phrase status. */
    MKPhraseStatus phraseStatus = [self phraseStatus];
    /* Is aNote a noteOn? */
    BOOL isNoteOn = [aNote noteType] == MK_noteOn;
    /* Is aNote the beginning of a new phrase? */
    BOOL isNewPhrase = (phraseStatus == MK_phraseOn) ||
                        (phraseStatus == MK_phraseOnPreempt);
    /* Used in the parameter checks. */
    BOOL shouldApplyAmp = NO;
    BOOL shouldApplyFreq = NO;
    BOOL shouldApplyBearing = NO;
    /* The same portamento is used in both frequency and amplitude. */
    if ( !MKIsNoDVal(myPortamento) ) {
        portamento = myPortamento;
        shouldApplyAmp = YES;
        shouldApplyFreq = YES; }
    /* Check the amplitude parameters and set the instance 
       variables. */
    if (myAmpEnv != nil) {
        ampEnv = myAmpEnv;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmp0)) {
        amp0 = myAmp0;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmp1)) {
        amp1 = myAmp1;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmpAtt)) {
        ampAtt = myAmpAtt;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmpRel)) {
        ampRel = myAmpRel;
        shouldApplyAmp = YES; }
    /* Apply the amplitude parameters. */
    if (shouldApplyAmp || isNoteOn)
        MKUpdateAsymp([self synthElementAt:ampAsymp], 
                        ampEnv, amp0, amp1, ampAtt, ampRel,
                        portamento, phraseStatus);
    /* Check the frequency parameters and set the instance 
       variables. */
    if (myFreqEnv != nil) {
        freqEnv = myFreqEnv;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreq0)) {
        freq0 = myFreq0;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreq1)) {
        freq1 = myFreq1;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreqAtt)) {
        freqAtt = myFreqAtt;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreqRel)) {
        freqRel = myFreqRel;
        shouldApplyFreq = YES; }
    /* Apply the frequency parameters. */
    if (shouldApplyFreq || isNoteOn)
        MKUpdateAsymp([self synthElementAt:freqAsymp], freqEnv,
                        [[self synthElementAt:osc] incAtFreq:freq0],
                        [[self synthElementAt:osc] incAtFreq:freq1],
                        freqAtt, freqRel, portamento, phraseStatus);
    /* Check and set the bearing. */
    if (!MKIsNoDVal(myBearing)) {
        bearing = myBearing;
        shouldApplyBearing = YES; }
    if (shouldApplyBearing || isNewPhrase)
        [[self synthElementAT:stereoOut] setBearing:bearing];
    return self;
}
</programlisting>

<para>As in Simplicity's implementation of <emphasis role="bold">applyParameters:</emphasis>, the value of each parameter is stored and then checked to determine whether the parameter is actually present in the argument <classname>MKNote</classname>.  In addition, this implementation updates the values of the instance variables to those of the parameters that are present.</para>

<para>Each parameter that affects amplitude is checked in its own conditional statement.  If the parameter is present, the <emphasis role="bold">shouldApplyAmp</emphasis> variable is set to YES, indicating that the amplitude <classname>MKEnvelope</classname> needs to be updated.  Finally, the value of <emphasis role="bold">shouldApplyAmp</emphasis> is logically or'd with the value of <emphasis role="bold">isNoteOn</emphasis>, which is YES if <emphasis role="bold">aNote</emphasis> is a noteOn.  Thus, the <emphasis role="bold">MKUpdateAsymp()</emphasis> call for amplitude is made if any of the tested parameters are present, and it's always made if <emphasis role="bold">aNote</emphasis> is a noteOn.</para>

<para>The conditionals for applying the frequency parameters are the same as those for amplitude.  Notice, however, that the <emphasis role="bold">freq0</emphasis> and <emphasis role="bold">freq1</emphasis> values aren't passed directly to <emphasis role="bold">MKUpdateAsymp()</emphasis>.  Instead, they're used to retrieve increment values from <emphasis role="bold">osc</emphasis> through its <emphasis role="bold">incAtFreq:</emphasis> method.  As mentioned earlier, Oscgafi's frequency value isn't set as a frequency in hertz, but rather as an increment into its lookup table.</para>

<para>Finally, the bearing parameter is tested, its instance variable
is set, and the parameter is applied to the patch.  Notice that
bearing is automatically applied if <emphasis
role="bold">aNote</emphasis> is the beginning of a new phrase.  Unlike
amplitude and frequency, bearing isn't controlled by an
<classname>MKEnvelope</classname>, so it doesn't need to be
automatically applied if the <classname>MKNote</classname> is simply a
rearticulation of an existing phrase.</para>

<title>Adding a <classname>MKWaveTable</classname></title>

<para>Envy, although otherwise entertaining, is of limited timbral interest&horbar;it can only produce a sine wave.  Replacing Envy's sine wave with a <classname>MKWaveTable</classname> is quite simple; its patch isn't affected, nor are the implementations of the <emphasis role="bold">noteOnSelf:</emphasis> type methods.  The only real change is in the implementation of <emphasis role="bold">applyParameters:</emphasis>.</para>

<para>First, however, you must provide an instance variable and default value for <emphasis role="bold">MK_waveform</emphasis>&horbar;the parameter that identifies <classname>MKSynthPatch</classname>'s <classname>MKWaveTable</classname> object:</para>

<programlisting>
@interface Envy:SynthPatch
{
    id waveform;
    . . .
}
- setDefaults
{
    waveform = nil;
    . . .
}
</programlisting>

<para>The <emphasis role="bold">applyParameters:</emphasis> method is rewritten to attend to the new parameter:</para>

<programlisting>
- applyParameters:aNote
{
    . . .
    /* Create local variables for the new parameter. */
    id  myWaveform = [aNote parAsWaveTable:MK_waveform];
    BOOL shouldApplyWave = NO;
    /* Test the parameters. */
    if (myWaveform != nil) {
        waveform = myWaveform;
        shouldApplyWave = YES; }
    if (shouldApplyWave || isNewPhrase)
    [[self synthElementAt:osc] setTable:waveform length:0
                                defaultToSineROM:isNewPhrase];
    . . .
}
</programlisting>

<para>The <emphasis role="bold">setTable:length:defaultToSineROM:</emphasis> method sets the oscillator's lookup table to the specified <classname>MKWaveTable</classname> object.  Passing 0 as the length of the table causes the MusicKit to compute a default value.  The argument to <emphasis role="bold">defaultToSineROM:</emphasis> is a BOOL value that determines whether the sineROM should be used if memory for the <classname>MKWaveTable</classname> can't be allocated.  In this implementation, the argument is YES only if <emphasis role="bold">aNote</emphasis> is the beginning of a new phrase.  For all other phrase states, the previously set <classname>MKWaveTable</classname> is used if a new one can't be allocated.</para>

<para>WaveTables are shared among <classname>MKSynthPatch</classname>es&horbar;if two <classname>MKSynthPatch</classname>es declare the same <classname>MKWaveTable</classname> object (with the same length), the <classname>MKWaveTable</classname> is allocated once and the <classname>MKSynthPatch</classname>es read from the same memory.  This feature is provided automatically by all the Oscg-type oscillators.</para>

<title>Doing Real-time Sound Processing</title>

<para>One of the most exciting aspects of the MusicKit is the ability to process sound in real time, under arbitrarily rich control.   To do this, you follow all the guidelines given above.  There are only three differences:	</para>

								    <orderedlist>
<listitem><para>You must connect hardware that accepts sound input to the DSP serial port.	</para>
								      </listitem>

<listitem><para>You must set up the <classname>MKOrchesra</classname> to do sound processing.	</para>
								      </listitem>

<listitem><para>You must have an In1aUG or In1bUG in your <classname>MKSynthPatch</classname>.</para>
								      </listitem>
								    </orderedlist>

<para>The standard NeXT configuration (at the time of this writing) does not include a high-quality sound input.  Therefore, in order to do real-time high-quality sound processing, you need to obtain a device that plugs into the DSP serial port.  See Using the DSP Serial Port above for how to set up the hardware and how to configure the <classname>MKOrchestra</classname>.</para>

<title>Making a <classname>MKSynthPatch</classname> to do Sound Processing</title>

<para>Making a <classname>MKSynthPatch</classname> that  does sound processing is simple.  You just include an instance of In1aUG to get the left  sound input channel or In1bUG to get the right sound input channel.  These <classname>MKUnitGenerator</classname>s write their input to an output patchpoint.  They also optionally provide a scale factor.  Thus, you can convert  the <classname>MKWaveTable</classname> synthesis <classname>MKSynthPatch</classname> described above to a sound processing synthpatch by merely replacing the oscillator with an In1aUG.  </para>

<title>Creating a <classname>MKUnitGenerator</classname> Subclass</title>

<para>Each <classname>MKUnitGenerator</classname> subclass is an object-oriented interface to a DSP macro, called a <emphasis>unit generator</emphasis>, that's written in DSP56001 assembly language.  The Objective-C code in the subclass is generated automatically from a DSP macro by the <emphasis role="bold">dspwrap</emphasis> program.  To build your own <classname>MKUnitGenerator</classname> subclass that you can use in <classname>MKSynthPatch</classname> design, you run <emphasis role="bold">dspwrap</emphasis> on a DSP56001 assembly language macro that you've created.  In addition, you can modify and wrap the DSP macros that NeXT provides as source code in the directory <emphasis role="bold">/usr/local/lib/dsp/ugsrc</emphasis>.  </para>

<para>The design of DSP assembly language macros is outside the scope of the present discussion.  The following sections show how to use <emphasis role="bold">dspwrap</emphasis> and how to further modify the <classname>MKUnitGenerator</classname>s that it creates.</para>

<title>Using dspwrap</title>

<para>The <emphasis role="bold">dspwrap</emphasis> program is used to create array processing C functions as well as <classname>MKUnitGenerator</classname> subclasses.  To indicate that you want to create the latter, you call the program with the <emphasis role="bold">-ug</emphasis> switch followed by the name of the file that contains the assembly code macro (you must include the &#170;.asm&#186; extension when specifying the file).  For example, the invocation </para>

<para>dspwrap -ug unoisehp.asm</para>

<para>creates a master <classname>MKUnitGenerator</classname> class called UnoisehpUG as well as the appropriate leaf classes.  These are embodied in the following files, which are automatically generated by <emphasis role="bold">dspwrap</emphasis>:</para>

<listitem><para><emphasis role="bold">UnoisehpUG.m</emphasis> is the implementation file of the master class.</para>

<listitem><para><emphasis role="bold">UnoisehpUG.h</emphasis> is the master class interface file.</para>

<listitem><para><emphasis role="bold">UnoisehpUGx.m</emphasis> and <emphasis role="bold">UnoisehpUGy.m</emphasis> are leaf class implementations.</para>

<listitem><para><emphasis role="bold">UnoisehpUGx.h</emphasis> and<emphasis role="bold"> UnoisehpUGy.h</emphasis> are the leaf interface files.</para>

<listitem><para><emphasis role="bold">unoisehpUGInclude.m</emphasis> is imported by the master class.</para>

<para>The number of leaf classes that are created depends on the number of address-valued memory arguments, described below, in the macro:  A different leaf class is created for each combination of x and y DSP memory spaces.  The <emphasis role="bold">unoisehp</emphasis> macro, which implements a high-pass random number generator, has only one such argument&horbar;its output&horbar;so two leaf classes are generated, one for either memory space.</para>

<para>Some other files, such as documentation and DSP assembler and linker files, are also created.  These can be moved, deleted, or disregarded as you see fit.  For the present purposes, only the files listed above are important.</para>

<title>Modifying the Class</title>

<para>There are two basic reasons to modify a <classname>MKUnitGenerator</classname> class that's generated by <emphasis role="bold">dspwrap</emphasis>:</para>

<listitem><para>To set the values of the DSP memory arguments that are passed to the macro</para>

<listitem><para>To define the class's response to some common messages</para>

<para>Of the files generated by <emphasis role="bold">dspwrap</emphasis>, you should modify only those that define the master class.  In other words, continuing with the Unoisehp example, only <emphasis role="bold">UnoisehpUG.m</emphasis> and <emphasis role="bold">UnoisehpUG.h</emphasis> should be edited.  The entire implementation file of the UnoisehpUG master class as generated by <emphasis role="bold">dspwrap</emphasis> is shown below:</para>

<programlisting>
#import &lt;musickit/musickit.h&gt;
#import "UnoisehpUG.h"
@implementation UnoisehpUG:UnitGenerator
{}
/* DSP memory arguments. */
enum args { aout, seed};
#import "unoisehpUGInclude.m"
</programlisting>

<title>Setting the Arguments</title>

<para>The two <emphasis role="bold">enum</emphasis> variables shown above, <emphasis role="bold">aout</emphasis> and <emphasis role="bold">seed</emphasis>, are DSP memory arguments.  A memory argument represents a location on the DSP from which the unit generator that's executing can read information sent to it by the MusicKit.  There are two types of memory arguments:</para>

<listitem><para>Address-valued arguments administer the location in DSP memory from which, or to which, the executing unit generator reads or writes data.</para>

<listitem><para>Datum-valued arguments take a value that's used as part of the unit generator's computation.</para>

<para>In the example, <emphasis role="bold">aout</emphasis> variable is an address-valued argument that represents the <classname>MKUnitGenerator</classname>'s output patchpoint.  We create a Unoisehp method named <emphasis role="bold">setOutput:</emphasis> that sets this argument:</para>

<programlisting>
-setOutput:outputPatchPoint
{
    return [self setAddressArg:aout to:outputPatchPoint];
}
</programlisting>

<para>The <emphasis role="bold">setAddressArg:to:</emphasis> method is defined by <classname>MKUnitGenerator</classname> to set an address-valued DSP memory argument.  </para>

<para>The other <emphasis role="bold">enum</emphasis> variable, <emphasis role="bold">seed</emphasis>, is a datum-valued memory argument.  It's set through <classname>MKUnitGenerator</classname>'s <emphasis role="bold">setDatumArg:to: </emphasis>method, as demonstrated in our implementation of Unoisehp's <emphasis role="bold">setSeed: </emphasis>method:</para>

<programlisting>
-setSeed:(int)aSeed
{
    return [self setDatumArg:seed to:aSeed];
}
</programlisting>

<title>Defining the Class's Response</title>

<para>During a performance, a <classname>MKUnitGenerator</classname> can expect to receive the following messages:</para>

<listitem><para><emphasis role="bold">run</emphasis> tells the receiver to begin doing whatever it does.</para>

<listitem><para><emphasis role="bold">finish</emphasis> winds down the receiver before coming to a halt.</para>

<listitem><para><emphasis role="bold">idle</emphasis> provides instructions for halting the receiver's activity.</para>

<para>Invocations of these methods were shown in the implementations
of the Simplicity and Envy <classname>MKSynthPatch</classname>es.
Remember that <emphasis role="bold">finish </emphasis>returns the
amount of time the <classname>MKUnitGenerator</classname> needs to
complete its mission&horbar;the amount of time to wait before
<emphasis role="bold">idle</emphasis> should be sent.  The default
implementations of these methods can be sufficient.  For further
tuning, you should implement, in your master class, the methods
<emphasis role="bold">runSelf</emphasis>, <emphasis
role="bold">finishSelf</emphasis>, and <emphasis
role="bold">idleSelf</emphasis>&horbar;methods that are automatically
invoked when the corresponding performance messages are
received.</para>

<para>You almost always provide an implementation of <emphasis role="bold">idleSelf </emphasis>to ensure that your <classname>MKUnitGenerator</classname> is brought to a halt in a manner befitting its activity.  The Unoisehp implementation of this method sets its output to the DSP's <emphasis>sink</emphasis>, a location that, by convention, is never read:</para>

<programlisting>
-idleSelf
{
    /* Set the output (aout) to sink. */
    [self setAddressArgToSink:aout];
    return self;
}
</programlisting>
  </chapter>
