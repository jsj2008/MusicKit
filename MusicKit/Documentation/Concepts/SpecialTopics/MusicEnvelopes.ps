%!PS-Adobe-2.0
%%Title: MusicEnvelopes.ma  -  /user/daj/doc
%%Creator: Mathematica
%%CreationDate: Thu Oct 22 16:42:03 1992
%%For: daj
%%DocumentFonts: (atend)
%%Pages: (atend) 1
%%BoundingBox: (atend)
%%DocumentPaperSizes: Letter
%%Orientation: Portrait
%%NXNextStepVersion: 3.0
%%EndComments

%%BeginProcSet: /usr/lib/NextStep/printPackage.ps 3.0
%!
% NeXT Printing Package
% Version: 3.0
% Copyright: 1988, NeXT, Inc.

/__NXdef{1 index where{pop pop pop}{def}ifelse}bind def
/__NXbdef{1 index where{pop pop pop}{bind def}ifelse}bind def
/UserObjects 10 array __NXdef
/defineuserobject{
	exch dup 1 add dup UserObjects length gt{
		array dup 0 UserObjects putinterval
		/UserObjects exch def
	}{pop}ifelse UserObjects exch 3 -1 roll put
}__NXbdef
/undefineuserobject{UserObjects exch null put}__NXbdef
/execuserobject{UserObjects exch get exec}__NXbdef
/__NXRectPath{4 2 roll moveto 1 index 0 rlineto
0 exch rlineto neg 0 rlineto closepath}__NXbdef
/__NXProcessRectArgs{
	1 index type /arraytype eq{
		exch 0 4 2 index length 1 sub{
			dup 3 add 1 exch{1 index exch get exch}for
			5 1 roll 5 index exec
		}for pop pop
	}{exec}ifelse
}__NXbdef
/rectfill{gsave newpath {__NXRectPath fill} __NXProcessRectArgs grestore}__NXbdef
/rectclip{newpath {__NXRectPath} __NXProcessRectArgs clip newpath}__NXbdef
/rectstroke{
	gsave newpath dup type /arraytype eq{dup length 6 eq}{false}ifelse{
		{gsave __NXRectPath null concat stroke grestore}
		dup length array cvx copy dup 2 4 -1 roll put __NXProcessRectArgs
	}{{__NXRectPath stroke} __NXProcessRectArgs}ifelse grestore
}__NXbdef
/_NXLevel2 systemdict /languagelevel known {languagelevel 2 ge}{false}ifelse __NXdef
/xyshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index 2 mul 1 add get add exch
		3 index	3 index 2 mul get add exch moveto pop
	}for pop pop
}__NXbdef
/xshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		exch 3 index 3 index get add exch moveto pop
	}for pop pop
}__NXbdef
/yshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index get add moveto pop
	}for pop pop
}__NXbdef
/arct{arcto pop pop pop pop}__NXbdef
/setbbox{pop pop pop pop}__NXbdef
/ucache{}__NXbdef
/ucachestatus{mark 0 0 0 0 0}__NXbdef
/setucacheparams{cleartomark}__NXbdef
/uappend{systemdict begin cvx exec end}__NXbdef
/ueofill{gsave newpath uappend eofill grestore}__NXbdef
/ufill{gsave newpath uappend fill grestore}__NXbdef
/ustroke{
	gsave newpath dup length 6 eq
	{exch uappend concat}{uappend}ifelse
	stroke grestore
}__NXbdef
/__NXustrokepathMatrix dup where {pop pop}{matrix def}ifelse
/ustrokepath{
	newpath dup length 6 eq{
		exch uappend __NXustrokepathMatrix currentmatrix exch concat
		strokepath setmatrix
	}{uappend strokepath}ifelse
} __NXbdef
/upath{
	[exch {/ucache cvx}if pathbbox /setbbox cvx
	 {/moveto cvx}{/lineto cvx}{/curveto cvx}{/closepath cvx}pathforall]cvx
} __NXbdef
/setstrokeadjust{pop}__NXbdef
/currentstrokeadjust{false}__NXbdef
/selectfont{exch findfont exch
dup type /arraytype eq {makefont}{scalefont}ifelse setfont}__NXbdef
/_NXCombineArrays{
	counttomark dup 2 add index dup length 3 -1 roll {
		2 index length sub dup 4 1 roll 1 index exch 4 -1 roll putinterval exch
	}repeat pop pop pop
}__NXbdef
/flushgraphics{}def
/setwindowtype{pop pop}def
/currentwindowtype{pop 0}def
/setalpha{pop}def
/currentalpha{1.0}def
/hidecursor{}def
/obscurecursor{}def
/revealcursor{}def
/setcursor{4 {pop}repeat}bind def
/showcursor{}def
/NextStepEncoding where not{
/NextStepEncoding StandardEncoding 256 array copy def
0 [129/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/Ccedilla/Egrave
/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/Ugrave/Uacute
/Ucircumflex/Udieresis/Yacute/Thorn/mu/multiply/divide/copyright
176/registered 181/brokenbar 190/logicalnot 192/onesuperior 201/twosuperior
204/threesuperior 209/plusminus/onequarter/onehalf/threequarters/agrave
/aacute/acircumflex/atilde/adieresis/aring/ccedilla/egrave/eacute
/ecircumflex/edieresis/igrave 226/iacute 228/icircumflex/idieresis/eth
/ntilde 236/ograve/oacute/ocircumflex/otilde/odieresis 242/ugrave/uacute
/ucircumflex 246/udieresis/yacute 252/thorn/ydieresis]
{dup type /nametype eq
 {NextStepEncoding 2 index 2 index put pop 1 add}{exch pop}ifelse
}forall pop
/NextStepEncoding NextStepEncoding readonly def
/_NXfstr 128 string dup 0 (_NX) putinterval def
/_NXfindfont /findfont load def
/findfont{
 % Because we can never let NextStepEncoding get into
 % SharedFontDirectory, we cannot reencode a font to NextStepEncoding
 % if we are in shared mode.  So if currentshared is true,
 % we call the normal findfont and return that
 /currentshared where {pop currentshared} {false} ifelse
 {_NXfindfont}
 {dup _NXfstr 3 125 getinterval cvs length 3 add _NXfstr 0 3 -1 roll
  getinterval cvn exch FontDirectory 2 index known 
  {pop FontDirectory exch get}
  {_NXfindfont dup /Encoding get StandardEncoding eq
   {	dup length dict exch
	{1 index /FID ne {2 index 3 1 roll put}{pop pop}ifelse}forall
	 dup /Encoding NextStepEncoding put definefont
	}{exch pop} ifelse
   }ifelse
 }ifelse
}bind def
}{pop}ifelse
/_NXImageString {/__NXImageString where{pop}{/__NXImageString 4000 string __NXdef}ifelse __NXImageString}__NXbdef
/_NXDoImageOp{
	3 dict begin /parr 5 array def 1 index{dup}{1}ifelse /chans exch def
	chans 2 add 2 roll parr 0 chans getinterval astore pop
	5 index 4 index mul 2 index{1 sub 8 idiv 1 add mul}{mul 1 sub 8 idiv 1 add}ifelse
	4 index mul /totbytes exch def pop exch pop
	gsave matrix invertmatrix concat 0.5 setgray 0 0 4 2 roll rectfill grestore
	{0 1 chans 1 sub{parr exch get exec length totbytes exch sub /totbytes exch def}for totbytes 0 le{exit}if}loop end
}__NXbdef
/alphaimage{1 add _NXDoImageOp}def
_NXLevel2{ 
	/NXCalibratedRGBColorSpace where{pop}{
		/NXCalibratedRGBColorSpace
		{mark /NXCalibratedRGB /ColorSpace findresource exch pop}stopped
		{cleartomark /NXCalibratedRGB[/CIEBasedABC 2 dict dup begin 
		/MatrixLMN[.4124 .2126 .0193 .3576 .7152 .1192 .1805 .0722 .9505]def
		/WhitePoint[.9505 1 1.089] def end] /ColorSpace defineresource}if def}ifelse
	/nxsetrgbcolor{NXCalibratedRGBColorSpace setcolorspace setcolor}__NXbdef
	/nxsetgray{dup dup nxsetrgbcolor}__NXbdef
	/_NXCalibratedImage{exch{array astore dup length true}{false}ifelse
		8 -1 roll{NXCalibratedRGBColorSpace setcolorspace}if
		8 dict dup 9 1 roll begin /ImageType 1 def /MultipleDataSources exch def
		currentcolorspace 0 get /Indexed eq{pop /Decode[0 2 6 index exp 1 sub]def}
		{2 mul dup array /Decode exch def 1 sub 0 1 3 -1 roll{Decode exch dup 2 mod put}for}ifelse
		/DataSource exch def /ImageMatrix exch def 
		/BitsPerComponent exch def /Height exch def /Width exch def end image}__NXbdef
} {
	/setcmykcolor{
		1.0 exch sub dup dup 6 -1 roll sub dup 0 lt{pop 0}if 5 1 roll
		4 -1 roll sub dup 0 lt{pop 0}if 3 1 roll exch sub dup 0 lt{pop 0}if setrgbcolor}__NXbdef
	/currentcmykcolor{currentrgbcolor 3{1.0 exch sub 3 1 roll}repeat 0}__NXbdef
	/colorimage{_NXDoImageOp}__NXbdef
	/nxsetrgbcolor{setrgbcolor}__NXbdef /nxsetgray{setgray}__NXbdef
	/setpattern{pop .5 setgray}__NXbdef
	/_NXCalibratedImage{dup 1 eq {pop pop image}{colorimage}ifelse pop}__NXbdef
} ifelse
/_NXSetCMYKOrRGB where{pop}{
	mark{systemdict /currentwindow get exec}stopped
	{{pop pop pop setcmykcolor}}{{nxsetrgbcolor pop pop pop pop}}ifelse /_NXSetCMYKOrRGB exch def cleartomark
}ifelse
%%EndProcSet

_NXLevel2{/_NXsethsb where{pop}{/_NXsethsb /sethsbcolor load def}ifelse /sethsbcolor{_NXsethsb currentrgbcolor nxsetrgbcolor}def /setrgbcolor{nxsetrgbcolor}bind def /setgray{nxsetgray}bind def
}if
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
%%EndProlog
%%BeginSetup
%%PaperSize: Letter
%%EndSetup

%%Page: 1 1
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 76 447 58 rectclip
gsave
74 76 1.677618e+07 58 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 445.969971 57.969971 rectfill
/Times-Bold findfont 24 scalefont [1 0 0 -1 0 0] makefont
24
exch
defineuserobject
24 execuserobject setfont
0 nxsetgray
87 23 moveto (The Smoothing Parameter) show
103 52 moveto (in Music Kit Envelopes) show
grestore
gsave
24 execuserobject setfont
0 nxsetgray
74 76 1.677618e+07 58 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 445.969971 57.969971 rectfill
24 execuserobject setfont
0 nxsetgray
87 23 moveto (The Smoothing Parameter) show
103 52 moveto (in Music Kit Envelopes) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 142 447 18 rectclip
gsave
24 execuserobject setfont
0 nxsetgray
74 142 1.677618e+07 18 rectclip
74 142 translate
1 nxsetgray
0.010002 0.019989 445.969971 17.970001 rectfill
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
167 14 moveto (by Julius O. Smith) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 168 447 28 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 168 1.677618e+07 28 rectclip
74 168 translate
1 nxsetgray
0.010002 0.019989 445.969971 27.970001 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
197 11 moveto (NeXT Inc.) show
190 25 moveto (July 11, 1991) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
0.5 setgray
59 209 12 12 rectfill
0 setgray
59 209 moveto 70 209 lineto 70 220 lineto 59 220 lineto closepath
stroke
gsave
74 204 447 21 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 204 1.677617e+07 21 rectclip
74 204 translate
1 nxsetgray
0.010002 0.019989 445.969971 20.970001 rectfill
/Times-Bold findfont 18 scalefont [1 0 0 -1 0 0] makefont
27
exch
defineuserobject
27 execuserobject setfont
0 nxsetgray
2 17 moveto (Introduction) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 237 9 9 rectfill
gsave
74 233 447 18 rectclip
gsave
27 execuserobject setfont
0 nxsetgray
74 233 1.677616e+07 18 rectclip
74 233 translate
1 nxsetgray
0.010002 0.019989 445.969971 17.970001 rectfill
25 execuserobject setfont
0 nxsetgray
2 14 moveto (Definition of an Envelope) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 259 447 84 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 259 1.677616e+07 84 rectclip
74 259 translate
1 nxsetgray
0.010002 0.019989 445.969971 83.970001 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (A Music Kit "envelope" is a function of time specified by a list of "breakpoints".  Each) show
2 25 moveto ("breakpoint" is specified by two or three numbers.  In the two-number case, you specify the) show
2 39 moveto (time of the breakpoint and desired value of the envelope at that point.    The envelope itself) show
2 53 moveto (is a piecewise exponential function.  The desired value at each breakpoint is approached) show
2 67 moveto (exponentially from the previous breakpoint.  Exponential functions are discussed below.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 355 9 9 rectfill
gsave
74 351 447 18 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 351 1.677616e+07 18 rectclip
74 351 translate
1 nxsetgray
0.010002 0.019989 445.969971 17.970001 rectfill
25 execuserobject setfont
0 nxsetgray
2 14 moveto (Definition of the Envelope Smoothing Parameter) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 377 447 42 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 377 1.677616e+07 42 rectclip
74 377 translate
1 nxsetgray
0.010002 0.02002 445.969971 41.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (The optional third parameter in a breakpoint specification is called "smoothness".  It) show
2 25 moveto (controls the relaxation time-constant used in approaching each "target value" in the) show
2 39 moveto (envelope.  The actual definition is the following:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 427 447 36 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 427 1.677616e+07 36 rectclip
74 427 translate
1 nxsetgray
0.010002 0.02002 445.969971 35.969971 rectfill
25 execuserobject setfont
0 nxsetgray
5 14 moveto (Smoothness is defined as the number of repetitions of the time interval to) show
42 32 moveto (the next breakpoint needed to reach that breakpoint's value.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 471 447 112 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 471 1.677616e+07 112 rectclip
74 471 translate
1 nxsetgray
0.010002 0.02002 445.969971 111.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Thus, the most natural choice of smoothness S is S=1.  This means the envelope will just) show
2 25 moveto (about reach the next envelope breakpoint value at the time specified for that breakpoint.) show
2 39 moveto (Setting S=0 means the envelope will instantly jump to the next breakpoint.  Setting S=2) show
2 53 moveto (means the envelope will about reach the next breakpoint value at two times the distance to) show
2 67 moveto (the next breakpoint; this is "smoother" than S=1.  It also means that using values of S larger) show
2 81 moveto (than 1 means setting breakpoint target values which are larger \(when going up\) than you) show
2 95 moveto (actually expect to reach.  In fact, if there were no maximum number limit on the DSP, you) show
2 109 moveto (could take S to infinity and get a piecewise linear envelope.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
0.5 setgray
59 596 12 12 rectfill
0 setgray
59 596 moveto 70 596 lineto 70 607 lineto 59 607 lineto closepath
stroke
gsave
74 591 447 21 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 591 1.677617e+07 21 rectclip
74 591 translate
1 nxsetgray
0.010002 0.02002 445.969971 20.969971 rectfill
27 execuserobject setfont
0 nxsetgray
2 17 moveto (Exponential Envelopes) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 624 9 9 rectfill
gsave
74 620 447 18 rectclip
gsave
27 execuserobject setfont
0 nxsetgray
74 620 1.677616e+07 18 rectclip
74 620 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
25 execuserobject setfont
0 nxsetgray
2 14 moveto (The Exponential Decay) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 646 447 28 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 646 1.677616e+07 28 rectclip
74 646 translate
1 nxsetgray
0.010002 0.02002 445.969971 27.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (First lets look at an exponential decay.  This is like the end of an envelope when it is) show
2 25 moveto (decaying to zero.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 682 447 26 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 682 1.677616e+07 26 rectclip
74 682 translate
1 nxsetgray
0.010002 0.02002 447.969971 25.969971 rectfill
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[f1,A,tau,t]; ) show
142 10 moveto ( \(* Clear any previous definitions *\)) show
2 23 moveto (f1[t_] := A Exp[-t/tau];  \(* tau = exponential time constant *\)) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (1) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Times-Bold
%%+ Times-Roman

%%Page: 2 2
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 76 447 42 rectclip
gsave
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
74 76 1.677616e+07 42 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 445.969971 41.969971 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (For t>0, f1[t] is the function used for the final decay of every envelope, where A is the) show
2 25 moveto (value of the envelope when the decay starts  \(nominally the value of the last nonzero) show
2 39 moveto (breakpoint\)..) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
63 129.666672 moveto 70 129.666672 lineto 70 136.666672 lineto 63 136.666672 lineto closepath
stroke
gsave
74 126 447 15 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 126 1.677615e+07 15 rectclip
74 126 translate
1 nxsetgray
0.010002 0.019989 445.969971 14.970001 rectfill
/Times-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
83
exch
defineuserobject
83 execuserobject setfont
0 nxsetgray
2 12 moveto (Example Plots) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 149 447 78 rectclip
gsave
83 execuserobject setfont
0 nxsetgray
74 149 1.677615e+07 78 rectclip
74 149 translate
1 nxsetgray
0.010002 0.019989 447.969971 77.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (A = 1;) show
114 10 moveto (\(* A = amplitude \(units arbitrary\) *\)) show
2 23 moveto (tau = 3;) show
114 23 moveto (\(* time constant = 3 seconds *\)) show
2 36 moveto (Plot[f1[t],{t,0,tau},) show
30 49 moveto (PlotRange->{0,A},) show
30 62 moveto (AxesLabel->{"time\(sec\)",""},) show
30 75 moveto (PlotLabel->"Decay by factor 1/e"];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 235 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	411.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.31746 0 0.61803 [
[(Decay by factor 1/e)] 0.5 0.62428 0 -1 Msboxa
[(0.5)] 0.18254 -0.0125 0 1 Msboxa
[(1)] 0.34127 -0.0125 0 1 Msboxa
[(1.5)] 0.5 -0.0125 0 1 Msboxa
[(2)] 0.65873 -0.0125 0 1 Msboxa
[(2.5)] 0.81746 -0.0125 0 1 Msboxa
[(3)] 0.97619 -0.0125 0 1 Msboxa
[(time\(sec\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Decay by factor 1/e)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.18254 -0.00625 moveto
0.18254 0.00625 lineto
stroke
0 setgray
[(0.5)] 0.18254 -0.0125 0 1 Mshowa
0.34127 -0.00625 moveto
0.34127 0.00625 lineto
stroke
0 setgray
[(1)] 0.34127 -0.0125 0 1 Mshowa
0.5 -0.00625 moveto
0.5 0.00625 lineto
stroke
0 setgray
[(1.5)] 0.5 -0.0125 0 1 Mshowa
0.65873 -0.00625 moveto
0.65873 0.00625 lineto
stroke
0 setgray
[(2)] 0.65873 -0.0125 0 1 Mshowa
0.81746 -0.00625 moveto
0.81746 0.00625 lineto
stroke
0 setgray
[(2.5)] 0.81746 -0.0125 0 1 Mshowa
0.97619 -0.00625 moveto
0.97619 0.00625 lineto
stroke
0 setgray
[(3)] 0.97619 -0.0125 0 1 Mshowa
0 setgray
[(time\(sec\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
gsave
0.004 setlinewidth
0.02381 0.61803 moveto
0.06349 0.59281 lineto
0.10317 0.56862 lineto
0.14286 0.54541 lineto
0.18254 0.52315 lineto
0.22222 0.5018 lineto
0.2619 0.48133 lineto
0.30159 0.46168 lineto
0.34127 0.44284 lineto
0.38095 0.42477 lineto
0.42063 0.40743 lineto
0.46032 0.39081 lineto
0.5 0.37486 lineto
0.53968 0.35956 lineto
0.57937 0.34488 lineto
0.61905 0.33081 lineto
0.65873 0.31731 lineto
0.69841 0.30436 lineto
0.7381 0.29194 lineto
0.77778 0.28002 lineto
0.81746 0.2686 lineto
0.85714 0.25763 lineto
0.89683 0.24712 lineto
0.93651 0.23704 lineto
0.97619 0.22736 lineto
stroke
grestore
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 419 447 14 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 419 1.677615e+07 14 rectclip
74 419 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (It takes several time constants to decay really close to zero:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 441 447 52 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 441 1.677615e+07 52 rectclip
74 441 translate
1 nxsetgray
0.010002 0.02002 447.969971 51.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Plot[f1[t],{t,0,3*tau},) show
30 23 moveto (PlotRange->{0,A},) show
30 36 moveto (AxesLabel->{"time\(sec\)",""},) show
30 49 moveto (PlotLabel->"Decay by 3 time constants"];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 501 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	677.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.10582 0 0.61803 [
[(Decay by 3 time constants)] 0.5 0.62428 0 -1 Msboxa
[(2)] 0.23545 -0.0125 0 1 Msboxa
[(4)] 0.44709 -0.0125 0 1 Msboxa
[(6)] 0.65873 -0.0125 0 1 Msboxa
[(8)] 0.87037 -0.0125 0 1 Msboxa
[(time\(sec\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Decay by 3 time constants)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.23545 -0.00625 moveto
0.23545 0.00625 lineto
stroke
0 setgray
[(2)] 0.23545 -0.0125 0 1 Mshowa
0.44709 -0.00625 moveto
0.44709 0.00625 lineto
stroke
0 setgray
[(4)] 0.44709 -0.0125 0 1 Mshowa
0.65873 -0.00625 moveto
0.65873 0.00625 lineto
stroke
0 setgray
[(6)] 0.65873 -0.0125 0 1 Mshowa
0.87037 -0.00625 moveto
0.87037 0.00625 lineto
stroke
0 setgray
[(8)] 0.87037 -0.0125 0 1 Mshowa
0 setgray
[(time\(sec\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
gsave
0.004 setlinewidth
0.02381 0.61803 moveto
0.06349 0.54541 lineto
0.10317 0.48133 lineto
0.14286 0.42477 lineto
0.18254 0.37486 lineto
0.22222 0.33081 lineto
0.2619 0.29194 lineto
0.30159 0.25763 lineto
0.34127 0.22736 lineto
0.38095 0.20065 lineto
0.42063 0.17707 lineto
0.46032 0.15626 lineto
0.5 0.1379 lineto
0.53968 0.1217 lineto
0.57937 0.1074 lineto
0.61905 0.09478 lineto
0.65873 0.08364 lineto
0.69841 0.07381 lineto
0.7381 0.06514 lineto
0.77778 0.05749 lineto
0.81746 0.05073 lineto
0.85714 0.04477 lineto
0.89683 0.03951 lineto
0.93651 0.03487 lineto
0.97619 0.03077 lineto
stroke
grestore
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 689 9 9 rectfill
gsave
74 685 447 18 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 685 1.677616e+07 18 rectclip
74 685 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
2 14 moveto (T60) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (2) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Times-Bold
%%+ Times-Roman

%%Page: 3 3
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 76 447 56 rectclip
gsave
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
74 76 1.677616e+07 56 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 445.969971 55.969971 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (In audio, a reasonable definition of the end of an exponential envelope is when the final) show
2 25 moveto (decay drops the level by 60 decibels \(dB\).  This decay time for exponentials is called t60 in) show
2 39 moveto (the reverberation literature.  Since Amp_dB = 20 Log[10,Amp], this means we have the) show
2 53 moveto (formula) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
63 143.666672 moveto 70 143.666672 lineto 70 150.666672 lineto 63 150.666672 lineto closepath
stroke
gsave
74 140 447 15 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 140 1.677615e+07 15 rectclip
74 140 translate
1 nxsetgray
0.010002 0.019989 445.969971 14.970001 rectfill
/Times-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
83
exch
defineuserobject
83 execuserobject setfont
0 nxsetgray
2 12 moveto (Derivation of t60) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 163 447 26 rectclip
gsave
83 execuserobject setfont
0 nxsetgray
74 163 1.677615e+07 26 rectclip
74 163 translate
1 nxsetgray
0.010002 0.019989 447.969971 25.970001 rectfill
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[A,tau,t60];) show
2 23 moveto (-60 == 20 Log[10,f1[t60]/A]) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 197 447 54 rectclip
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 0 0 setrgbcolor
74 205 moveto
(               -\(t60/tau\)\012) show
74 219 moveto
(       20 Log[E          ]\012) show
74 233 moveto
(-60 == -------------------\012) show
77.5 233 moveto
(       ------------------  ) show
74 247 moveto
(             Log[10]) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 259 447 42 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 259 1.677615e+07 42 rectclip
74 259 translate
1 nxsetgray
0.010002 0.019989 445.969971 41.970001 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (We divide by A because we are interested in the decay factor, not the absolute final value.) show
2 25 moveto (Solving the above equation for t60 can be done as follows.  First divide both sides by 20,) show
2 39 moveto (then raise 10 to the value on each side to get) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 309 447 13 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 309 1.677615e+07 13 rectclip
74 309 translate
1 nxsetgray
0.010002 0.019989 447.969971 12.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (0.001 == f1[t60]/A) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 330 447 26 rectclip
84 execuserobject setfont
0 0 0 setrgbcolor
74 338 moveto
(          -\(t60/tau\)\012) show
74 352 moveto
(0.001 == E) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 364 447 13 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 364 1.677615e+07 13 rectclip
74 364 translate
1 nxsetgray
0.010002 0.02002 447.969971 12.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Solve[%,t60]) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 385 447 39 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 385 1.677615e+07 39 rectclip
74 385 translate
1 nxsetgray
0.010002 0.02002 447.969971 38.969971 rectfill
84 execuserobject setfont
0 nxsetgray
2 10 moveto (Solve::ifun: ) show
2 23 moveto (   Warning: inverse functions are being used by Solve,) show
2 36 moveto (    so some solutions may not be found.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 432 447 12 rectclip
84 execuserobject setfont
0 0 0 setrgbcolor
74 440 moveto
({{t60 -> 6.90776 tau}}) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 452 447 14 rectclip
gsave
84 execuserobject setfont
0 nxsetgray
74 452 1.677616e+07 14 rectclip
74 452 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Thus, t60 is about 7 time constants, or 6.91 tau to 3 digits accuracy.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
63 477.666656 moveto 70 477.666656 lineto 70 484.666656 lineto 63 484.666656 lineto closepath
stroke
gsave
74 474 447 15 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 474 1.677615e+07 15 rectclip
74 474 translate
1 nxsetgray
0.010002 0.02002 445.969971 14.969971 rectfill
83 execuserobject setfont
0 nxsetgray
2 12 moveto (Pictures of 60 dB Decay) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 497 447 91 rectclip
gsave
83 execuserobject setfont
0 nxsetgray
74 497 1.677615e+07 91 rectclip
74 497 translate
1 nxsetgray
0.010002 0.019989 447.969971 90.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (A = 1;) show
2 23 moveto (tau = 3;) show
2 36 moveto (t60 = 6.91 tau;) show
2 49 moveto (Plot[f1[t],{t,0,t60},) show
30 62 moveto (PlotRange->{0,A},) show
30 75 moveto (AxesLabel->{"time\(sec\)",""},) show
30 88 moveto (PlotLabel->"Decay of -60 dB"];) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (3) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Bold
%%+ Times-Roman

%%Page: 4 4
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 76 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	252.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04594 0 0.61803 [
[(Decay of -60 dB)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.25352 -0.0125 0 1 Msboxa
[(10)] 0.48323 -0.0125 0 1 Msboxa
[(15)] 0.71294 -0.0125 0 1 Msboxa
[(20)] 0.94265 -0.0125 0 1 Msboxa
[(time\(sec\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Decay of -60 dB)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.25352 -0.00625 moveto
0.25352 0.00625 lineto
stroke
0 setgray
[(5)] 0.25352 -0.0125 0 1 Mshowa
0.48323 -0.00625 moveto
0.48323 0.00625 lineto
stroke
0 setgray
[(10)] 0.48323 -0.0125 0 1 Mshowa
0.71294 -0.00625 moveto
0.71294 0.00625 lineto
stroke
0 setgray
[(15)] 0.71294 -0.0125 0 1 Mshowa
0.94265 -0.00625 moveto
0.94265 0.00625 lineto
stroke
0 setgray
[(20)] 0.94265 -0.0125 0 1 Mshowa
0 setgray
[(time\(sec\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
gsave
0.004 setlinewidth
0.02381 0.61803 moveto
0.06349 0.46342 lineto
0.10317 0.34748 lineto
0.14286 0.26055 lineto
0.18254 0.19537 lineto
0.22222 0.14649 lineto
0.2619 0.10984 lineto
0.30159 0.08236 lineto
0.34127 0.06176 lineto
0.38095 0.04631 lineto
0.42063 0.03472 lineto
0.46032 0.02604 lineto
0.5 0.01952 lineto
0.53968 0.01464 lineto
0.57937 0.01098 lineto
0.61905 0.00823 lineto
0.65873 0.00617 lineto
0.69841 0.00463 lineto
0.7381 0.00347 lineto
0.77778 0.0026 lineto
0.81746 0.00195 lineto
0.85714 0.00146 lineto
0.89683 0.0011 lineto
0.93651 0.00082 lineto
0.97619 0.00062 lineto
stroke
grestore
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 260 447 14 rectclip
gsave
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
74 260 1.677615e+07 14 rectclip
74 260 translate
1 nxsetgray
0.010002 0.019989 445.969971 13.970001 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Same thing on a dB scale:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 282 447 52 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 282 1.677615e+07 52 rectclip
74 282 translate
1 nxsetgray
0.010002 0.019989 447.969971 51.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Plot[20 Log[10,f1[t]],{t,0,t60},) show
30 23 moveto (PlotRange->{-60,20 Log[10,A]},) show
30 36 moveto (AxesLabel->{"time\(sec\)",""},) show
30 49 moveto (PlotLabel->"Decay of -60 dB on a dB scale"];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 342 447 13 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 342 1.677615e+07 13 rectclip
74 342 translate
1 nxsetgray
0.010002 0.019989 447.969971 12.970001 rectfill
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 nxsetgray
2 10 moveto (General::dby0: Division by zero.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 363 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	539.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04594 0.61803 0.0103 [
[(Decay of -60 dB on a dB scale)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.25352 0.60553 0 1 Msboxa
[(10)] 0.48323 0.60553 0 1 Msboxa
[(15)] 0.71294 0.60553 0 1 Msboxa
[(20)] 0.94265 0.60553 0 1 Msboxa
[(time\(sec\))] 1.00625 0.61803 -1 0 Msboxa
[(-60)] 0.01131 0 1 0 Msboxa
[(-50)] 0.01131 0.10301 1 0 Msboxa
[(-40)] 0.01131 0.20601 1 0 Msboxa
[(-30)] 0.01131 0.30902 1 0 Msboxa
[(-20)] 0.01131 0.41202 1 0 Msboxa
[(-10)] 0.01131 0.51503 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.001 0 0 ]
[ 1.001 0.62528 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Decay of -60 dB on a dB scale)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0.61803 moveto
1 0.61803 lineto
stroke
0.25352 0.61178 moveto
0.25352 0.62428 lineto
stroke
0 setgray
[(5)] 0.25352 0.60553 0 1 Mshowa
0.48323 0.61178 moveto
0.48323 0.62428 lineto
stroke
0 setgray
[(10)] 0.48323 0.60553 0 1 Mshowa
0.71294 0.61178 moveto
0.71294 0.62428 lineto
stroke
0 setgray
[(15)] 0.71294 0.60553 0 1 Mshowa
0.94265 0.61178 moveto
0.94265 0.62428 lineto
stroke
0 setgray
[(20)] 0.94265 0.60553 0 1 Mshowa
0 setgray
[(time\(sec\))] 1.00625 0.61803 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0 moveto
0.03006 0 lineto
stroke
0 setgray
[(-60)] 0.01131 0 1 0 Mshowa
0.01756 0.10301 moveto
0.03006 0.10301 lineto
stroke
0 setgray
[(-50)] 0.01131 0.10301 1 0 Mshowa
0.01756 0.20601 moveto
0.03006 0.20601 lineto
stroke
0 setgray
[(-40)] 0.01131 0.20601 1 0 Mshowa
0.01756 0.30902 moveto
0.03006 0.30902 lineto
stroke
0 setgray
[(-30)] 0.01131 0.30902 1 0 Mshowa
0.01756 0.41202 moveto
0.03006 0.41202 lineto
stroke
0 setgray
[(-20)] 0.01131 0.41202 1 0 Mshowa
0.01756 0.51503 moveto
0.03006 0.51503 lineto
stroke
0 setgray
[(-10)] 0.01131 0.51503 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
gsave
0.004 setlinewidth
0.02381 0.61803 moveto
0.06349 0.59227 lineto
0.10317 0.56651 lineto
0.14286 0.54075 lineto
0.18254 0.51499 lineto
0.22222 0.48924 lineto
0.2619 0.46348 lineto
0.30159 0.43772 lineto
0.34127 0.41196 lineto
0.38095 0.3862 lineto
0.42063 0.36044 lineto
0.46032 0.33468 lineto
0.5 0.30892 lineto
0.53968 0.28316 lineto
0.57937 0.2574 lineto
0.61905 0.23164 lineto
0.65873 0.20588 lineto
0.69841 0.18012 lineto
0.7381 0.15436 lineto
0.77778 0.1286 lineto
0.81746 0.10284 lineto
0.85714 0.07708 lineto
0.89683 0.05132 lineto
0.93651 0.02556 lineto
0.97619 -0.0002 lineto
stroke
grestore
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 551 9 9 rectfill
gsave
74 547 447 18 rectclip
gsave
84 execuserobject setfont
0 nxsetgray
74 547 1.677616e+07 18 rectclip
74 547 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
2 14 moveto (Exponentials which Approach a Non-Zero Asymptote) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 573 447 14 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 573 1.677616e+07 14 rectclip
74 573 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Note that the function) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 595 447 26 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 595 1.677615e+07 26 rectclip
74 595 translate
1 nxsetgray
0.010002 0.02002 447.969971 25.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[A,tau];) show
2 23 moveto (f2[t_] = A-f1[t]) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 629 447 54 rectclip
84 execuserobject setfont
0 0 0 setrgbcolor
74 637 moveto
(      A\012) show
74 651 moveto
(A - ------\012) show
77.5 651 moveto
(    -----  ) show
74 665 moveto
(     t/tau\012) show
74 679 moveto
(    E) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 691 447 14 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 691 1.677616e+07 14 rectclip
74 691 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (approaches A starting from 0:) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (4) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Bold
%%+ Times-Roman

%%Page: 5 5
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 76 447 78 rectclip
gsave
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
74 76 1.677615e+07 78 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 447.969971 77.969971 rectfill
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
2 10 moveto (A=1;) show
2 23 moveto (tau=3;) show
2 36 moveto (Plot[f2[t],{t,0,t60},) show
30 49 moveto (PlotRange->{0,A},) show
30 62 moveto (AxesLabel->{"time\(sec\)",""},) show
30 75 moveto (PlotLabel->"Exponential approach to A=1"];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 162 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	338.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04594 0 0.61803 [
[(Exponential approach to A=1)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.25352 -0.0125 0 1 Msboxa
[(10)] 0.48323 -0.0125 0 1 Msboxa
[(15)] 0.71294 -0.0125 0 1 Msboxa
[(20)] 0.94265 -0.0125 0 1 Msboxa
[(time\(sec\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Exponential approach to A=1)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.25352 -0.00625 moveto
0.25352 0.00625 lineto
stroke
0 setgray
[(5)] 0.25352 -0.0125 0 1 Mshowa
0.48323 -0.00625 moveto
0.48323 0.00625 lineto
stroke
0 setgray
[(10)] 0.48323 -0.0125 0 1 Mshowa
0.71294 -0.00625 moveto
0.71294 0.00625 lineto
stroke
0 setgray
[(15)] 0.71294 -0.0125 0 1 Mshowa
0.94265 -0.00625 moveto
0.94265 0.00625 lineto
stroke
0 setgray
[(20)] 0.94265 -0.0125 0 1 Mshowa
0 setgray
[(time\(sec\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
gsave
0.004 setlinewidth
0.02381 0 moveto
0.06349 0.15462 lineto
0.10317 0.27055 lineto
0.14286 0.35748 lineto
0.18254 0.42267 lineto
0.22222 0.47154 lineto
0.2619 0.50819 lineto
0.30159 0.53567 lineto
0.34127 0.55628 lineto
0.38095 0.57173 lineto
0.42063 0.58331 lineto
0.46032 0.592 lineto
0.5 0.59851 lineto
0.53968 0.6034 lineto
0.57937 0.60706 lineto
0.61905 0.6098 lineto
0.65873 0.61186 lineto
0.69841 0.61341 lineto
0.7381 0.61456 lineto
0.77778 0.61543 lineto
0.81746 0.61608 lineto
0.85714 0.61657 lineto
0.89683 0.61694 lineto
0.93651 0.61721 lineto
0.97619 0.61742 lineto
stroke
grestore
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 346 447 42 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 346 1.677616e+07 42 rectclip
74 346 translate
1 nxsetgray
0.010002 0.019989 445.969971 41.970001 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (When approaching a constant breakpoint value A1 given an initial value A0 at time 0, the) show
2 25 moveto (formula to use is like the one above, but adding in the initial value A0, and using A1-A0) show
2 39 moveto (\(the amplitude difference\) in place of A:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 396 447 39 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 396 1.677615e+07 39 rectclip
74 396 translate
1 nxsetgray
0.010002 0.02002 447.969971 38.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[A,tau];) show
2 23 moveto (A = A1-A0;) show
2 36 moveto (f3[t_] = A0 + f2[t]) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 443 447 26 rectclip
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 0 0 setrgbcolor
74 451 moveto
(     -\(t/tau\)\012) show
74 465 moveto
(2 - E) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 477 447 14 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 477 1.677616e+07 14 rectclip
74 477 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Let's plot this for some sample values:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 499 447 91 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 499 1.677615e+07 91 rectclip
74 499 translate
1 nxsetgray
0.010002 0.019989 447.969971 90.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (A0=1;) show
2 23 moveto (A1=2;) show
2 36 moveto (tau=3;) show
2 49 moveto (Plot[f3[t],{t,0,t60},) show
30 62 moveto (PlotRange->{0,A1},) show
30 75 moveto (AxesLabel->{"time\(sec\)",""},) show
30 88 moveto (PlotLabel->"Exp glide from A0=1 to A1=2"];) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (5) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Roman

%%Page: 6 6
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 76 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	252.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04594 0 0.30902 [
[(Exp glide from A0=1 to A1=2)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.25352 -0.0125 0 1 Msboxa
[(10)] 0.48323 -0.0125 0 1 Msboxa
[(15)] 0.71294 -0.0125 0 1 Msboxa
[(20)] 0.94265 -0.0125 0 1 Msboxa
[(time\(sec\))] 1.00625 0 -1 0 Msboxa
[(0.25)] 0.01131 0.07725 1 0 Msboxa
[(0.5)] 0.01131 0.15451 1 0 Msboxa
[(0.75)] 0.01131 0.23176 1 0 Msboxa
[(1)] 0.01131 0.30902 1 0 Msboxa
[(1.25)] 0.01131 0.38627 1 0 Msboxa
[(1.5)] 0.01131 0.46353 1 0 Msboxa
[(1.75)] 0.01131 0.54078 1 0 Msboxa
[(2)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Exp glide from A0=1 to A1=2)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.25352 -0.00625 moveto
0.25352 0.00625 lineto
stroke
0 setgray
[(5)] 0.25352 -0.0125 0 1 Mshowa
0.48323 -0.00625 moveto
0.48323 0.00625 lineto
stroke
0 setgray
[(10)] 0.48323 -0.0125 0 1 Mshowa
0.71294 -0.00625 moveto
0.71294 0.00625 lineto
stroke
0 setgray
[(15)] 0.71294 -0.0125 0 1 Mshowa
0.94265 -0.00625 moveto
0.94265 0.00625 lineto
stroke
0 setgray
[(20)] 0.94265 -0.0125 0 1 Mshowa
0 setgray
[(time\(sec\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.07725 moveto
0.03006 0.07725 lineto
stroke
0 setgray
[(0.25)] 0.01131 0.07725 1 0 Mshowa
0.01756 0.15451 moveto
0.03006 0.15451 lineto
stroke
0 setgray
[(0.5)] 0.01131 0.15451 1 0 Mshowa
0.01756 0.23176 moveto
0.03006 0.23176 lineto
stroke
0 setgray
[(0.75)] 0.01131 0.23176 1 0 Mshowa
0.01756 0.30902 moveto
0.03006 0.30902 lineto
stroke
0 setgray
[(1)] 0.01131 0.30902 1 0 Mshowa
0.01756 0.38627 moveto
0.03006 0.38627 lineto
stroke
0 setgray
[(1.25)] 0.01131 0.38627 1 0 Mshowa
0.01756 0.46353 moveto
0.03006 0.46353 lineto
stroke
0 setgray
[(1.5)] 0.01131 0.46353 1 0 Mshowa
0.01756 0.54078 moveto
0.03006 0.54078 lineto
stroke
0 setgray
[(1.75)] 0.01131 0.54078 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(2)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
gsave
0.004 setlinewidth
0.02381 0.30902 moveto
0.06349 0.38633 lineto
0.10317 0.44429 lineto
0.14286 0.48776 lineto
0.18254 0.52035 lineto
0.22222 0.54479 lineto
0.2619 0.56311 lineto
0.30159 0.57685 lineto
0.34127 0.58716 lineto
0.38095 0.59488 lineto
0.42063 0.60067 lineto
0.46032 0.60502 lineto
0.5 0.60827 lineto
0.53968 0.61071 lineto
0.57937 0.61255 lineto
0.61905 0.61392 lineto
0.65873 0.61495 lineto
0.69841 0.61572 lineto
0.7381 0.6163 lineto
0.77778 0.61673 lineto
0.81746 0.61706 lineto
0.85714 0.6173 lineto
0.89683 0.61749 lineto
0.93651 0.61762 lineto
0.97619 0.61773 lineto
stroke
grestore
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 260 447 56 rectclip
gsave
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
74 260 1.677616e+07 56 rectclip
74 260 translate
1 nxsetgray
0.010002 0.019989 445.969971 55.970001 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (A Music Kit envelope is put together by concatenating segments such as the above) show
2 25 moveto (Actually, the segments are not exactly concatenated.  The asymptote gets changed each) show
2 39 moveto (breakpoint, so the envelope just starts approaching the new asymptote from wherever it) show
2 53 moveto (happens to be.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
0.5 setgray
59 329 12 12 rectfill
0 setgray
59 329 moveto 70 329 lineto 70 340 lineto 59 340 lineto closepath
stroke
gsave
74 324 447 21 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 324 1.677617e+07 21 rectclip
74 324 translate
1 nxsetgray
0.010002 0.019989 445.969971 20.970001 rectfill
/Times-Bold findfont 18 scalefont [1 0 0 -1 0 0] makefont
27
exch
defineuserobject
27 execuserobject setfont
0 nxsetgray
2 17 moveto (Sampled Exponentials) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 357 9 9 rectfill
gsave
74 353 447 18 rectclip
gsave
27 execuserobject setfont
0 nxsetgray
74 353 1.677616e+07 18 rectclip
74 353 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
2 14 moveto (Replacing t by n T) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 379 447 28 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 379 1.677616e+07 28 rectclip
74 379 translate
1 nxsetgray
0.010002 0.02002 445.969971 27.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (A digitally sampled exponential is obtained by replacing t with n T, where n is the sample) show
2 25 moveto (number and T is the sampling interval in seconds.  The sampling-rate is denoted fs.  Thus,) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 415 447 13 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 415 1.677616e+07 13 rectclip
74 415 translate
1 nxsetgray
0.010002 0.02002 447.969971 12.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (T = 1/fs;) show
114 10 moveto (\(* Corresponding sampling interval *\)) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 436 447 39 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 436 1.677615e+07 39 rectclip
74 436 translate
1 nxsetgray
0.010002 0.02002 447.969971 38.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[A,tau,T,n];) show
2 23 moveto (t = n T;) show
2 36 moveto (f1d[n_] = f1[t]) show
142 36 moveto (\(* Sampled exponential decay *\)) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 483 447 54 rectclip
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 0 0 setrgbcolor
74 491 moveto
(    A\012) show
74 505 moveto
(----------\012) show
77.5 505 moveto
(---------  ) show
74 519 moveto
( \(T n\)/tau\012) show
74 533 moveto
(E) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 545 447 104 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 545 1.677615e+07 104 rectclip
74 545 translate
1 nxsetgray
0.010002 0.02002 447.969971 103.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[t];) show
2 23 moveto (A=1;) show
2 36 moveto (tau=3;) show
2 49 moveto (T=1;) show
2 62 moveto (ListPlot[Table[f1d[n],{n,t60/T}],) show
30 75 moveto (PlotRange->{0,A},) show
30 88 moveto (AxesLabel->{"time\(samples\)",""},) show
30 101 moveto (PlotLabel->"Sampled exponential decay"];) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (6) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Bold
%%+ Times-Roman

%%Page: 7 7
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 76 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	252.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04762 0 0.61803 [
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.2619 -0.0125 0 1 Msboxa
[(10)] 0.5 -0.0125 0 1 Msboxa
[(15)] 0.7381 -0.0125 0 1 Msboxa
[(20)] 0.97619 -0.0125 0 1 Msboxa
[(time\(samples\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.2619 -0.00625 moveto
0.2619 0.00625 lineto
stroke
0 setgray
[(5)] 0.2619 -0.0125 0 1 Mshowa
0.5 -0.00625 moveto
0.5 0.00625 lineto
stroke
0 setgray
[(10)] 0.5 -0.0125 0 1 Mshowa
0.7381 -0.00625 moveto
0.7381 0.00625 lineto
stroke
0 setgray
[(15)] 0.7381 -0.0125 0 1 Mshowa
0.97619 -0.00625 moveto
0.97619 0.00625 lineto
stroke
0 setgray
[(20)] 0.97619 -0.0125 0 1 Mshowa
0 setgray
[(time\(samples\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
0.008 setlinewidth
0.07143 0.44284 Mdot
0.11905 0.31731 Mdot
0.16667 0.22736 Mdot
0.21429 0.16291 Mdot
0.2619 0.11673 Mdot
0.30952 0.08364 Mdot
0.35714 0.05993 Mdot
0.40476 0.04294 Mdot
0.45238 0.03077 Mdot
0.5 0.02205 Mdot
0.54762 0.0158 Mdot
0.59524 0.01132 Mdot
0.64286 0.00811 Mdot
0.69048 0.00581 Mdot
0.7381 0.00416 Mdot
0.78571 0.00298 Mdot
0.83333 0.00214 Mdot
0.88095 0.00153 Mdot
0.92857 0.0011 Mdot
0.97619 0.00079 Mdot
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 264 9 9 rectfill
gsave
74 260 447 18 rectclip
gsave
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
74 260 1.677616e+07 18 rectclip
74 260 translate
1 nxsetgray
0.010002 0.019989 445.969971 17.970001 rectfill
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
2 14 moveto (Sampled Exponentials are Geometric Sequences) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 286 447 28 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 286 1.677616e+07 28 rectclip
74 286 translate
1 nxsetgray
0.010002 0.019989 445.969971 27.970001 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Note that Exp[-n T / tau] can be written as Exp[-T/tau]^n.) show
2 25 moveto (Define) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 322 447 26 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 322 1.677616e+07 26 rectclip
74 322 translate
1 nxsetgray
0.010002 0.019989 447.969971 25.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (Clear[A,T,tau,g];) show
2 23 moveto (g = Exp[-T/tau];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 356 447 14 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 356 1.677616e+07 14 rectclip
74 356 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Now our basic exponential looks like) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 378 447 13 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 378 1.677615e+07 13 rectclip
74 378 translate
1 nxsetgray
0.010002 0.02002 447.969971 12.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (f1d[n] = A g^n) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 399 447 54 rectclip
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 0 0 setrgbcolor
74 407 moveto
(    A\012) show
74 421 moveto
(----------\012) show
77.5 421 moveto
(---------  ) show
74 435 moveto
( \(T n\)/tau\012) show
74 449 moveto
(E) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 461 447 196 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 461 1.677616e+07 196 rectclip
74 461 translate
1 nxsetgray
0.010002 0.02002 445.969971 195.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (This is the function used by the AsympUG unit generator to compute the samples of an) show
2 25 moveto (exponential.   Note that it can be computed recursively via f1d[n] = g f1d[n-1].   The form) show
2 39 moveto (f1d[n] = g f1d[n-1] + \(1-g\) A gives an exponential approach to the value A \(show this!\).) show
2 53 moveto (This latter recursion is what the AsympUG DSP code actually does each sample, except) show
2 67 moveto (that it uses the variable r = 1-g = 1-Exp[-T/tau], called the "rate".   Thus, the recursion used) show
2 81 moveto (by asymp.asm is) show
38 109 moveto (f1d[n] = \(1-r\) f1d[n-1] + r A) show
2 137 moveto (to approach the value A exponentially with time-constant tau, where r = 1-Exp[-T/tau].) show
2 151 moveto (The rate is so named because when it is at its maximum value of 1 \(tau = 0\), A is reached) show
2 165 moveto (in one sample step, as substitution in the above recurrence immediately shows.  When r is) show
2 179 moveto (at its minimum value of 0 \(tau = infinity\), the exponential never gets to the asymptote A.) show
2 193 moveto (The source code for AsympUG is in /usr/local/lib/dsp/ugsrc/asymp.asm.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 665 447 14 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 665 1.677615e+07 14 rectclip
74 665 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Let's prove its the same function as before:) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (7) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Bold
%%+ Times-Roman

%%Page: 8 8
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 76 447 91 rectclip
gsave
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
74 76 1.677615e+07 91 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 447.969971 90.969971 rectfill
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
2 10 moveto (A=1;) show
2 23 moveto (tau=3;) show
2 36 moveto (T=1;) show
2 49 moveto (ListPlot[Table[f1d[n],{n,t60/T}],) show
30 62 moveto (PlotRange->{0,A},) show
30 75 moveto (AxesLabel->{"time\(samples\)",""},) show
30 88 moveto (PlotLabel->"Sampled exponential decay"];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 175 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	351.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04762 0 0.61803 [
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.2619 -0.0125 0 1 Msboxa
[(10)] 0.5 -0.0125 0 1 Msboxa
[(15)] 0.7381 -0.0125 0 1 Msboxa
[(20)] 0.97619 -0.0125 0 1 Msboxa
[(time\(samples\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.2619 -0.00625 moveto
0.2619 0.00625 lineto
stroke
0 setgray
[(5)] 0.2619 -0.0125 0 1 Mshowa
0.5 -0.00625 moveto
0.5 0.00625 lineto
stroke
0 setgray
[(10)] 0.5 -0.0125 0 1 Mshowa
0.7381 -0.00625 moveto
0.7381 0.00625 lineto
stroke
0 setgray
[(15)] 0.7381 -0.0125 0 1 Mshowa
0.97619 -0.00625 moveto
0.97619 0.00625 lineto
stroke
0 setgray
[(20)] 0.97619 -0.0125 0 1 Mshowa
0 setgray
[(time\(samples\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
0.008 setlinewidth
0.07143 0.44284 Mdot
0.11905 0.31731 Mdot
0.16667 0.22736 Mdot
0.21429 0.16291 Mdot
0.2619 0.11673 Mdot
0.30952 0.08364 Mdot
0.35714 0.05993 Mdot
0.40476 0.04294 Mdot
0.45238 0.03077 Mdot
0.5 0.02205 Mdot
0.54762 0.0158 Mdot
0.59524 0.01132 Mdot
0.64286 0.00811 Mdot
0.69048 0.00581 Mdot
0.7381 0.00416 Mdot
0.78571 0.00298 Mdot
0.83333 0.00214 Mdot
0.88095 0.00153 Mdot
0.92857 0.0011 Mdot
0.97619 0.00079 Mdot
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
0.5 setgray
59 364 12 12 rectfill
0 setgray
59 364 moveto 70 364 lineto 70 375 lineto 59 375 lineto closepath
stroke
gsave
74 359 447 21 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 359 1.677617e+07 21 rectclip
74 359 translate
1 nxsetgray
0.010002 0.02002 445.969971 20.969971 rectfill
/Times-Bold findfont 18 scalefont [1 0 0 -1 0 0] makefont
27
exch
defineuserobject
27 execuserobject setfont
0 nxsetgray
2 17 moveto (The Music Kit Envelope Smoothness Parameter) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 392 9 9 rectfill
gsave
74 388 447 18 rectclip
gsave
27 execuserobject setfont
0 nxsetgray
74 388 1.677616e+07 18 rectclip
74 388 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
2 14 moveto (T48) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 414 447 28 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 414 1.677616e+07 28 rectclip
74 414 translate
1 nxsetgray
0.010002 0.02002 445.969971 27.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Instead of t60, the Music Kit uses "t48" which is the time it takes to decay -48 dB from the) show
2 25 moveto (initial starting value \(in the case of final decay toward zero\).) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 450 447 13 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 450 1.677615e+07 13 rectclip
74 450 translate
1 nxsetgray
0.010002 0.02002 447.969971 12.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (t48taus = -N[Log[10^\(-48/20\)]]) show
226 10 moveto (\(* "t48" in time-constants *\)) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 471 447 12 rectclip
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 0 0 setrgbcolor
74 479 moveto
(5.5262) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 491 447 14 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 491 1.677615e+07 14 rectclip
74 491 translate
1 nxsetgray
0.010002 0.02002 445.969971 13.969971 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Thus, 5.53 time-constants is about 48 dB of decay.) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 513 447 13 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 513 1.677615e+07 13 rectclip
74 513 translate
1 nxsetgray
0.010002 0.02002 447.969971 12.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (-20 Log[10, Exp[ - t48taus tau / tau]]) show
282 10 moveto (\(* test it out *\)) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 534 447 12 rectclip
84 execuserobject setfont
0 0 0 setrgbcolor
74 542 moveto
(48.) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 558 9 9 rectfill
gsave
74 554 447 18 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 554 1.677616e+07 18 rectclip
74 554 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
25 execuserobject setfont
0 nxsetgray
2 14 moveto (Relating Smoothness to Time Constant or Rate) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (8) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Bold
%%+ Times-Roman

%%Page: 9 9
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 76 447 322 rectclip
gsave
/Times-Bold findfont 14 scalefont [1 0 0 -1 0 0] makefont
25
exch
defineuserobject
25 execuserobject setfont
0 nxsetgray
74 76 1.677616e+07 322 rectclip
74 76 translate
1 nxsetgray
0.010002 0.02002 445.969971 321.969971 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Recall that smoothness is defined as the number of breakpoint intervals to reach the next) show
2 25 moveto (breakpoint value.  In this context, "reaching" the next breakpoint value is defined as) show
2 39 moveto (traversing t48 seconds along the exponential which is approaching that breakpoint value.) show
2 53 moveto (Let d denote the time between the current breakpoint and the next breakpoint.  Then, for) show
2 67 moveto (S=1, d must be t48.  For S=2, we want d to be 1/2 of t48, and so on.  Thus, the fundamental) show
2 81 moveto (relation relating smoothness to exponential decay is) show
38 109 moveto (d S = t48) show
2 137 moveto (We found above that t48 was about 5.5 time constants. Thus,) show
38 165 moveto (d S = 5.5262 tau) show
2 193 moveto (\(to 4 digits\).  Since tau is related to r by the formula r = 1-g = 1-Exp[-T/tau], we can solve) show
2 207 moveto (for the AsympUG rate r in terms of S to get) show
38 235 moveto (r = 1 - Exp[-5.5262 / \(d S\)]) show
2 263 moveto (where d is the distance to the next breakpoint in seconds, and S is the smoothing parameter.) show
2 277 moveto (Since the default value for S is 1,  we see that increasing it to 2 corresponds to taking the) show
2 291 moveto (square root of g so that r goes from 1-g to 1-Sqrt[g].  Since g is between 0 and 1, Sqrt[g] is) show
2 305 moveto (always larger than g, so r \(the "rate"\) is made smaller by increasing smoothness.  This) show
2 319 moveto (actually makes sense!) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
62 410 9 9 rectfill
gsave
74 406 447 18 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 406 1.677617e+07 18 rectclip
74 406 translate
1 nxsetgray
0.010002 0.02002 445.969971 17.969971 rectfill
25 execuserobject setfont
0 nxsetgray
2 14 moveto (What AsympUG Does) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 432 447 84 rectclip
gsave
25 execuserobject setfont
0 nxsetgray
74 432 1.677617e+07 84 rectclip
74 432 translate
1 nxsetgray
0.010002 0.019989 445.969971 83.970001 rectfill
26 execuserobject setfont
0 nxsetgray
2 11 moveto (As mentioned above, AsympUG generates an exponential envelope segment using the) show
2 25 moveto (recursion) show
38 53 moveto (f1d[n] = g f1d[n-1] + r A) show
2 81 moveto (Let's demonstrate this recursion for the following example:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 524 447 91 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 524 1.677616e+07 91 rectclip
74 524 translate
1 nxsetgray
0.010002 0.02002 447.969971 90.969971 rectfill
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
2 10 moveto (A = 1;) show
2 23 moveto (tau=3;) show
2 36 moveto (T=1;) show
2 49 moveto (ListPlot[Table[f1d[n],{n,t60/T}],) show
30 62 moveto (PlotRange->{0,A},) show
30 75 moveto (AxesLabel->{"time\(samples\)",""},) show
30 88 moveto (PlotLabel->"Sampled exponential decay"];) show
grestore
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
460 9 moveto (9) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Times-Bold
%%+ Times-Roman

%%Page: 10 10
%%PageBoundingBox: 0 0 612 792
%%PageFonts: (atend)
%%BeginPageSetup
%%PaperSize: Letter
/__NXsheetsavetoken save def
0 0 translate
gsave
-20 9972 translate
 /__NXbasematrix matrix currentmatrix def
grestore
gsave
[1 0 0 -1 -19 10581] concat
19 9789 translate
%%EndPageSetup
gsave
0 0 612 792 rectclip
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 76 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	252.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04762 0 0.61803 [
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.2619 -0.0125 0 1 Msboxa
[(10)] 0.5 -0.0125 0 1 Msboxa
[(15)] 0.7381 -0.0125 0 1 Msboxa
[(20)] 0.97619 -0.0125 0 1 Msboxa
[(time\(samples\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.2619 -0.00625 moveto
0.2619 0.00625 lineto
stroke
0 setgray
[(5)] 0.2619 -0.0125 0 1 Mshowa
0.5 -0.00625 moveto
0.5 0.00625 lineto
stroke
0 setgray
[(10)] 0.5 -0.0125 0 1 Mshowa
0.7381 -0.00625 moveto
0.7381 0.00625 lineto
stroke
0 setgray
[(15)] 0.7381 -0.0125 0 1 Mshowa
0.97619 -0.00625 moveto
0.97619 0.00625 lineto
stroke
0 setgray
[(20)] 0.97619 -0.0125 0 1 Mshowa
0 setgray
[(time\(samples\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
0.008 setlinewidth
0.07143 0.44284 Mdot
0.11905 0.31731 Mdot
0.16667 0.22736 Mdot
0.21429 0.16291 Mdot
0.2619 0.11673 Mdot
0.30952 0.08364 Mdot
0.35714 0.05993 Mdot
0.40476 0.04294 Mdot
0.45238 0.03077 Mdot
0.5 0.02205 Mdot
0.54762 0.0158 Mdot
0.59524 0.01132 Mdot
0.64286 0.00811 Mdot
0.69048 0.00581 Mdot
0.7381 0.00416 Mdot
0.78571 0.00298 Mdot
0.83333 0.00214 Mdot
0.88095 0.00153 Mdot
0.92857 0.0011 Mdot
0.97619 0.00079 Mdot
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 260 447 14 rectclip
gsave
/Courier-Bold findfont 12 scalefont [1 0 0 -1 0 0] makefont
59
exch
defineuserobject
59 execuserobject setfont
0 nxsetgray
74 260 1.677617e+07 14 rectclip
74 260 translate
1 nxsetgray
0.010002 0.019989 445.969971 13.970001 rectfill
/Times-Roman findfont 12 scalefont [1 0 0 -1 0 0] makefont
26
exch
defineuserobject
26 execuserobject setfont
0 nxsetgray
2 11 moveto (Now we'll compute the same samples using AsympUG's recursion:) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 282 447 26 rectclip
gsave
26 execuserobject setfont
0 nxsetgray
74 282 1.677616e+07 26 rectclip
74 282 translate
1 nxsetgray
0.010002 0.019989 447.969971 25.970001 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (g = N[Exp[-T/tau]];) show
2 23 moveto (r = 1-g) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 316 447 12 rectclip
/Courier findfont 12 scalefont [1 0 0 -1 0 0] makefont
84
exch
defineuserobject
84 execuserobject setfont
0 0 0 setrgbcolor
74 324 moveto
(0.283469) show
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
74 336 447 130 rectclip
gsave
59 execuserobject setfont
0 nxsetgray
74 336 1.677616e+07 130 rectclip
74 336 translate
1 nxsetgray
0.010002 0.02002 447.969971 129.969971 rectfill
59 execuserobject setfont
0 nxsetgray
2 10 moveto (npoints = Floor[t60/T];) show
2 23 moveto (env = Table[0,{npoints}];) show
2 36 moveto (Af = 0.0;) show
86 36 moveto (\(* Approached amplitude [experiment!] *\)) show
2 49 moveto (env[[1]]=1.0;) show
114 49 moveto (\(* Initial segment amplitude *\)) show
2 62 moveto (For[n=2,n<=npoints,n=n+1,) show
30 75 moveto (env[[n]] = g env[[n-1]] + r Af];) show
2 88 moveto (ListPlot[env,) show
30 101 moveto (PlotRange->{0,Max[env[[1]],Af]},) show
30 114 moveto (AxesLabel->{"time\(samples\)",""},) show
30 127 moveto (PlotLabel->"Sampled exponential decay"];) show
grestore
grestore
grestore
gsave
54 72 467 648 rectclip
1 setlinewidth 0 setgray
gsave
113 474 282 176 rectclip
/Mnodistort true def
100 dict begin
/Mfixwid true def
/Mrot 0 def
/Mpstart {
    MathPictureStart
} bind def
/Mpend {
    MathPictureEnd
} bind def
/Mscale {
    0 1 0 1
    5 -1 roll
    MathScale
} bind def
/Plain	/Courier findfont def
/Bold	/Courier-Bold findfont def
/Italic /Courier-Oblique findfont def
/MathPictureStart {
	/Mimatrix
	 matrix currentmatrix
	def
	gsave
	newpath
	Mleft
	Mbottom
	translate
	1 -1 scale
	/Mtmatrix
	matrix currentmatrix
	def
	Plain
	Mfontsize scalefont
	setfont
	0 setgray
	0 setlinewidth
} bind def
/MathPictureEnd {
	grestore
} bind def
/MathSubStart {
        Mgmatrix Mtmatrix
        Mleft Mbottom
        Mwidth Mheight
        8 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        Mgmatrix setmatrix
        10 -2 roll
        moveto
        Mtmatrix setmatrix
        currentpoint
        2 copy translate
        /Mtmatrix matrix currentmatrix def
        /Mleft 0 def
        /Mbottom 0 def
        3 -1 roll
        exch sub
        /Mheight exch def
        sub
        /Mwidth exch def
} bind def
/MathSubEnd {
        /Mheight exch def
        /Mwidth exch def
        /Mbottom exch def
        /Mleft exch def
        /Mtmatrix exch def
        dup setmatrix
        /Mgmatrix exch def
} bind def
/Mdot {
	moveto
	0 0 rlineto
	stroke
} bind def
/Mtetra {
	moveto
	lineto
	lineto
	lineto
	fill
} bind def
/Metetra {
	moveto
	lineto
	lineto
	lineto
	closepath
	gsave
	fill
	grestore
	0 setgray
	stroke
} bind def
/Mistroke {
	flattenpath
	0 0 0
	{
	4 2 roll
	pop pop
	}
	{
	4 -1 roll
	2 index
	sub dup mul
	4 -1 roll
	2 index
	sub dup mul
	add sqrt
	4 -1 roll
	add
	3 1 roll
	}
	{
	stop
	}
	{
	stop
	}
	pathforall
	pop pop
	currentpoint
	stroke
	moveto
	currentdash
	3 -1 roll
	add
	setdash
} bind def
/Mfstroke {
	stroke
	currentdash
	pop 0
	setdash
} bind def
/Mrotsboxa {
	gsave
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	grestore
	Msboxa
	3  -1 roll
	/Mtmatrix
	exch def
	/Mrot
	0 def
} bind def
/Msboxa {
	newpath
	5 -1 roll
	Mvboxa
	pop
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Msboxa1
	5 -3 roll
	Msboxa1
	Mboxrot
	[
	7 -2 roll
	2 copy
	[
	3 1 roll
	10 -1 roll
	9 -1 roll
	]
	6 1 roll
	5 -2 roll
	]
} bind def
/Msboxa1 {
	sub
	2 div
	dup
	2 index
	1 add
	mul
	3 -1 roll
	-1 add
	3 -1 roll
	mul
} bind def
/Mvboxa	{
	Mfixwid
	{
	Mvboxa1
	}
	{
	dup
	Mwidthcal
	0 exch
	{
	add
	}
	forall
	exch
	Mvboxa1
	4 index
	7 -1 roll
	add
	4 -1 roll
	pop
	3 1 roll
	}
	ifelse
} bind def
/Mvboxa1 {
	gsave
	newpath
	[ true
	3 -1 roll
	{
	Mbbox
	5 -1 roll
	{
	0
	5 1 roll
	}
	{
	7 -1 roll
	exch sub
	(m) stringwidth pop
	.3 mul
	sub
	7 1 roll
	6 -1 roll
	4 -1 roll
	Mmin
	3 -1 roll
	5 index
	add
	5 -1 roll
	4 -1 roll
	Mmax
	4 -1 roll
	}
	ifelse
	false
	}
	forall
	{ stop } if
	counttomark
	1 add
	4 roll
	]
	grestore
} bind def
/Mbbox {
	0 0 moveto
	false charpath
	flattenpath
	pathbbox
	newpath
} bind def
/Mmin {
	2 copy
	gt
	{ exch } if
	pop
} bind def
/Mmax {
	2 copy
	lt
	{ exch } if
	pop
} bind def
/Mrotshowa {
	dup
	/Mrot
	exch def
	Mrotcheck
	Mtmatrix
	dup
	setmatrix
	7 1 roll
	4 index
	4 index
	translate
	rotate
	3 index
	-1 mul
	3 index
	-1 mul
	translate
	/Mtmatrix
	matrix
	currentmatrix
	def
	Mgmatrix setmatrix
	Mshowa
	/Mtmatrix
	exch def
	/Mrot 0 def
} bind def
/Mshowa {
	4 -2 roll
	moveto
	2 index
	Mtmatrix setmatrix
	Mvboxa
	7 1 roll
	Mboxout
	6 -1 roll
	5 -1 roll
	4 -1 roll
	Mshowa1
	4 1 roll
	Mshowa1
	rmoveto
	currentpoint
	Mfixwid
	{
	Mshowax
	}
	{
	Mshoway
	}
	ifelse
	pop pop pop pop
	Mgmatrix setmatrix
} bind def
/Mshowax {
	0 1
        4 index length
        -1 add
        {
        2 index
        4 index
        2 index
        get
        3 index
        add
        moveto
        4 index
        exch get
        show
        } for
} bind def
/Mshoway {
        3 index
        Mwidthcal
        5 1 roll
	0 1
	4 index length
	-1 add
	{
	2 index
	4 index
	2 index
	get
	3 index
	add
	moveto
	4 index
	exch get
	[
	6 index
	aload
	length
	2 add
	-1 roll
	{
	pop
	Strform
	stringwidth
	pop
	neg
	exch
	add
	0 rmoveto
	}
	exch
	kshow
	cleartomark
	} for
	pop
} bind def
/Mwidthcal {
	[
	exch
	{
	Mwidthcal1
	}
	forall
	]
	[
	exch
	dup
	Maxlen
	-1 add
	0 1
	3 -1 roll
	{
	[
	exch
	2 index
	{
	1 index
	Mget
	exch
	}
	forall
	pop
	Maxget
	exch
	}
	for
	pop
	]
	Mreva
} bind def
/Mreva	{
	[
	exch
	aload
	length
	-1 1
	{1 roll}
	for
	]
} bind def
/Mget	{
	1 index
	length
	-1 add
	1 index
	ge
	{
	get
	}
	{
	pop pop
	0
	}
	ifelse
} bind def
/Maxlen	{
	[
	exch
	{
	length
	}
	forall
	Maxget
} bind def
/Maxget	{
	counttomark
	-1 add
	1 1
	3 -1 roll
	{
	pop
	Mmax
	}
	for
	exch
	pop
} bind def
/Mwidthcal1 {
	[
	exch
	{
	Strform
	stringwidth
	pop
	}
	forall
	]
} bind def
/Strform {
	/tem (x) def
	tem 0
	3 -1 roll
	put
	tem
} bind def
/Mshowa1 {
	2 copy
	add
	4 1 roll
	sub
	mul
	sub
	-2 div
} bind def
/MathScale {
	Mwidth
	Mheight
	Mlp
	translate
	scale
	/Msaveaa exch def
	/Msavebb exch def
	/Msavecc exch def
	/Msavedd exch def
	/Mgmatrix
	matrix currentmatrix
	def
} bind def
/Mlp {
	3 copy
	Mlpfirst
	{
	Mnodistort
	{
	Mmin
	dup
	} if
	4 index
	2 index
	2 index
	Mlprun
	11 index
	11 -1 roll
	10 -4 roll
	Mlp1
	8 index
	9 -5 roll
	Mlp1
	4 -1 roll
	and
	{ exit } if
	3 -1 roll
	pop pop
	} loop
	exch
	3 1 roll
	7 -3 roll
	pop pop pop
} bind def
/Mlpfirst {
	3 -1 roll
	dup length
	2 copy
	-2 add
	get
	aload
	pop pop pop
	4 -2 roll
	-1 add
	get
	aload
	pop pop pop
	6 -1 roll
	3 -1 roll
	5 -1 roll
	sub
	dup /MsaveAx exch def
	div
	4 1 roll
	exch sub
	dup /MsaveAy exch def
	div
} bind def
/Mlprun {
	2 copy
	4 index
	0 get
	dup
	4 1 roll
	Mlprun1
	3 copy
	8 -2 roll
	9 -1 roll
	{
	3 copy
	Mlprun1
	3 copy
	11 -3 roll
	/gt Mlpminmax
	8 3 roll
	11 -3 roll
	/lt Mlpminmax
	8 3 roll
	} forall
	pop pop pop pop
	3 1 roll
	pop pop
	aload pop
	5 -1 roll
	aload pop
	exch
	6 -1 roll
	Mlprun2
	8 2 roll
	4 -1 roll
	Mlprun2
	6 2 roll
	3 -1 roll
	Mlprun2
	4 2 roll
	exch
	Mlprun2
	6 2 roll
} bind def
/Mlprun1 {
	aload pop
	exch
	6 -1 roll
	5 -1 roll
	mul add
	4 -2 roll
	mul
	3 -1 roll
	add
} bind def
/Mlprun2 {
	2 copy
	add 2 div
	3 1 roll
	exch sub
} bind def
/Mlpminmax {
	cvx
	2 index
	6 index
	2 index
	exec
	{
	7 -3 roll
	4 -1 roll
	} if
	1 index
	5 index
	3 -1 roll
	exec
	{
	4 1 roll
	pop
	5 -1 roll
	aload
	pop pop
	4 -1 roll
	aload pop
	[
	8 -2 roll
	pop
	5 -2 roll
	pop
	6 -2 roll
	pop
	5 -1 roll
	]
	4 1 roll
	pop
	}
	{
	pop pop pop
	} ifelse
} bind def
/Mlp1 {
	5 index
	3 index	sub
	5 index
	2 index mul
	1 index
	le
	1 index
	0 le
	or
	dup
	not
	{
	1 index
	3 index	div
	.99999 mul
	8 -1 roll
	pop
	7 1 roll
	}
	if
	8 -1 roll
	2 div
	7 -2 roll
	pop sub
	5 index
	6 -3 roll
	pop pop
	mul sub
	exch
} bind def
/intop 0 def
/inrht 0 def
/inflag 0 def
/outflag 0 def
/xadrht 0 def
/xadlft 0 def
/yadtop 0 def
/yadbot 0 def
/Minner {
	outflag
	1
	eq
	{
	/outflag 0 def
	/intop 0 def
	/inrht 0 def
	} if
	5 index
	gsave
	Mtmatrix setmatrix
	Mvboxa pop
	grestore
	3 -1 roll
	pop
	dup
	intop
	gt
	{
	/intop
	exch def
	}
	{ pop }
	ifelse
	dup
	inrht
	gt
	{
	/inrht
	exch def
	}
	{ pop }
	ifelse
	pop
	/inflag
	1 def
} bind def
/Mouter {
	/xadrht 0 def
	/xadlft 0 def
	/yadtop 0 def
	/yadbot 0 def
	inflag
	1 eq
	{
	dup
	0 lt
	{
	dup
	intop
	mul
	neg
	/yadtop
	exch def
	} if
	dup
	0 gt
	{
	dup
	intop
	mul
	/yadbot
	exch def
	}
	if
	pop
	dup
	0 lt
	{
	dup
	inrht
	mul
	neg
	/xadrht
	exch def
	} if
	dup
	0 gt
	{
	dup
	inrht
	mul
	/xadlft
	exch def
	} if
	pop
	/outflag 1 def
	}
	{ pop pop}
	ifelse
	/inflag 0 def
	/inrht 0 def
	/intop 0 def
} bind def
/Mboxout {
	outflag
	1
	eq
	{
	4 -1
	roll
	xadlft
	leadjust
	add
	sub
	4 1 roll
	3 -1
	roll
	yadbot
	leadjust
	add
	sub
	3 1
	roll
	exch
	xadrht
	leadjust
	add
	add
	exch
	yadtop
	leadjust
	add
	add
	/outflag 0 def
	/xadlft 0 def
	/yadbot 0 def
	/xadrht 0 def
	/yadtop 0 def
	} if
} bind def
/leadjust {
	(m) stringwidth pop
	.5 mul
} bind def
/Mrotcheck {
	dup
	90
	eq
	{
	yadbot
	/yadbot
	xadrht
	def
	/xadrht
	yadtop
	def
	/yadtop
	xadlft
	def
	/xadlft
	exch
	def
	}
	if
	dup
	cos
	1 index
	sin
	Checkaux
	dup
	cos
	1 index
	sin neg
	exch
	Checkaux
	3 1 roll
	pop pop
} bind def
/Checkaux {
	4 index
	exch
	4 index
	mul
	3 1 roll
	mul add
	4 1 roll
} bind def
/Mboxrot {
	Mrot
	90 eq
	{
	brotaux
	4 2
	roll
	}
	if
	Mrot
	180 eq
	{
	4 2
        roll
	brotaux
	4 2
	roll
	brotaux
	}
	if
	Mrot
	270 eq
	{
	4 2
	roll
	brotaux
	}
	if
} bind def
/brotaux {
	neg
	exch
	neg
} bind def
/Mabswid {
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	mul
	setlinewidth
} bind def
/Mabsdash {
	exch
	Mimatrix
	0 get
	Mgmatrix
	0 get
	div
	[
	3 1 roll
	exch
	{
	exch
	dup
	3 -1 roll
	mul
	exch
	}
	forall
	pop ]
	exch
	setdash
} bind def
/colorimage where
{ pop }
{
/colorimage {
3 1 roll
 pop pop
 5 -1 roll
 mul
 4 1 roll
{
currentfile
1 index
readhexstring
pop }
image
} bind def
} ifelse
/sampledsound where
{ pop}
{ /sampledsound {
exch
pop
exch
5 1 roll
mul
4 idiv
mul
2 idiv
exch pop
exch
/Mtempproc exch def
{ Mtempproc pop }
repeat
} bind def
} ifelse

/Mleft		113.000000 def
/Mbottom	650.000000 def
/Mwidth		282.000000 def
/Mheight	176.000000 def
/Mfontsize 12 def
/Plain /Courier findfont def
%!
%%Creator: Mathematica
%%AspectRatio: 0.61803 
MathPictureStart
% Scaling calculations
0.02381 0.04762 0 0.61803 [
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Msboxa
[(5)] 0.2619 -0.0125 0 1 Msboxa
[(10)] 0.5 -0.0125 0 1 Msboxa
[(15)] 0.7381 -0.0125 0 1 Msboxa
[(20)] 0.97619 -0.0125 0 1 Msboxa
[(time\(samples\))] 1.00625 0 -1 0 Msboxa
[(0.2)] 0.01131 0.12361 1 0 Msboxa
[(0.4)] 0.01131 0.24721 1 0 Msboxa
[(0.6)] 0.01131 0.37082 1 0 Msboxa
[(0.8)] 0.01131 0.49443 1 0 Msboxa
[(1)] 0.01131 0.61803 1 0 Msboxa
[()] 0.02381 0.62428 0 -1 Msboxa
[ -0.001 -0.00725 0 0 ]
[ 1.001 0.61903 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
%%Object: Graphics
[ ] 0 setdash
0 setgray
0 setgray
[(Sampled exponential decay)] 0.5 0.62428 0 -1 Mshowa
gsave
gsave
0.002 setlinewidth
0 0 moveto
1 0 lineto
stroke
0.2619 -0.00625 moveto
0.2619 0.00625 lineto
stroke
0 setgray
[(5)] 0.2619 -0.0125 0 1 Mshowa
0.5 -0.00625 moveto
0.5 0.00625 lineto
stroke
0 setgray
[(10)] 0.5 -0.0125 0 1 Mshowa
0.7381 -0.00625 moveto
0.7381 0.00625 lineto
stroke
0 setgray
[(15)] 0.7381 -0.0125 0 1 Mshowa
0.97619 -0.00625 moveto
0.97619 0.00625 lineto
stroke
0 setgray
[(20)] 0.97619 -0.0125 0 1 Mshowa
0 setgray
[(time\(samples\))] 1.00625 0 -1 0 Mshowa
0.02381 0 moveto
0.02381 0.61803 lineto
stroke
0.01756 0.12361 moveto
0.03006 0.12361 lineto
stroke
0 setgray
[(0.2)] 0.01131 0.12361 1 0 Mshowa
0.01756 0.24721 moveto
0.03006 0.24721 lineto
stroke
0 setgray
[(0.4)] 0.01131 0.24721 1 0 Mshowa
0.01756 0.37082 moveto
0.03006 0.37082 lineto
stroke
0 setgray
[(0.6)] 0.01131 0.37082 1 0 Mshowa
0.01756 0.49443 moveto
0.03006 0.49443 lineto
stroke
0 setgray
[(0.8)] 0.01131 0.49443 1 0 Mshowa
0.01756 0.61803 moveto
0.03006 0.61803 lineto
stroke
0 setgray
[(1)] 0.01131 0.61803 1 0 Mshowa
0 setgray
[()] 0.02381 0.62428 0 -1 Mshowa
grestore
grestore
0 0 moveto
1 0 lineto
1 0.618034 lineto
0 0.618034 lineto
closepath
clip
newpath
0 setgray
gsave
0.008 setlinewidth
0.07143 0.61803 Mdot
0.11905 0.44284 Mdot
0.16667 0.31731 Mdot
0.21429 0.22736 Mdot
0.2619 0.16291 Mdot
0.30952 0.11673 Mdot
0.35714 0.08364 Mdot
0.40476 0.05993 Mdot
0.45238 0.04294 Mdot
0.5 0.03077 Mdot
0.54762 0.02205 Mdot
0.59524 0.0158 Mdot
0.64286 0.01132 Mdot
0.69048 0.00811 Mdot
0.7381 0.00581 Mdot
0.78571 0.00416 Mdot
0.83333 0.00298 Mdot
0.88095 0.00214 Mdot
0.92857 0.00153 Mdot
0.97619 0.0011 Mdot
grestore
% End of Graphics
MathPictureEnd%%PSTrailer
end

%%EPS Trailer
grestore
grestore
gsave
54 30 467 12 rectclip
gsave
/Times-Roman findfont 10 scalefont [1 0 0 -1 0 0] makefont
52
exch
defineuserobject
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
2 9 moveto (MusicEnvelopes.ma) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
gsave
54 30 467 12 rectclip
gsave
52 execuserobject setfont
0 nxsetgray
54 30 467 12 rectclip
54 30 translate
52 execuserobject setfont
0 nxsetgray
455 9 moveto (10) show
grestore
grestore
0.5 setlinewidth
521 42 moveto
54 42 lineto
stroke
1 setlinewidth
1 setlinewidth 0 setgray
grestore
grestore
showpage
__NXsheetsavetoken restore
%%PageTrailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Roman
%%Trailer
%%DocumentFonts: Courier-Bold
%%+ Courier
%%+ Times-Bold
%%+ Times-Roman
%%Pages: 10 1
%%BoundingBox:0 0 612 792

