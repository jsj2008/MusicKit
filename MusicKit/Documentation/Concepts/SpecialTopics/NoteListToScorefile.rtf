{\rtf0\ansi{\fonttbl\f0\fnil Times-Roman;\f3\ftech Symbol;\f1\fmodern Courier;}
\paperw12240
\paperh13540
\margl1800
\margr1800
\pard\tx1140\tx2280\tx3420\tx4560\tx5700\tx6840\tx7980\f0\b\i0\ulnone\qc\fs28\fc0\cf0 From The Classical Software Synthesis Note-List to the NeXT Scorefile 	
\b0 		\

\ql \

\qc 	by David A. Jaffe 		\
		1989	
\f3 ã
\f0  NeXT Inc. \

\ql \
This introduction to the NeXT Scorefile is aimed at people who are familiar with the note-list used in "classical" software synthesis languages such as Music5.  However, it should be useful to others as well.  For brevity, we refer to the classical note-list as, simply
\i  note-list
\i0 , and the NeXT Scorefile as 
\i scorefile
\i0 .   \
\
The 
\b scorefile
\b0  is part of the NeXT Music Kit. The Music Kit supports both real-time synthesis and accelerated non-real-time synthesis using the built-in DSP and sound hardware. (It also supports MIDI processing, interactive applications, etc., but these do not concern us here.) The 
\b scorefile
\b0 , therefore, must be capable of representing both event-based data, such as MIDI, and compositional data, such as the classical note-list. Many of its characteristics stem from this aim.\
\

\b\qc 	Classical Parameter Lists Can Be Hard To Read\

\b0 \

\ql Most note-lists represent notes in the form of pseudo-function calls, where the function is a software instrument name and the arguments are the note parameters.  For example:\
\
	guitar 0 2 440 3 F1; \
\
Here 
\i guitar
\i0  is the name of the software instrument, 0 is the begin time, 2 is the duration, 440 is the frequency, 3 is perhaps the FM index and 
\i F1
\i0  is the name of an envelope. The effect of this line in the note-list is to create a note with the parameters given. \
\
This is fine for very simple instruments with few parameters, but it becomes terribly unwieldy for complex instruments with many parameters. Notes like this are not uncommon:\
\
	guitar 0 2 440 3 F1 4 .1 432 0 0 0 .5423 1 55 F2 .11\
		 0 0 0 0 0 .44 0 0 0 880 F2 0 0 0;  \
\
Several notes in a row may have only a few small parameter changes. But every parameter must be repeated:\
\
	guitar 0 2 440 3 F1 4 .1 332 0 0 0 .5423 1 55 F2 .11\
		 0 0 0 0 0 .44 0 0 0 880 F2 0 0 0;  	\
	guitar 3 2 880 3 F1 4 .1 432 0 0 0 .6423 1 55 F2 .11 \
		0 0 0 0 0 .44 0 0 0 880 F2 0 0 0;  	\
	guitar 7 2 880 3 F1 4 .1 432 0 0 0 .5423 1 55 F2 .11\
 		0 0 0 0 0 .44 0 0 0 440 F2 0 0 0;  \
\
Since the position of each number in the list determines the parameter to which the number applies, all parameters must be supplied on every note (clever ordering and defaulting of trailing parameters makes this not strictly true, but does not solve the basic problem.)\
\

\b\qc Scorefiles Use Keywords To Make Order-Indpendent Parameter Lists\

\b0\ql \
Instead of ordered parameters, the 
\b scorefile
\b0  uses keywords to identify parameters. Only the parameters that differ from the defaults need be specified for a given note. Here's a parameter list for a 
\b scorefile
\b0  note:\
\
	freq:440 amp:.1 bearing:-45\
\
The frequency parameter is set to 440, the amplitude parameter is set to .1 and the bearing parameter (left/right panning) is set to -45 (the left speaker).\
\

\b\qc Keywords Make Reorchestration Easier\

\b0\ql \
The note-list is difficult to reorchestrate, since different synthesis instruments have different parameters, possibly in different orders. With the 
\b scorefile
\b0  approach, this is not a problem. Parameters unrecognized by one instrument are simply ignored. A new parameter keyword may be added to a 
\b scorefile
\b0  at will. Of course, it will have no effect unless the program that reads the 
\b scorefile
\b0  is sensitive to that parameter. \
\

\b Scorefile
\b0  parameters can be thought of as messages whose precise meaning depends on what application or instrument responds to the message. Different instruments can implement the same parameter in different ways.  For example, a pseudo-wind instrument can interpret a crescendo to mean "blow harder" while a pseudo-string instrument can interpret it to mean "move the bow faster and press harder".\
\

\b\qc Parts Make Resorchestration Easier\

\b0\ql \
In a classical note-list the first element in a note is a "hard-wired" instrument name. To change which instrument realizes a musical passage, every note in that passage must be changed. In contrast, a 
\b scorefile
\b0  note begins with a 
\b part
\b0  specification.  A part is an abstract grouping of notes that are realized in a similar manner, e.g. with the same software instrument.  Parts may contain chords and multiple polyphonic lines.\
\
The mapping from part to software instrument is "soft-wired". The instrument may be specified in the header of the 
\b scorefile
\b0  as a parameter of a special note called the 
\i part info
\i0 . Applications use the part info as a hint as to how to orchestrate the music. Different applications may behave differently. One application might ignore the software instrument specification and play the score via MIDI on an external synthesizer. \
\

\i [The Common Music System by Heinrich Taube has an analagous but subtly different notion of "part".  A Music Kit part is an ordered set of notes.  A Common Music part is a part of a Lisp program that creates that set of notes. See the 
\b Common Music Manual 
\b0 [Taube], 
\b Introduction to Common Music 
\b0 [Jaffe, Taube] and the document 
\b Creating Music with Common Music and the NeXT Music Kit
\b0   [Jaffe,Taube]].\

\i0 \
Here's a sample 
\b scorefile
\b0  header. First we declare a part, then we give it a part info:\
\
	/* This is a comment. */ 	\
	part soprano; /* Part declaration.  */ \
	soprano synthPatch:"Fm1vi" synthPatchCount:4 midiChan:3;\
\
This specifies that the soprano part use a 
\b synthPatch
\b0  called "Fm1vi". A synthPatch is a NeXT software instrument that runs on the built-in DSP. In this case, the synthPatch is Fm1vi. This string stands for "frequency modulation with one modulator, vibrato, and using an interpolating oscillator".\
\
The parameter 
\b synthPatchCount
\b0  may optionally be supplied to provide allocation information. In this case, we would like 4 synthpatches allocated to this part. If no such parameter is included, allocation is handled dynamically and automatically. \
\
An application that plays the 
\b scorefile
\b0  on MIDI uses the 
\b midiChan
\b0  parameter to determine on which MIDI channel to send the notes in the part. \
\
\

\b\qc 	A Complete Scorefile\

\b0\ql \
At this point, let's take a look at a complete simple 
\b scorefile
\b0 :\
\
	part soprano; 	\
	soprano synthPatch:"Fm1vi" synthPatchCount:4;\
\
	/* BEGIN Specifies the end of the header and\
		 beginning of the body. */ 	\
	BEGIN;       	\
	t 0; 	\
	soprano (2) freq:c4; 	\
	t 1; 	\
	soprano (2) freq:d4; 	\
	t +1; 	\
	soprano (2) freq:e4;\
\
This plays three overlapping notes, each with a duration of 2.  The 2 is not given a parameter keyword. Instead it appears in a special place surrounded by parentheses. The reason for this will be explained later. Notice that unlike in the classical note-list, the onset time appears outside of the note in a separate "time statement".  This allows chords to be more easily recognized visually. \
\
Time may be specified relatively or absolutely. In the example above, the first two time statements specify absolute time, while the third specifies relative time. A relative time statement advances time from its previous value by the amount specified. Use of relative time makes it easy to "cut and paste" sections from one 
\b scorefile
\b0  to another.  On the other hand, use of absolute time makes it easy to know where you are in a 
\b scorefile
\b0 . Since both are handy, we provide both.\
\
Durations and times are in beats, interpreted relative to a tempo. The tempo is specified in a special header note that contains parameters that affect the whole score. This note is called a "score info" or simply 
\b info
\b0 :\
\
	info samplingRate:44100 tempo:84;\
\
\

\b\qc 	Scorefiles Have Notes of Various Types\

\b0\ql \
Notes in most software synthesis languages always have a duration.  However, when responding to real-time events, the duration is not necessarily known. When a performer presses his finger on a klavier-style keyboard, the computer must begin a note now but has no idea when the performer will lift his finger from the keyboard. MIDI breaks notes into on/off pairs. 
\b Scorefiles
\b0  represent both the MIDI-style and the note-list-style of note by including a note type in the note specification. The note types are 
\b noteOn
\b0 , 
\b noteOff
\b0 , 
\b noteDur
\b0 , 
\b noteUpdate
\b0  and 
\b mute
\b0 . NoteOn is the start of a musical note, similar to the MIDI noteOn.  NoteOff is the end of a musical note or, more precisely, the point when the performer lifts his finger from the key, triggering the beginning of the final portion of the envelopes. NoteDur is a note with a duration. NoteUpdates are explained later. Mutes are notes that make no sound, used for a variety of purposes such as MIDI system exclusive messages.\
\
The following example shows three notes, a noteOn, a noteOff and a noteDur:\
\
	guitar (noteOn, 4) freq:c4; 	\
	t +2; 	\
	guitar (noteOff, 4); 	\
	t +2; 	\
	guitar (2) freq:c5;\
\
We now see why the duration parameter does not have a label. Supplying a duration in place of the note type identifies the note as a noteDur. \
\
The number 4 following the note type in the first two notes is a 
\b noteTag
\b0 . Since noteOns and noteOffs are only "half a note" as it were, there needs to be some way to match them up. We could simply say that a noteOff matches the most recent noteOn played by the same part. But then it would not be possible to do chords or polyphony in a single part. MIDI handles the situation by using the MIDI channel (in mono mode) or a combination of the key number and channel (in poly mode). However, MIDI's approach is problematic in many cases. For example, in a general computer music system, we do not want to be limited to 88 discrete pitches. We would like to be able to specify slight retuning without disturbing the matching of a noteOn and a noteOff. Therefore, we prefer to avoid use of key number or frequency to identify notes.\
\
As mentioned above, 
\b scorefile
\b0 s use noteTags to match noteOns and noteOffs. NoteTag matching does not depened on frequency at all. Therefore, there's no need to repeat the freq: parameter in the noteOff. \
\
NoteTags also serve another significant purpose. They make phrase-level structure possible.\
\

\b\qc Phrase Structure\

\b0\ql \
In the classical note-list, each note is a separate entity, unrelated to any other notes. Legato effects must be achieved using overlapping notes or by embedding information in the parameters. \
\

\b Scorefile
\b0  noteTags can represent phrase structure. In addition to their function of matching noteOns and noteOffs, noteTags associate notes of a given phrase within a single part.  Several noteOns (or noteDurs) with the same noteTag are interpreted as rearticulations within a single melody. No overlap results.  Unlike in MIDI, 
\b scorefile
\b0  noteOns do not have to be each matched with a noteOff.  Any number of noteOns on the same noteTag are matched by a single noteOff.  (The Music Kit does automatic conversion between 
\b scorefile
\b0  and MIDI semantics when it reads or writes MIDI bytes or a MIDI file.) To solve the mixing problem, the Music Kit automatically remaps NoteTags when it reads a 
\b scorefile
\b0 .  This assures that note tags in several files will not collide, even if the files share noteTags.\
\
Here is a 
\b scorefile
\b0  fragment that produces a single line of 3 notes.\
\
	/* Example 1 */ 	\
	guitar (noteOn,1) freq:c4; 	\
	t +.1; 	\
	guitar (noteOn,1) freq:d4; 	\
	t +.2; 	\
	guitar (noteOn,1) freq:e4; 	\
	t +.2; 	\
	guitar (noteOff,1);\
\
In contrast, the next example produces 3 overlapping notes:\
\
	/* Example 2 */\
	guitar (2) freq:c4; 	\
	t +.1; 	\
	guitar (2) freq:d4; 	\
	t +.2; 	\
	guitar (.2) freq:e4;\
\
If noteTags are added to example 2, it behaves like example 1, again producing a single line of 3 notes. The durations, if they are longer than the time between notes with the same tag, are ignored. \
	\
	/* Example 3 */\
	guitar (2,1) freq:c4; 	\
	t +.1; 	\
	guitar (2,1) freq:d4; 	\
	t +.2; 	\
	guitar (.2,1) freq:e4;\
\
Of course, you can combine the two approaches. Example 4 produces a line of 3 notes and 3 overlapping notes.\
\
	/* Example 4 */\
	guitar (noteOn,1) freq:c4; 	\
	guitar (2) freq:c5; 	\
	t +.1; 	\
	guitar (2) freq:d4; 	\
	guitar (noteOn,1) freq:d5; 	\
	t +.2; 	\
	guitar (.2) freq:e4; 	\
	guitar (noteOn,1) freq:e5; 	\
	t +.2; 	\
	guitar (noteOff,1);\
\
As a final example, we add a second 2-note melody by using a different noteTag:\
\
	/* Examle 5 */\
	guitar (noteOn,1) freq:c4; 	\
	guitar (2) freq:c5; 	\
	guitar (noteOn,2) freq:g5; 	\
	t +.1; 	\
	guitar (2) freq:d4; 	\
	guitar (noteOn,1) freq:d5; 	\
	t +.2; 	\
	guitar (.2) freq:e4; 	\
	guitar (noteOn,1) freq:e5; 	\
	guitar (noteOn,2) freq:g5; 	\
	t +.2; 	\
	guitar (noteOff,1); 	\
	guitar (noteOff,2);\

\b\qc \
\
Scorefiles Support Both Event-Based and Envelope-Based Continuous Control\
\

\b0\ql A note cannot be addressed from the classical note-list once the note has begun. It is not possible, for example, to alter the parameter of a note once it has started playing. This means all continuous change must be built into the instrument and specified in advance via envelopes.  But in a real-time situation, such as MIDI or any interactive application, the future is not known and cannot be predicted. \
\
MIDI solves the problem with its special "continous controllers" that must be interpreted by the synthesizer. The 
\b scorefile
\b0  is even more flexible. It allows any parameter of a note that's already playing to be changed at any time, simply by specifying the noteType as 
\b noteUpdate
\b0  and giving the appropriate noteTag.  In this example the note goes sharp and its amplitude is increased:\
\
	/* Example 6 */\
	guitar (noteOn,1) freq:c4 amp:.1 	\
	t +2; 	\
	guitar (noteUpdate,1) amp:.3 freq:cs4; 	\
	t +2; 	\
	guitar (noteOff,1); 	\
\

\b Scorefiles
\b0  can also represent envelopes. Envelopes are defined as (X,Y) pairs (with an optional Z parameter that represents "smoothing"). \
\
For example here's an envelope definition:\
\
	envelope martele = [(0,0)(.1,1)(.6,.2)|(1.0,0)];\
\
The X values are in seconds, independent of the tempo. The portion up to the stick point (represented as a vertical bar "|") is called the "attack portion". Tempo variations do not cause attack times to be distorted. The reasoning here is that the attack of an acoustic instrument, such as a xylophone, is invariant with respect to tempo. \
\
The portion after the vertical bar is called the "decay portion". There is no absolute limit to the number of points in an envelope. Both the attack and the decay portions may have any number of points.\
\
\
The envelope progresses as follows: It proceeds until the stick point (at .6 seconds after the onset, with a Y value of .2) and then waits until the noteOff (or, for a noteDur, the end of the duration). Then it proceeds with the final segment(s). For example, if the note has a duration of 4, the final segment begins after 4 beats and the decay takes .4 seconds.  Alternatively, an optional attack time and decay parameter may be supplied for each envelope in a note. These scale the X values in the envelope definition. For example, if 
\i martele
\i0  is used as an amplitude envelope and 
\b ampAtt
\b0 , the amplitude attack parameter, is equal to .1, the resulting envelope X values will be 0, .01, .06. The release portion may similarly be scaled. Here is an example of a note that uses the 
\b ampAtt
\b0  and 
\b ampRel
\b0  parameters.\
\
	weaslePhone (4) amp:.3 ampEnv:martele ampAtt:.1 ampRel:6.0;\
\
The 
\b amp 
\b0 parameter does scaling on the envelope values. Actually, 
\b amp 
\b0 is really a synonym for 
\b amp1
\b0 , the value of the amplitude when the envelope is at 1.0. There is also an optional parameter 
\b amp0
\b0 , that signifies the value of the amplitude when the envelope is at 0. This convention is followed uniformly for all parameters that take envelopes. For example, a frequency envelopes parameters are 
\b freq0
\b0 ,
\b  freq1
\b0 ,
\b  freqAtt
\b0 ,
\b  freqRel
\b0 ,
\b  
\b0 and 
\b freqEnv
\b0 .
\b \

\b0 \

\b\qc NoteUpdates Without Tags Set Defaults\

\b0\ql \
If a noteUpdate has no tag, it applies to all currently playing notes of the part in which it appears. It also becomes the default for future notes. This mechanism can be used to provide "voicings" that periodically change. \
\
	/* Example 7 */\
	singer  (noteUpdate) waveLen:128.000 svibAmp0:.003 \
		svibAmp1:.011 rvibAmp:.006 bearing:.000;	 	\
	t 0.800; 	\
	singer (2) freq0:466.164 freq1:466.164 freqEnv:frqFn0 amp:-12dB\
 	   	ampEnv:ampFn1 waveform0:"0SU" waveform1:"SU"\
	        	waveformEnv:intFn0 freqAtt:.200 waveformAtt:.200 svibFreq0:3.125 \
		svibFreq1:4.630;\
\

\b\qc 	Scorefiles Support Various Parameter Types\

\b0\ql \
Example 7 also illustrates that a parameter may be a number of types: a string, a floating point number, an integer, an envelope, a wavetable (see below), or a type defined by the application that reads the 
\b scorefile
\b0 .\
\
WaveTables may be represented in either the frequency or the time domain. In the frequency domain, they are represented as pairs of the form \{harmonic number,relative amplitude\}.  An optional third element gives the phase of the component. For example, here is a clarinet-like waveTable, containing only odd harmonics:\
\
	waveTable clarinet = [\{1,1\}\{3,.5\}\{7,.2\},\{9,.05\}];\
\
In the time domain, waveTables are represented by specifying the NeXT soundfile that holds the samples:\
\
	waveTable sampledClarinet = \
		[\{"onePeriodOfAClarinet.snd"\}];\
\
It is usually preferable to specify a waveTable in the frequency domain, since it is more easily transposable.\
\
Note that waveTables use curly braces rather than parentheses. (This is needed because envelopes and waveTables may appear as unnamed data. The use of a different syntax allows the parser to differentiate unnamed waveTables from unnamed envelopes.)\
\

\b\qc 	The Music Kit Allows Simple Language Constructs to Appear in a Scorefile\

\b0 \

\ql The Music Kit can read an extended 
\b scorefile
\b0  format called 
\b\i ScoreFile
\b0\i0  that is actually a simple language supporting variables, expressions and operators. While 
\b\i ScoreFile
\b0\i0  is not intended as a means of entering musical data, it is useful for fine-tuning or making other minor modifications to a piece.  For a complete description of 
\b\i ScoreFile
\b0 ,
\i0  see the NeXT Technical Documentation (appendix E, available on line as 
\b /NextLibrary/Documentation/NeXT/SysRefMan/ApE_SFileSummary.wn
\b0 ). \
\
As a final example, here is a NeXT 
\b scorefile
\b0  with some 
\b\i ScoreFile
\b0\i0  constructs included:\
\
info tempo:72;\
part bell; \
bell synthPatch:"Fm1i" synthPatchCount:9; \
\
envelope ampFun =  [(0,0)(.005,0dB)(10,-40dB)|(14,0.0)(15,0)];\
envelope freqFun =  [(0,1)(.005,bf4/a4)(.01,1)(10,1)|(14,.9,2)];\
envelope indxFun =  [(0,2)(.005,1)(10,0,.3)|(14,0.0)];\
\
waveTable wave1  = [\{1,1\}\{3,.1\}]; \
\
\
BEGIN;\
bell (noteUpdate) waveform:wave1 m1Ratio:3.4\
	m1Ind1:.4 amp:0.2 ampEnv:ampFun freqEnv:freqFun \
	m1IndEnv:indxFun;\
t .001;\
bell (4.5) freq:c7 bearing:-45 + ran; /* ran returns a random number */\
bell (4.5) freq:c7+4.5 bearing:0;\
t +.1;\
bell (4.4) freq:b6 bearing:-35 + ran;\
bell (4.4) freq:b6+4.1 bearing:10;\
t .2;\
bell (4.3) freq:g6 bearing:-25;\
bell (4.3) freq:g6+4.8 bearing:20;\
t .3;\
bell (4.2) freq:f6 bearing:-15;\
bell (4.2) freq:f6+5.5 bearing:30;\
t .4;\
print "Last note coming up. Time is ",t,"\\n"; \
bell (4.1) freq:d6 bearing:45;\
END;
\b \

\qc \

\b0\ql 	
\b 	Summary\
\

\b0 The NeXT 
\b scorefile
\b0  has its roots in both the classical note-list and MIDI.  The scorefile makes it possible to express the generality of software synthesis note-lists as well as the performance nuance and control characteristics of MIDI.\
\

\b 		Acknowledgements\
\

\b0 Julius Smith, Bill Schottstaedt, and Doug Fulton made substantial contributions to the 
\b scorefile 
\b0 and 
\b\i ScoreFile
\b0  
\i0 designs
\b\i .
\i0 \

\b0 \
\

\fs24 \

}
