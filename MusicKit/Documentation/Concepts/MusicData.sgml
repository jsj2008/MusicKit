<!-- $Id$ -->

<chapter id=MusicData>
<title>Representing Music Data</title>

<para>This chapter describes the classes, methods, and C Functions
that the MusicKit defines to represent music data.</para>

  <sect1 id=MKNoteClass>
    <title>The <classname>MKNote</classname> Class</title>

    <para>Whether you are composing music, designing a performance
scheme, or building software instruments, you need a thorough
understanding of the <classname>MKNote</classname> class.  The
<classname>MKNote</classname> class provides a means for describing
musical sounds; a <classname>MKNote</classname> object is a repository
of musical information that's passed to and acted on by other MusicKit
objects.</para>

    <para>A <classname>MKNote</classname> contains three categories of
    information:</para>

    <itemizedlist>
      <listitem><para> A collection of
<emphasis>parameters</emphasis>.  Parameters describe the attributes
of a musical sound, such as its frequency (pitch) and amplitude
(loudness).  A <classname>MKNote</classname> can contain any number of
parameters, including none.</para></listitem>

      <listitem><para> A single <emphasis>note type</emphasis> that
expresses the basic character of the <classname>MKNote</classname>
object, whether it defines an entire musical note, or just its
beginning, middle, or end.</para></listitem>

      <listitem><para> An integer identifier called a <emphasis>note
tag</emphasis>.  Note tags are used to associate a series of
<classname>MKNote</classname>s.  For example, two separate
<classname>MKNote</classname> objects that define the beginning and
the end of a musical note must have the same note tag value.</para>
      </listitem>
    </itemizedlist>
	
<para>The three categories of <classname>MKNote</classname>
information are examined in detail in the following sections.</para>

    <sect2><title>Parameters</title>

<para>Parameters are the pith of a <classname>MKNote</classname>
object.  They're used to enumerate and describe the quantifiable
aspects of a musical sound.  The most important rule of parameters is
that they don't <emphasis>do</emphasis> anything; in order for a
parameter to have an effect, another object (or your application) must
retrieve and apply it in some way.  For example, the subclasses of
<classname>MKSynthPatch</classname> provided by the MusicKit are
designed to look for particular sets of parameters when synthesizing a
<classname>MKNote</classname>.  Some common parameters, such as those
for frequency and amplitude, are looked for by all these
classes.</para>

<para>A parameter consists of a unique integer tag, a unique print
name (a string), and a value.  The tag and name are used to identify
the parameter:</para>

      <itemizedlist>
<listitem><para> The parameter's tag identifies it within an
application.</para>
	</listitem>
<listitem><para> The print name identifies the parameter in a
scorefile.</para>
	</listitem>
      </itemizedlist>
<para>Thus, the tag and the name are simply two ways of identifying
the same parameter.  To create a new parameter, you pass a print name
(that you make up yourself) to the <emphasis
role="bold">parName:</emphasis> class method.  The method returns a
unique tag for the parameter:</para>

<programlisting>
/* Create a new parameter tag (an int). */
int myPar = [MKNote parName:"myPar"];
</programlisting>

<para>The name of the variable that represents the tag needn't be the
same as the string name, although in the interest of clarity this is
regarded as good form.  The <emphasis role="bold">parName:</emphasis>
method can also be used to retrieve the tag of a parameter that's
already been created: <emphasis role="bold">parName:</emphasis>
creates a new tag for each unique argument that's passed to it;
subsequent invocations with the same argument will return the
already-created tag.</para>

<para>Since the MusicKit <classname>MKSynthPatch</classname>es look
for particular parameters during synthesis, it follows that the
MusicKit must also supply some number of parameter tags.  These are
listed and described in <xref linkend="MusicTables">.</para>

<para>MusicKit parameter tags are represented by integer constants
such as <emphasis role="bold">MK_freq</emphasis> (for frequency) and
<emphasis role="bold">MK_amp</emphasis> (for amplitude).  The print
names are formed by dropping the &ldquo;MK_&rdquo; prefix.  Thus,
<emphasis role="bold">MK_freq</emphasis> is represented in a scorefile
as &ldquo;freq&rdquo; and <emphasis role="bold">MK_amp</emphasis> is
&ldquo;amp&rdquo;.</para>

<para>By definition, the parameter tags supplied by the MusicKit are
sufficient for all uses of its <classname>MKSynthPatch</classname>es
and <classname>MKMidi</classname>.  If you create your own
<classname>MKSynthPatch</classname> subclass, you can create
additional parameter tags to fully describe its functionality, but you
should use as many of the MusicKit parameter tags as are applicable.
For example, it's assumed that all <classname>MKSynthPatch</classname>
subclasses will have a settable frequency; rather than create your own
frequency parameter tag, you should use <emphasis
role="bold">MK_freq</emphasis>.  This promotes portability between
<classname>MKSynthPatch</classname>es.</para>

<para>Lest the emphasis on synthesis be misconstrued, keep in mind
that a parameter's purpose is not restricted to that arena.
Parameters can be used in any way that your application sees fit; for
example, a graphic notation program could use parameters to describe
how a Note object is displayed on the screen.  However, you should
also keep in mind that a parameter is significant only if some other
object or your application looks for and uses it.</para>

      <sect3><title>Parameter Values</title>

<para>The method you use to set a parameter's value depends on the
data type of the value.  The <classname>MKNote</classname> class
provides six value-setting methods.  The first three of these
are:</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">setPar:toDouble:</emphasis>
sets the parameter value as a <emphasis
role="bold">double</emphasis>.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">setPar:toInt:</emphasis> sets
the value as an <emphasis role="bold">int</emphasis>.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">setPar:toString:</emphasis>
sets the value as a pointer to a string.</para>
	  </listitem>
	</itemizedlist>
<para>The other three methods will be examined later.</para>

<para>The argument to the <emphasis role="bold">setPar:</emphasis>
keyword is a parameter tag; the second argument is the value that
you're setting.  For example, to set the value of the bearing
parameter (stereophonic location of a DSP synthesized sound) to 45.0
degrees (hard right), you could send any of the following
messages:</para>

<programlisting>
/* Of course, you have to create the MKNote first. */
id aNote =[[MKNote alloc] init];

/* Set the bearing. */
[aNote setPar:MK_bearing toDouble:45.0];

/* or */
[aNote setPar:MK_bearing toInt:45];

/* or */
[aNote setPar:MK_bearing toString:"45"];
</programlisting>

<para>You generally set bearing as a <emphasis
role="bold">double</emphasis>&horbar;all the MusicKit
<classname>MKSynthPatch</classname>es apply bearing, as well as most
other number-valued parameters, as a value of that type.  However,
retrieval methods are provided that perform type conversion for you.
For example, the message</para>

<programlisting>
/* Retrieve the bearing parameter value as a double. */
double theBearing = [aNote ParAsDouble:MK_bearing];
</programlisting>

<para>returns the <emphasis role="bold">double</emphasis> 45.0
regardless of which of the three methods you used to set the value.
The retrieval methods include:</para>
	<itemizedlist>

<listitem><para> <emphasis role="bold">parAsDouble:</emphasis> returns
the value as a <emphasis role="bold">double</emphasis>.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">parAsInt:</emphasis> returns
the value as an <emphasis role="bold">int</emphasis>.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">parAsString:</emphasis> returns
a pointer (a<emphasis role="bold"> char *</emphasis>) to a copy of the
value.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">parAsStringNoCopy:</emphasis>
returns a pointer to the value itself.</para>
	  </listitem>
	</itemizedlist>
<para><emphasis role="bold">Note:</emphasis> You shouldn't alter the
string returned by <emphasis
role="bold">parAsStringNoCopy:</emphasis>.  It's owned by the
<classname>MKNote</classname> object.</para>

<para>If the parameter hasn't been set, the retrieval methods return
values as follows:</para>
      <itemizedlist>

<listitem><para> <emphasis role="bold">parAsDouble:</emphasis> returns
MK_NODVAL.</para>
	  </listitem>

<listitem><para> <emphasis role="bold">parAsInt:</emphasis> returns
MAXINT.</para>
	  </listitem>

<listitem><para> The string retrieval methods return an empty
string.</para>
	  </listitem>
	</itemizedlist>
<para>Unfortunately, you can't use MK_NODVAL in a simple comparison
predicate.  To check for this return value, you must call the in-line
function <emphasis role="bold">MKIsNoDVal()</emphasis>; the function
returns 0 if its argument is MK_NODVAL and nonzero if not:</para>

<programlisting>
/* Retrieve the value of the amplitude parameter. */
double amp = [aNote parAsDouble:MK_amp];

/* Test for the parameter's existence. */
if (!MKIsNoDVal(amp))
... /* do something with the parameter */
</programlisting>

<para>For most uses of parameters&horbar;in particular, if you're
designing a <classname>MKSynthPatch</classname> subclass&horbar;it's
important to know whether the parameter was actually set before
applying its value.  You can compare the retrieved values with the
values shown above to check whether the parameter had actually been
set, or you can test the <emphasis role="bold">BOOL</emphasis> value
returned by the <emphasis role="bold">isParPresent:</emphasis>
method:</para>

<programlisting>
/* Only retrieve bearing if its value was set. */
if ([aNote parIsPresent:MK_bearing])
    double theBearing = [aNote parAsDouble:MK_bearing];
</programlisting>
      
      <sect4><title>Choosing a Value</title>

<para>To properly set a parameter's value, you need to know the range
of values that are meaningful to the object that applies it.  The
MusicKit parameter lists given in Appendix B supply this information.
If you're creating an application (or writing a scorefile) in order to
synthesize <classname>MKNote</classname>s on the DSP or on an external
MIDI synthesizer, you should consult these lists to make sure you're
setting the <classname>MKNote</classname>s' parameters to reasonable
and musically useful values.</para>

<para>Three of the most commonly used parameters, those for pitch,
begin time, and duration, are special.  See 
<xref linkend="BasicParameters">, later in this chapter, for a discussion of
alternative ways to set and retrieve the values of these
parameters.</para>
      </sect4>

      <sect4><title>Object-Valued Parameters</title>

<para>Some parameters take objects as their values.  The methods for
setting an object-valued parameter are:</para>
      <itemizedlist>

<listitem><para> <emphasis role="bold">setPar:toEnvelope:</emphasis>
sets the value as an <classname>MKEnvelope</classname> object.
</para>
	    </listitem>

<listitem><para> <emphasis role="bold">setPar:toWaveTable:</emphasis>
sets the value as a <classname>MKWaveTable</classname> object.</para>
	    </listitem>
<listitem><para> <emphasis role="bold">setPar:toObject:</emphasis>
sets the value as a non-MusicKit object.</para>
	    </listitem>
      </itemizedlist>

<para><classname>MKEnvelope</classname>s and <classname>MKWaveTable</classname>s are
described later in this chapter.  The <emphasis
role="bold">setPar:toObject:</emphasis> method is provided so you can
set a parameter to an instance of one of your own classes.  The class
that you define should implement the following methods so its
instances can be written to and read from a scorefile:</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">writeASCIIStream:</emphasis>
provides instructions for writing the object as ASCII text.  In a
scorefile, the text that represents an object&horbar;this includes
<classname>MKEnvelope</classname>s and <classname>MKWaveTable</classname>s&horbar;is enclosed
in square brackets (<emphasis role="bold">[]</emphasis>).  The ASCII
representation of an object must not include a close bracket.  The
method's argument is the NXStream to which the text is written.</para>
		</listitem>

<listitem><para> <emphasis role="bold">readASCIIStream:</emphasis>
provides instructions for creating an object from its ASCII
representation.  When the method is called, the argument (an NXStream)
is pointing to the first character after the open bracket.  You should
leave the argument pointing to the close bracket.  In other words, you
should read in whatever you wrote out.</para>
		</listitem>
	      </itemizedlist>
<para>Both of these methods are called automatically when you read a
scorefile into your application (scorefile-reading methods are
described later in this chapter).</para>

<para>You can retrieve an object-valued parameter through the
following methods:</para>
      <itemizedlist>

<listitem><para> <emphasis role="bold">parAsEnvelope:</emphasis>
returns an <classname>MKEnvelope</classname> object.</para>
		</listitem>
<listitem><para> <emphasis role="bold">parAsWaveTable:</emphasis>
returns a <classname>MKWaveTable</classname> object.</para>
		</listitem>
<listitem><para> <emphasis role="bold">parAsObject:</emphasis> returns
a non-MusicKit object.</para>
		</listitem>
	      </itemizedlist>
<para>Unlike the value retrieval methods shown in the previous
section, these methods return <emphasis role="bold">nil</emphasis> if
the parameter's value isn't the correct type.</para>
	</sect4>
      </sect3>
    </sect2>
    <sect2 id="BasicParameters"><title>Basic Parameters</title>

<para>A handful of attributes are common to all musical notes: pitch,
loudness, begin time, and duration.  Special methods and values are
used to set the parameters that represent these attributes, as
explained in the following sections.</para>

      <sect3><title>Frequency and Pitch</title>

<para>Frequency and pitch are two terms that refer to the most
fundamental aspect of a musical sound: its register or tonal height.
Frequency is the exact measurement of the periodicity of an acoustical
waveform expressed in hertz.  Pitch, on the other hand, is an inexact
representation expressed in musical names such as F sharp, A flat, or
G natural.</para>

<para>When the DSP synthesizes a musical note, it produces a tone at a
specified frequency.  However, musicians think in terms of pitch.  To
bridge the gap between frequency and pitch, the MusicKit defines sets
of <emphasis>pitch variables</emphasis> and <emphasis>key
numbers</emphasis> that represent particular frequencies.</para>

	<sect4><title>Pitch Variables</title>

<para>A pitch variable takes the following form:</para>

<para><emphasis>pitchLetter</emphasis>[<emphasis>sharpOrFlat</emphasis>]<emphasis>octave</emphasis></para>
      <itemizedlist>

<listitem><para> <emphasis>pitchLetter</emphasis> is a lowercase
letter from <emphasis role="bold">a</emphasis> to <emphasis
role="bold">g</emphasis>.  As in standard music notation, the Music
Kit's pitch variables are organized within an octave such that
<emphasis role="bold">c</emphasis> is the lowest pitch and <emphasis
role="bold">b</emphasis> is the highest.</para>
	  </listitem>

<listitem><para> The optional <emphasis>sharpOrFlat</emphasis> is
<emphasis role="bold">s</emphasis> for sharp and <emphasis
role="bold">f</emphasis> for flat.  They raise or lower by a semitone
the pitch indicated by <emphasis>pitchLetter</emphasis>.</para>
	  </listitem>
<listitem><para> <emphasis>octave</emphasis> is 00 or an integer from
0 to 9.  The octave component of the pitch name variable places the
pitch class within a particular octave, where 00 is the lowest octave
and 9 is the highest.  Octaves are numbered such that <emphasis
role="bold">c4</emphasis> is middle C.</para>
	  </listitem>
	</itemizedlist>
<para>Some examples of pitch variables are:</para>

<para><emphasis role="bold">Pitch Variable Pitch</emphasis></para>

<para>ef4 E flat above middle C</para>

<para>gs3 G sharp below middle C</para>

<para>f00 F natural in the fifth octave below middle C</para>

<para>bs8 B sharp five octaves above middle C (the same as c9)</para>

<para>Notice that the natural sign isn't represented in the pitch
variables.  If neither the sharp nor the flat sign is present, the
pitch is automatically natural.  In addition, key signatures aren't
represented; the accidentals that define a key must be present in each
pitch that they affect.</para>
	</sect4>
	<sect4>
	  <title>Correspondence Between Pitch Variables and Frequencies</title>

<para>Each pitch variable represents a predefined frequency.  By
default, the frequencies that correspond to the pitch variables define
a <emphasis>twelve-tone equal-tempered</emphasis> tuning system, with
<emphasis role="bold">a4</emphasis> equal to 440.0 Hz:</para>
      <itemizedlist>

<listitem><para> Twelve-tone means that there are twelve discrete
tones within an octave.</para>
	  </listitem>
<listitem><para> Equal-tempered means that the frequency ratio between
any pair of successive tones is always the same.</para>
	  </listitem>
	</itemizedlist>
<para>This is the tuning system used to tune modern fixed-pitch
instruments, most notably the piano.  The complete table of pitch
variables and the corresponding default frequencies is given in
Appendix B of <emphasis>Reference</emphasis>.</para>
	</sect4>
	<sect4>
	  <title>Key Numbers</title>

<para>Another way to specify the pitch is to use a key number.  Key
numbers are integers that correspond to the keys of a MIDI keyboard.
As a MIDI standard, 60 is the key number for the middle C of the
keyboard.  The MusicKit provides constants to represent key numbers.
The form of these constants is like that of the pitch variables, but
with the letter <emphasis role="bold">k</emphasis> appended; for
example:</para>

<para><emphasis role="bold">Pitch Variable Key Number</emphasis>
</para>

<para>ef4 ef4k</para>

<para>gs3 gs3k</para>

<para>f00 f00k</para>

<para>bs8 bs8k</para>

<para>Key numbers are provided primarily to accommodate MIDI
instruments.  If you record a MIDI performance (using a
<classname>MKMidi</classname> object), the pitch specifications will
all be represented as key numbers.  When you realize
<classname>MKNote</classname>s on a MIDI synthesizer, the actual
frequency represented by a particular key number is controlled by the
synthesizer itself.  The standard of &ldquo;60 equals middle C&rdquo;
simply means that key number 60 creates a tone at whatever frequency
the synthesizer's middle C key is tuned to produce.</para>
	</sect4>
	<sect4>
	  <title>Specifying Pitch in a <classname>MKNote</classname></title>

<para>You can specify the pitch of <classname>MKNote</classname>
objects as a frequency or pitch variable (a <emphasis
role="bold">double</emphasis>), or as a key number (an <emphasis
role="bold">int</emphasis>).  These are represented by the parameter
tags <emphasis role="bold">MK_freq</emphasis> and <emphasis
role="bold">MK_keyNum</emphasis>.  Regardless of how it's synthesized
(on the DSP or on a MIDI instrument), the appropriate value is
converted from whichever parameter is present.</para>

<para>To set a <classname>MKNote</classname>'s pitch, you use the methods described
earlier:</para>

<programlisting>
/* You must import this file when using pitch variables. */
#import &lt;MusicKit/pitches.h&gt;

/* Set the MKNote's pitch to middle C as a frequency. */
[aNote setPar:MK_freq toDouble:261.625];

/* The same using a pitch variable. */
[aNote setPar:MK_freq toDouble:c4];

/* And as a key number. */
[aNote setPar:MK_keyNum toDouble:c4k];
</programlisting>

<para>The conversion between frequencies or pitch variables and key
numbers allows you to create Note objects that can be played on both
the DSP and on a MIDI instrument using the same pitch
parameter.</para>
	</sect4>
	<sect4>
<title>Retrieving Pitch from a <classname>MKNote</classname></title>

<para>Special methods are provided to retrieve pitch:</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">freq:</emphasis> returns a
<emphasis role="bold">double</emphasis> value as a frequency.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">keyNum:</emphasis> returns an
<emphasis role="bold">int</emphasis> as a key number.</para>
	  </listitem>
	</itemizedlist>
<para>If the <emphasis role="bold">MK_freq</emphasis> parameter isn't
present but <emphasis role="bold">MK_keyNum</emphasis> is, the
<emphasis role="bold">freq:</emphasis> method returns a frequency
value converted from the <emphasis role="bold">MK_keyNum</emphasis>
parameter.  Similarly, <emphasis role="bold">keyNum:</emphasis>
returns a key number value converted from <emphasis
role="bold">MK_freq</emphasis> in the absence of <emphasis
role="bold">MK_keyNum</emphasis>.</para>

<para>The MusicKit <classname>MKSynthPatch</classname>es use <emphasis
role="bold">freq:</emphasis> to retrieve pitch information;
<classname>MKMidi</classname> uses <emphasis
role="bold">keyNum:</emphasis>.</para>

<para>Keep in mind that either retrieval method converts a value from
the opposite parameter only if its own parameter isn't set.  In
addition, you can set <emphasis role="bold">MK_freq</emphasis> and
<emphasis role="bold">MK_keyNum</emphasis> independently of each
other: Setting one doesn't reset the other.</para>

<para>Since frequencies are continuous and key numbers are discrete,
the correspondence between them isn't exact; conversion from frequency
to key number sometimes requires approximation.  The pitch table in
Appendix B of <emphasis>Reference</emphasis> gives the frequency range
that corresponds to particular key numbers (in the default tuning
system).</para>
	</sect4>
	<sect4>
	  <title>Loudness</title>

<para>The perceived loudness of a musical note depends on a number of
factors, the most important being the amplitude of the waveform and
its spectral energy, or brightness.  All the MusicKit
<classname>MKSynthPatch</classname>es use the amplitude parameter,
<emphasis role="bold">MK_amp</emphasis>; most also use <emphasis
role="bold">MK_bright</emphasis>, the brightness parameter.</para>
	</sect4>
	<sect4>
	  <title>Amplitude</title>

<para>Amplitude is fairly straightforward: The value of the amplitude
parameter determines the strength of the signal produced by the DSP.
The value of <emphasis role="bold">MK_amp</emphasis> is retrieved as a
<emphasis role="bold">double</emphasis>.  Its value must be between
0.0 and 1.0, where 0.0 is inaudibly soft and 1.0 is a fully saturated
signal.  Perceived amplitude increases logarithmically: Successive
Notes with incrementally increasing amplitude values are perceived to
get louder by successively smaller amounts.  For instance, the
difference in loudness between amplitudes of 0.1 and 0.2 sounds much
greater than the difference between 0.8 and 0.9.</para>

<para>Amplitude is set and retrieved through the normal methods; for
example:</para>

<programlisting>
/* Set the amplitude of a MKNote. */
[aNote setPar:MK_amp toDouble:0.2];

/* Retrieve amplitude. */
double myAmp = [aNote parAsDouble:MK_amp];

/* Set the amplitude of a MKNote. */
[aNote setPar:MK_amp toDouble:MKdB(-15.0)];
</programlisting>

<para>The range of the decibel scale extends from negative infinity
(inaudible) to 0.0 (maximally loud).  Decibel scaling creates a linear
correspondence between increasing value and perceived loudness: The
perceived increase in loudness from -20.0 to -15.0 is the same as that
from -15.0 to -10.0 (as well as from -10.0 to -5.0 and from -5.0 to
0.0).</para>
	</sect4>
	<sect4>
	  <title>Brightness</title>

<para>Brightness can be thought of as a tone control.  The greater the
value of <emphasis role="bold">MK_bright</emphasis>, the brighter the
synthesized sound.  As you decrease brightness, the sound becomes
darker.  <emphasis role="bold">MK_bright</emphasis> is used
differently by the various <classname>MKSynthPatch</classname>
subclasses; usually it's used to modify the values of other
timbre-related parameters.  Some
<classname>MKSynthPatch</classname>es, such as those that perform
<classname>MKWaveTable</classname> synthesis, don't use <emphasis
role="bold">MK_bright</emphasis> at all.</para>

<para>Brightness values are usually set and retrieved through
<emphasis role="bold">setPar:toDouble:</emphasis> and <emphasis
role="bold">parAsDouble:</emphasis> (the MusicKit
<classname>MKSynthPatch</classname>es always retrieve the value of
<emphasis role="bold">MK_bright</emphasis> as a <emphasis
role="bold">double</emphasis>).  The range of valid brightness values
is, in general, 0.0 to 1.0; you can actually set <emphasis
role="bold">MK_bright</emphasis> to a value in excess of 1.0, although
this may cause distortion in some
<classname>MKSynthPatch</classname>es.  Specifying brightness in
decibels is possible, but the scale tends to have less meaning here
than it does for amplitude.</para>
	</sect4>
      </sect3>
    </sect2>
    <sect2><title>Begin Time and Duration</title>

<para>The begin time, or <emphasis>time tag</emphasis>, and duration
parameters of a <classname>MKNote</classname> are set through the
methods <emphasis role="bold">setTimeTag:</emphasis> and <emphasis
role="bold">setDur:</emphasis>.  Both methods take a <emphasis
role="bold">double</emphasis> argument that's measured in
<emphasis>beats</emphasis>.  By default, a beat is one second long;
however, you can change the size of a beat through methods defined in
the <classname>MKConductor</classname> class.</para>

<para>The retrieval methods <emphasis role="bold">timeTag</emphasis>
and <emphasis role="bold">dur</emphasis> return a
<classname>MKNote</classname>'s time tag and duration.  Because of the
specialized methods for setting and retrieving these parameters, they
don't have parameter tags to represent them, nor do they have print
names.  Their representation in a scorefile is explained in
<emphasis>Reference</emphasis>.</para>

<para>For some applications, setting a <classname>MKNote</classname>'s
time tag isn't necessary; for instance, you can design a
<classname>MKPerformer</classname> object that creates
<classname>MKNote</classname>s and performs them immediately.
However, in many musical applications&horbar;in particular, for any
application that adds <classname>MKNote</classname>s to a
<classname>MKPart</classname>&horbar;time tags are indispensable.  For
convenience, the <emphasis role="bold">newSetTimeTag:</emphasis>
method lets you create a new <classname>MKNote</classname> and set the
time tag value at the same time:</para>

<programlisting>
/* Create a new MKNote and set the time tag value to 3.5 beats. */
id myNote = [MKNote newSetTimeTag:3.5];
</programlisting>

<para>A newly created <classname>MKNote</classname> otherwise has a
time tag value of 1.0.  Time tags are typically measured from the
beginning of a performance (the <classname>MKPerformer</classname>
class provides methods that let you add a begin time offset).  The
<classname>MKNote</classname> in the example would thus be played
after three and a half beats of a performance.</para>

<para>Duration is also in beats and indicates, ostensibly, the
longevity of a <classname>MKNote</classname> during synthesis: When
the duration has expired, the <classname>MKNote</classname> doesn't
stop short; instead, its <classname>MKEnvelope</classname> objects (if
any) start to wind down.  The actual length of the
<classname>MKNote</classname> is its duration value plus the amount of
time it takes for its amplitude <classname>MKEnvelope</classname> to
finish.  This is described in detail in <xref
linkend="MKEnvelopeClass">, later in this chapter.</para>

<para>Many <classname>MKNote</classname>s don't have a duration value.
For example, some <classname>MKNote</classname> objects initiate a
synthesized tone that plays until a subsequent
<classname>MKNote</classname> object, also lacking a duration,
specifically turns it off.  The necessity or superfluity of the
duration value is described in the following sections.</para>
    </sect2>
    <sect2><title>Note Type and Note Tag</title>

<para>A <classname>MKNote</classname>'s note type describes its
musical function with regard to the life of a synthesized sound.
There are five note types.  Briefly they are:</para>
      <itemizedlist>

<listitem><para> NoteDur represents an entire musical note.
</para></listitem>

<listitem><para> NoteOn establishes the beginning of a note.
</para></listitem>

<listitem><para> NoteOff establishes the end of a note.
</para></listitem>

<listitem><para> NoteUpdate modifies a sounding note.
</para></listitem>

<listitem><para> Mute makes no sound.</para></listitem>
      </itemizedlist>
<para>Each of the five types is represented by an MKToken
constant:</para>
      <itemizedlist>

<listitem><para> MK_noteDur</para></listitem>

<listitem><para> MK_noteOn</para></listitem>

<listitem><para> MK_noteOff</para></listitem>

<listitem><para> MK_noteUpdate</para></listitem>

<listitem><para> MK_mute</para></listitem>
      </itemizedlist>
<para>Every <classname>MKNote</classname> has exactly one note type;
the default is <emphasis role="bold">MK_mute</emphasis>.  You set the
note type with <emphasis role="bold">setNoteType:</emphasis> and
retrieve it with <emphasis role="bold">noteType</emphasis>.</para>

<para>There are two styles for creating a complete musical note,
either with a single noteDur or with a noteOn/noteOff pair.</para>

<para>Note tags are integers that are used to identify
<classname>MKNote</classname> objects that are part of the same
phrase; in particular, matching note tags are used to create
noteOn/noteOff pairs and to associate noteUpdates with other
<classname>MKNote</classname>s.  The actual integer value of a note
tag has no significance.  The range of note tag values extends from 0
to 231-1.</para>

<para>You set a <classname>MKNote</classname>'s note tag through
<emphasis role="bold">setNoteTag:</emphasis> and retrieve it with
<emphasis role="bold">noteTag</emphasis>.  The C function <emphasis
role="bold">MKNoteTag()</emphasis> is provided to create note tag
values that are guaranteed to be unique across your entire
application&horbar;you should never create note tag values except
through this function.</para>

<para>The following example, in which a noteOff is paired with a
noteOn, demonstrates how to create and administer note tags:</para>

<programlisting>
/* Create a noteOn and a noteOff and set their time tags. */
id aNoteOn = [[MKNote alloc] initWithTimeTag:1.0];
id aNoteOff = [[MKNote alloc] initWithTimeTag:3.5];
[aNoteOn setNoteType:MK_noteOn];
[aNoteOff setNoteType:MK_noteOff];

/* Create a new note tag for the noteOn. */
[aNoteOn setNoteTag:MKNoteTag()];

/* Set the noteOff note tag to that of the noteOn. */
[aNoteOff setNoteTag:[myNoteOn noteTag]];
</programlisting>

<para>
The following sections further examine each note type and discuss note
tags as they apply to each type.
</para>
      <sect3><title>NoteDur</title>

<para>The information in a noteDur defines an entire musical note.  A
noteDur is distinguished by having a duration (&ldquo;Dur&rdquo; stands
for duration).  Of the five note types, only noteDur can have a
duration value&horbar;invoking <emphasis role="bold">setDur:</emphasis>
automatically sets a <classname>MKNote</classname>'s duration to
<emphasis role="bold">MK_noteDur</emphasis>.</para>

<para>You can associate any number of noteUpdates with a noteDur,
thereby changing the attributes of the musical note while it's
sounding.  In order to associate a noteUpdate to a noteDur, they must
be given the same note tag, as described above.  NoteUpdates are
described in a subsequent section.</para>
      </sect3>
      <sect3><title>NoteOn and NoteOff</title>

<para>The other way to define a complete musical note is to use a
noteOn/noteOff pair.  A noteOn starts a musical note and a subsequent
noteOff terminates it.  Each noteOn/noteOff pair must share a unique
note tag.</para>

<para>If the same note tag is given to successive noteOns that aren't
articulated by intervening noteOffs, the second and subsequent noteOns
retrigger the <classname>MKNote</classname>'s
<classname>MKEnvelope</classname>s when it's synthesized on the
DSP.</para>

<para>A noteOff triggers the release portion of a
<classname>MKNote</classname>'s <classname>MKEnvelope</classname>.
Any parameters that it contains are applied to that portion of the
<classname>MKNote</classname>, however brief.  See <xref
linkend="MKEnvelopeClass">, later in this chapter.</para>
      </sect3>
      <sect3><title>NoteUpdate</title>

<para>NoteUpdates are used to alter the parameters of a musical note
that's already underway.  A noteUpdate is associated with another
<classname>MKNote</classname> by virtue of matching note tags.  In the
following example, a noteUpdate is used to change the pitch of a
musical note represented by a noteDur:</para>

<programlisting>
id myNoteDur, myNoteUpdate;

/* Create a MKNote with a time tag and set its pitch, and duration. */
myNoteDur = [[MKNote alloc] initWithTimeTag:1.0];
[myNoteDur setPar:MK_freq toDouble:c4];
[myNoteDur setDur:3.0];

/* Create a noteUpdate with a time tag and set its pitch. */
myNoteUpdate = [[MKNote alloc] initWithTimeTag:2.5];
[myNoteUpdate setNoteType:MK_noteUpdate];
[myNoteUpdate setPar:MK_freq toDouble:d4];

/* Set the note tags to the same value. */
[myNoteDur setNoteTag:MKNoteTag()];
[myNoteUpdate setNoteTag:[myNoteDur noteTag]];
</programlisting>

<para>The effect of the two <classname>MKNote</classname>s is a
single, two-beat-long musical note that changes pitch after
one-and-a-half beats.</para>

<para>Only the parameters that are explicitly present in the
noteUpdate are applied to the sounding note: If a particular parameter
is present in the original <classname>MKNote</classname> but is absent
in an associated noteUpdate, the value of the original parameter is
retained.</para>

<para>A noteUpdate with no note tag affects all the currently sounding
<classname>MKNote</classname>s that are being realized through the
same <classname>MKSynthInstrument</classname> object.</para>
      </sect3>
      <sect3><title>Mute</title>

<para>A mute is normally ignored by
<classname>MKSynthPatch</classname> and <classname>MKMidi</classname>
objects, so it can't be used to represent a sound-making event.  Mutes
are useful for representing structural breakpoints such as bar lines.
If you send the <emphasis role="bold">setNoteTag:</emphasis> message
to a mute, its note type is changed to <emphasis
role="bold">MK_noteUpdate</emphasis>.</para>
      </sect3>
    </sect2>
    <sect2 id="MKEnvelopeClass"><title>The <classname>MKEnvelope</classname> Class</title>

<para>An envelope is a function that varies over time.  Envelopes are
extremely important to synthesized music because they allow continuous
control of the attributes of a sound.  For example, with an envelope
you can specify how quickly a musical note speaks and how long it
takes to die away.  Without envelopes, a synthesized tone would snap
on, maintain a steady amplitude for its entire duration, and then snap
off.  (&ldquo;Snap&rdquo; can be taken literally: Both the arrival and
the departure of the sound would be accompanied by an audible
click.)</para>

<para>An envelope is depicted as a continuous line on an xy coordinate
system, where time moves forward from left to right on the x-axis, and
the envelope's value at a particular time is given as y. <xref
linkend="figure3-2"> shows some typical envelope shapes.  The top two
envelopes, with their characteristic initial rise and ultimate fall,
are typical of those used to control amplitude.  The bottom one,
applied to frequency, would introduce some warble at the beginning and
end of a note.</para>

<figure id="figure3-2">
<title>Typical Envelopes</title>
<mediaobject>
<imageobject><imagedata fileref="EPS2.eps"></imageobject>
<imageobject><imagedata fileref="EPS2.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>Instances of the MusicKit's <classname>MKEnvelope</classname>
class are used to represent envelope functions.  An
<classname>MKEnvelope</classname> object contains a series of x,y
coordinates, or <emphasis>breakpoints</emphasis>, that mark a change
in an envelope's direction or trajectory.  <xref linkend="figure3-3"> superimposes
breakpoints on the previously illustrated envelope shapes (an open
circle denotes the location of a breakpoint).</para>

<figure id="figure3-3">
<title>Breakpoint Envelopes</title>
<mediaobject>
<imageobject><imagedata fileref="EPS5.eps"></imageobject>
<imageobject><imagedata fileref="EPS5.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

<para>An <classname>MKEnvelope</classname> object can have any number
of breakpoints, allowing you to create arbitrarily complex
functions.</para>

<para>You can use an <classname>MKEnvelope</classname> object to
control virtually any attribute of a sound synthesized on the DSP.
While <classname>MKEnvelope</classname> control is indispensable for
amplitude, it can also be used to good effect for frequency and
timbre-related attributes associated with particular synthesis
techniques.</para>

<para>Besides providing continuous control of a sound's attributes, an
<classname>MKEnvelope</classname> can also be used to retrieve
discrete values of y for given values of x.  The retrieved values can
then be used, for example, to set the same parameter in a series of
<classname>MKNote</classname>s, allowing you to control the
parameter's evolution over an entire musical phrase.</para>

<para>The following sections examine the methods that define
<classname>MKEnvelope</classname> objects and demonstrate how to use
them in DSP synthesis and for discrete-value retrieval.</para>

      <sect3><title>Defining an
      <classname>MKEnvelope</classname></title>

<para>The (x,y) value pairs that define an
<classname>MKEnvelope</classname>'s shape are set through the
<emphasis role="bold">setPointCount:xArray:yArray:</emphasis> method.
The first argument is the number of breakpoints in the
<classname>MKEnvelope</classname>; the other two arguments are arrays
of x values and y values:</para>

<programlisting>
/* Create an MKEnvelope object. */
id anEnvelope = [[MKEnvelope alloc] init];

/* Create and instantiate arrays for the x and y values. */
double xVals[] = {0.0, 1.0, 4.0, 5.0};
double yVals[] = {0.0, 1.0, 1.0, 0.0};

/* Define the MKEnvelope with data. */
[anEnvelope setPointCount:4 xArray:xVals yArray:yVals];
</programlisting>

<para>The elements in the x and y arrays are paired in the order
given.  Thus, the first breakpoint in an
<classname>MKEnvelope</classname> is created from the first element in
the x array and the first element in the y array, the second
breakpoint is created from the second elements of either array, and so
on.  <xref linkend="figure3-4"> illustrates the <classname>MKEnvelope</classname>
object defined in the example.  The x and y values for each breakpoint
are shown in parentheses.</para>

<figure id="figure3-4">
<title>Simple <classname>MKEnvelope</classname></title>
<mediaobject>
<imageobject><imagedata fileref="EPS6.eps"></imageobject>
<imageobject><imagedata fileref="EPS6.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>The way the x and y values are interpreted depends on the way
the <classname>MKEnvelope</classname> is used.  In general, an
<classname>MKEnvelope</classname> is scaled by other values, allowing
the same <classname>MKEnvelope</classname> object to be stretched and
squeezed to fit a number of different contexts.</para>
      </sect3>
      <sect3><title><classname>MKEnvelope</classname>s and the
      DSP</title>

<para>The most important use of an <classname>MKEnvelope</classname>
is to provide continuous control over a musical attribute of a
<classname>MKNote</classname> that's synthesized on the DSP.  To do
this, you supply the <classname>MKEnvelope</classname> object as a
parameter to the <classname>MKNote</classname>.  For example, an
<classname>MKEnvelope</classname> used to control amplitude is set as
a <classname>MKNote</classname>'s <emphasis
role="bold">MK_ampEnv</emphasis> parameter:</para>

<programlisting>
/* Create a MKNote and an MKEnvelope. */
id aNote = [[MKNote alloc] init];
id anEnvelope = [[MKEnvelope alloc] init];

/* Create x and y value arrays and define the MKEnvelope. */
double xVals = {0.0, 1.0, 4.0, 5.0};
double yVals = {0.0, 1.0, 1.0, 0.0};
[anEnvelope pointCount:4 xArray:xVals yArray:yVals];

/* Set the MKEnvelope to control aNote's amplitude. */
[aNote setPar:MK_ampEnv toEnvelope:anEnvelope];
</programlisting>

<para>The <classname>MKEnvelope</classname> defined here is the same
as the one illustrated in <xref linkend="figure3-4">, above.  When <emphasis
role="bold">aNote</emphasis> is synthesized its amplitude follows the
curve shown in the illustration.  It rises from zero, maintains a
steady state, and then falls back to zero.</para>

<para>As with any parameter, an
<classname>MKEnvelope</classname>-valued parameter is only meaningful
if it's looked for and used by the <classname>MKSynthPatch</classname>
object that synthesizes the Note.  Appendix B lists and describes the
<classname>MKEnvelope</classname> parameters used by the MusicKit
<classname>MKSynthPatch</classname> subclasses.</para>

<para>In addition, the MusicKit <classname>MKSynthPatch</classname>es
are designed such that <classname>MKEnvelope</classname>s are only
significant in a noteOn or a noteDur.  Setting an
<classname>MKEnvelope</classname> parameter in a noteOff or a
noteUpdate has no immediate effect, although it's used if the phrase
is rearticulated and the rearticulating <classname>MKNote</classname>
(by definition, a noteOn or noteDur) doesn't specify the
<classname>MKEnvelope</classname> parameter itself.</para>
	<sect4>
	  <title>Scale and Offset</title>

<para>Associated with each <classname>MKEnvelope</classname> parameter
provided by the Music Kit are two related parameters that interpret
the <classname>MKEnvelope</classname>'s y values.  The names of these
parameters are formed as <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">0</emphasis> and <emphasis role="bold">
MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">1</emphasis>:</para>
      <itemizedlist>

<listitem><para> <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">0</emphasis> is the value of the
<classname>MKEnvelope</classname> when y is 0.0.</para>
	  </listitem>
<listitem><para> <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">1</emphasis> is the value of the
<classname>MKEnvelope</classname> when y is 1.0.  As a convenience,
the parameter <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis> is defined as
a synonym for <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">1</emphasis>.</para>
	  </listitem>
	</itemizedlist>

<para>The parameters that interpret the amplitude
<classname>MKEnvelope</classname>, for example, are <emphasis
role="bold">MK_amp0</emphasis> and <emphasis role="bold">MK_amp1
</emphasis>(which is synonymous with <emphasis
role="bold">MK_amp</emphasis>).  Since amplitude should always rise
from and fall back to 0.0 (to avoid clicks), you'll probably never
need to set the value of <emphasis
role="bold">MK_amp0</emphasis>&horbar;if the parameter isn't set, its
value defaults to 0.0.  The amplitude
<classname>MKEnvelope</classname> is normally interpreted by setting
the value of <emphasis role="bold">MK_amp</emphasis> (only):</para>

<programlisting>
/* Set the amplitude MKEnvelope (as previously defined). */
[aNote setPar:MK_ampEnv toEnvelope:anEnvelope];

/* The value of MK_amp sets the value when y is 1.0. */
[aNote setPar:MK_amp toDouble:0.15];
</programlisting>

<para>During synthesis, <emphasis role="bold">aNote</emphasis>'s
amplitude is scaled according to the value of <emphasis
role="bold">MK_amp</emphasis>, as depicted in <xref linkend="figure3-5"> (notice that
the breakpoint values themselves don't change, only their
interpretations are affected).</para>

<figure id="figure3-5">
<title>Scaled Amplitude <classname>MKEnvelope</classname></title>
<mediaobject>
<imageobject><imagedata fileref="EPS7.eps"></imageobject>
<imageobject><imagedata fileref="EPS7.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>Technically, the interpretation of a particular value of y is
calculated according to the following formula:</para>

<para>interpretedValue = (<emphasis>scale</emphasis>* y) +
<emphasis>offset</emphasis></para>

<para>where <emphasis>scale</emphasis> is calculated as <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">1</emphasis> - <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">0</emphasis> and <emphasis>offset</emphasis> is simply the
value of <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">0</emphasis>.</para>
	</sect4>
	<sect4>
	  <title>The Stickpoint</title>

<para>When a <classname>MKSynthPatch</classname> receives a noteOn or
noteDur, it starts processing the <classname>MKNote</classname>'s
<classname>MKEnvelope</classname>s, reading their breakpoints one by
one.  The y values are scaled and offset as described above; the x
values are taken as seconds (with modifications described in the next
section).  If the <classname>MKNote</classname>'s duration (in
seconds) is greater than the duration of the
<classname>MKEnvelope</classname>&horbar;in other words, if the
<classname>MKEnvelope</classname> runs out of breakpoints before the
DSP is done synthesizing the <classname>MKNote</classname>&horbar;then
the final y value is maintained for the balance of the
<classname>MKNote</classname>.</para>

<para>To accommodate <classname>MKNote</classname>s of different
lengths, the <classname>MKEnvelope</classname> object lets you define
one of its breakpoints as a <emphasis>stickpoint</emphasis>.  When the
<classname>MKSynthPatch</classname> reads an
<classname>MKEnvelope</classname>'s stickpoint, it &ldquo;sticks&rdquo;
until a noteOff arrives (or the declared duration of a noteDur
elapses).  The <classname>MKEnvelope</classname> shown in the previous
example, with its flat middle section, can easily be redefined using a
stickpoint, as follows:</para>

<programlisting>
/* Instantiate arrays for x and y. */
double xVals = {0.0, 1.0, 2.0};
double yVals = {0.0, 1.0, 0.0};

/* Define the MKEnvelope and set the MK_amp constant. */
[anEnvelope pointCount:3 xArray:xVals yArray:yVals];
[aNote setPar:MK_amp toDouble:0.15];

/* Set the MKEnvelope's stickpoint. */
[anEnvelope setStickpoint:1];
</programlisting>

<para>The argument to <emphasis role="bold">setStickpoint:</emphasis>
is a zero-based index into the <classname>MKEnvelope</classname>'s
breakpoints.  In the example, <emphasis
role="bold">anEnvelope</emphasis>'s second breakpoint is declared to
be the stickpoint.  <xref linkend="figure3-6"> shows how the stickpoint allows the
same <classname>MKEnvelope</classname> to be applied to
<classname>MKNote</classname>s (or <classname>MKNote</classname>
phrases) with different durations.  The stickpoint is shown as a solid
circle; the sustained portion of the <classname>MKEnvelope</classname>
is indicated as a dashed line.  The tempo in the illustration is
assumed to be 60.0.</para>

<figure id="figure3-6">
<title><classname>MKEnvelope</classname> with Stickpoint</title>
<mediaobject>
<imageobject><imagedata fileref="EPS10.eps"></imageobject>
<imageobject><imagedata fileref="EPS10.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>Notice that the duration between the end of the stickpoint
segment and the following breakpoint is always the same (one second,
as defined by the <classname>MKEnvelope</classname> itself),
regardless of the length of the <classname>MKNote</classname>.</para>
	</sect4>
	<sect4>
	  <title>Attack and Release</title>

<para>An <classname>MKEnvelope</classname> object is divided into
three parts: attack, sustain, and release.  The stickpoint defines the
sustain; the attack is the portion that comes before the stickpoint
and the release is the portion that comes after it.  An
<classname>MKEnvelope</classname> can have any number of breakpoints
in its attack and release segments.</para>

<para>You can specify the absolute duration of the attack portion of
an <classname>MKEnvelope</classname> by setting the value of the
<emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">Att</emphasis> parameter; the release is set through
<emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">Rel</emphasis>.  For example, the amplitude attack and
release parameters are <emphasis role="bold">MK_ampAtt</emphasis> and
<emphasis role="bold">MK_ampRel</emphasis>, respectively.  The values
of these parameters are taken as the number of seconds (given as
<emphasis role="bold">double</emphasis>s) to spend in either segment,
as illustrated in <xref linkend="figure3-7">.  The x values of the breakpoints in the
two segments are scaled within the given durations to maintain their
defined proportions.</para>

<figure id="figure3-7">
<title>Attack and Release</title>
<mediaobject>
<imageobject><imagedata fileref="EPS11.eps"></imageobject>
<imageobject><imagedata fileref="EPS11.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para><emphasis role="bold">Note:</emphasis> Since they're set as
seconds (not beats), the attack and release times aren't affected by
tempo.</para>

<para><xref linkend="figure3-8"> shows the same (amplitude)
<classname>MKEnvelope</classname> used in the previous examples with
various attack and release values.</para>

<figure id="figure3-8">
<title><classname>MKEnvelope</classname> with Attack and
Release</title>
<mediaobject>
<imageobject><imagedata fileref="EPS14.eps"></imageobject>
<imageobject><imagedata fileref="EPS14.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para><xref linkend="figure3-9"> shows what happens when a noteOff arrives (or a
noteDur expires) during the attack portion of the
<classname>MKEnvelope</classname>&horbar;in other words, before the
stickpoint is reached.  For this illustration, both<emphasis
role="bold"> MK_ampAtt</emphasis> and <emphasis
role="bold">MK_ampRel</emphasis> are assumed to have values of
1.0.</para>

<figure id="figure3-9">
<title>Early noteOff</title>
<mediaobject>
<imageobject><imagedata fileref="EPS17.eps"></imageobject>
<imageobject><imagedata fileref="EPS17.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

<para>When the noteOff arrives, the <classname>MKEnvelope</classname>
heads for the first breakpoint in the release (the first breakpoint
after the stickpoint) from wherever it happens to be at the time.  The
release takes its full duration (as defined in the
<classname>MKEnvelope</classname> itself, or by <emphasis
role="bold">MK_ampRel</emphasis>, if present) regardless of whether
the noteOff arrives before or after the stickpoint is reached.</para>
	</sect4>
	<sect4>
	  <title>Modeling a Note without Sustain</title>

<para>Not every instrument can create a sustained tone; the amplitude
envelope of a piano tone, for example, is characterized by a sharp
rise and fall followed by a gradual but steady decay to quiescence.
This is depicted in <xref linkend="figure3-10">.</para>

<figure id="figure3-10">
<title>Piano <classname>MKEnvelope</classname></title>
<mediaobject>
<imageobject><imagedata fileref="EPS18.eps"></imageobject>
<imageobject><imagedata fileref="EPS18.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

<para>To simulate this sort of envelope shape, yet still accommodate
<classname>MKNote</classname>s of any length, the
<classname>MKEnvelope</classname> object definition would look
something like this:</para>

<programlisting>
double xVals = {0.0, 0.05, 0.2, 0.5, 8.0, 8.15};
double yVals = {0,0, 1.0, 0.5, 0.3, 0.0, 0.0};
[anEnvelope setPointCount:6 xArray:xVals yArray:yVals];

/* Set the stickpoint to breakpoint 4, xy:(8.0, 0.0). */
[anEnvelope setStickpoint:4];
</programlisting>

<para>The <classname>MKEnvelope</classname> is depicted in <xref linkend="figure3-11"></para>

<figure id="figure3-11">
<title>Simulated Piano <classname>MKEnvelope</classname></title>
<mediaobject>
<imageobject><imagedata fileref="EPS19.eps"></imageobject>
<imageobject><imagedata fileref="EPS19.gif"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>Notice that the <classname>MKEnvelope</classname>'s stickpoint
is, curiously enough, set to a breakpoint that has a y value of 0.0.
Equally curious is the release portion of the
<classname>MKEnvelope</classname>: a flat piece of seemingly useless
real estate.  However, consider the result of the two possible
scenarios:</para>

      <itemizedlist>

<listitem><para> The noteOff arrives after the stickpoint is reached.
In this case, the synthesized sound has already decayed to an
amplitude of 0.0.  When the noteOff arrives, the release portion is
indeed executed, but since the amplitude is already at 0.0, the
release portion doesn't produce an audible effect.</para>
	  </listitem>
<listitem><para> The noteOff arrives before the stickpoint is reached.
The release portion is triggered, causing the amplitude to decay to
0.0 in 0.15 seconds.</para>
	  </listitem>
	</itemizedlist>
<para>Attack and release durations on a nonsustaining instrument are
generally invariant, so you would rarely set the <emphasis
role="bold">MK_ampAtt</emphasis> and <emphasis
role="bold">MK_ampRel</emphasis> parameter.</para>
	</sect4>
	<sect4>
	  <title>Portamento</title>

<para>The MusicKit provides an additional parameter, <emphasis
role="bold">MK_portamento</emphasis>, with which you can further
manipulate your <classname>MKEnvelope</classname>s' attack times.
Like the <emphasis
role="bold">MK_</emphasis><emphasis>attribute</emphasis><emphasis
role="bold">Att</emphasis> parameters, <emphasis
role="bold">MK_portamento</emphasis> takes a <emphasis
role="bold">double</emphasis> value that's measured in seconds, but
rather than affect the entire attack portion, it sets the duration
between the first two breakpoints only.  Also, as used by the
<classname>MKSynthPatch</classname>es provided by the Music kit,
<emphasis role="bold">MK_portamento</emphasis> affects all the
<classname>MKEnvelope</classname>s in a
<classname>MKNote</classname>&horbar;there aren't individual portamento
parameters for amplitude, frequency, and so on.  In a
<classname>MKNote</classname> that contains a portamento value and one
or more attack scalers, the attacks of the individual
<classname>MKEnvelope</classname>s are scaled before the value of
<emphasis role="bold">MK_portamento</emphasis> is applied.</para>

<para><emphasis role="bold">MK_portamento</emphasis> is provided so
you can easily and quickly control, to some degree, the rearticulation
of a <classname>MKNote</classname>'s
<classname>MKEnvelope</classname>s.  As such, it's only significant in
a <classname>MKNote</classname> that rearticulates a phrase&horbar;it's
ignored in a noteDur with no note tag, and has no immediate effect in
a noteOn or a noteDur with a previously inactive note tag (although,
in the latter case, the value of <emphasis
role="bold">MK_portamento</emphasis> is stored in anticipation of
subsequent rearticulations).</para>

<para>You should keep in mind that portamento is optional.  It can be
quite useful if you're modelling an instrument that has different
attack characteristics depending on whether a
<classname>MKNote</classname> is the beginning of a new phrase or part
of a legato passage.  For example, in some instruments, such as a
horn, the attack of an initial musical note&horbar;in amplitude,
frequency, and timbre&horbar;is more drawn out than in the subsequent
notes of a phrase.  To simulate such an instrument, it's convenient to
use <emphasis role="bold">MK_portamento</emphasis> to affect all the
<classname>MKEnvelope</classname>s at once.</para>
	</sect4>
	<sect4>
	  <title>Smoothing</title>

<para>The previous examples have shown the lines that connect an
<classname>MKEnvelope</classname>'s breakpoints as straight segments.
In reality, as synthesized by the DSP, these segments follow an
asymptotic curve.  In an asymptotic curve, the target is never fully
reached&horbar;the curve rises (or falls) in successively smaller steps
as it approaches the target.  However, there's a point in the curve
where the target is perceived to have been attained.  This point is
controlled by the smoothing value.</para>

<para>By default, smoothing is 1.0, a value that's used to mean that
the point at which the target is perceived to have been reached is
equal to the difference between the x values in successive
breakpoints; in other words, it takes the entire time between
breakpoints to reach the target y value.  Other values are, similarly,
the ratio of curve duration to overall duration between a pair of
breakpoints.  For example, a smoothing of 0.5 means it takes half the
time between a pair of breakpoints to (perceptually) complete the
curve between the breakpoints' y values.  A smoothing value in excess
of 1.0 falls short of the target altogether (it takes longer than the
allotted time to reach the target).</para>

<para>You can set the smoothing value for each breakpoint by defining
the <classname>MKEnvelope</classname> through an alternative
method:</para>

<para><emphasis
role="bold">setPointCount:xArray:orSamplingPeriod:yArray:</emphasis>
</para>

<para><emphasis
role="bold">smoothingArray:orDefaultSmoothing:</emphasis></para>

<para>Smoothing is set as either an array of values (one for each
breakpoint) passed to as the argument to the <emphasis
role="bold">smoothingArray:</emphasis> keyword, or as a default value
passed as the argument to the <emphasis
role="bold">orDefaultSmoothing:</emphasis> keyword.  The default
smoothing is used only if the argument to <emphasis
role="bold">smoothingArray:</emphasis> is NULL.</para>

<para>Smoothing is, admittedly, a somewhat elusive concept, best
explained by illustration.  <xref linkend="figure3-12"> shows the shape of an
<classname>MKEnvelope</classname> that uses various smoothing values
between successive breakpoints.  The values in parentheses are the x,
y, and smoothing values for each breakpoint.</para>

<figure id="figure3-12">
<title><classname>MKEnvelope</classname> with Smoothing</title>
<mediaobject>
<imageobject><imagedata fileref="EPS20.eps"></imageobject>
<imageobject><imagedata fileref="EPS20.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>Notice that the smoothing value is omitted from the first
breakpoint.  While a smoothing value must be supplied as the first
element in the smoothing array (if you use the <emphasis
role="bold">smoothingArray:</emphasis> keyword), this value is
actually ignored when the <classname>MKEnvelope</classname> is
synthesized.  This is because a breakpoint's smoothing value applies
to the curve leading into it&horbar;the curve from the previous
breakpoint to the current one.  Since there isn't a previous
breakpoint before the first one, the smoothing value for breakpoint 0
is thrown away.</para>

<para>Returning to the illustration, the smoothing value for the
second breakpoint is 1.0; thus the curve leading from the first
breakpoint into the second breakpoint takes up the entire duration
between the two points.  The smoothing value for the third break point
is 0.2; the curve leading into the third breakpoint reaches the target
y value with time to spare.  The fourth breakpoint has a smoothing of
0.0.  This means that it takes no time to reach the target; the
<classname>MKEnvelope</classname> immediately leaps to the target y
value.  (Note that a smoothing of 0.0 is the only way to ensure that
the asymptotic curve will, in truth, reach its target.)  The final
breakpoint smoothing value is 0.5.  Accordingly, the curve reaches the
target halfway between breakpoints.</para>

<para>While smoothing control is provided for completeness, most
musical applications will be satisfied with the default smoothing
provided by the <emphasis
role="bold">setPointCount:xArray:yArray:</emphasis> method.</para>
	</sect4>
	<sect4>
	  <title>Sampling Period</title>

<para>You may have noticed that the <classname>MKEnvelope</classname>
definition method that brought you smoothing also introduced an
alternate way to set an <classname>MKEnvelope</classname>'s x values.
Rather than define x values in an array, you can also set them as a
default increment by passing a (<emphasis
role="bold">double</emphasis>) value to the method's <emphasis
role="bold">orSamplingPeriod:</emphasis> keyword.  Again, the default
argument is used only if the array argument (in this case, the
argument to <emphasis role="bold">xArray:</emphasis>) is NULL.</para>

<para>If you use a sampling period, the first x value is always 0.0.
Successive x values are integer multiples of the sampling period
value.</para>
	</sect4>
      </sect3>
      <sect3>
	<title>Discrete Value Lookup</title>

<para>The other way to use an <classname>MKEnvelope</classname> is to
retrieve a discrete value of y for a given x.  This is performed in a
single method, <emphasis role="bold">lookupYForX:</emphasis>, which
takes a <emphasis role="bold">double</emphasis> argument that
specifies an x value and returns the y value that corresponds to it.
If the x value doesn't lie directly on a breakpoint, a linear
interpolation between the y values of the surrounding breakpoints is
performed to determine the appropriate value.  For example, consider a
simple, two-breakpoint <classname>MKEnvelope</classname> defined as
follows:</para>

<programlisting>
double xVals = {0.0, 1.0};
double yVals = {0.0, 2.0};
id anEnvelope = [[MKEnvelope alloc] init];

[anEnvelope setPointCount:2 xArray:xVals yArray:yVals];
</programlisting>

<para>The message</para>

<programlisting>
double interpY = [anEnvelope lookupYForX:0.5];
</programlisting>

<para>returns 1.0.  The computation is illustrated in <xref linkend="figure3-13"></para>

<figure id="figure3-13">
<title>Linear Interpolation</title>
<mediaobject>
<imageobject><imagedata fileref="EPS21.eps"></imageobject>
<imageobject><imagedata fileref="EPS21.png"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>


<para>With discrete-value lookup, the
<classname>MKEnvelope</classname>'s stickpoint and smoothing values
are ignored.  Also, using an <classname>MKEnvelope</classname> in this
way doesn't require its presence in a <classname>MKNote</classname>
object; thus, the parameters that help shape an
<classname>MKEnvelope</classname> used for DSP synthesis, such as
<emphasis role="bold">MK_amp</emphasis>, <emphasis
role="bold">MK_ampAtt</emphasis>, and <emphasis
role="bold">MK_ampRel</emphasis>, aren't applied to discrete-value
lookup.</para>

<para>If you request a discrete y value for an x that's out of bounds,
the <emphasis role="bold">lookupYForX:</emphasis> method returns the y
value of the breakpoint at the exceeded boundary.  For example (using
the same <classname>MKEnvelope</classname>), the message</para>

<programlisting>
/* Specify an x for which there is no y. */
double interpY = [anEnvelope lookupYForX:1.5];
</programlisting>

<para>returns 2.0, as it also would for any argument greater than 1.0.
Similarly, any argument that's less than 0.0 would return (from this
<classname>MKEnvelope</classname>) 0.0.</para>
      </sect3>
      <sect3><title><classname>MKEnvelope</classname>s in Scorefile
      Format</title>

<para>When you write a <classname>MKScore</classname> to a scorefile,
either through a message to the <classname>MKScore</classname> object
or by using a ScorefileWriter in a performance, the
<classname>MKEnvelope</classname> objects that appear in the
<classname>MKNote</classname>s in the <classname>MKScore</classname>
are written out as a series of breakpoints in parentheses.  The
<classname>MKEnvelope</classname>'s stickpoint, if any, is indicated
by the presence of a vertical bar following the so-designated
breakpoint.  The entire <classname>MKEnvelope</classname>
representation is enclosed by square brackets.  For example:</para>

<programlisting>
[(0.0, 0.0, 1.0) (0.3, 1.0, 1.0) | (0.5, 0.0, 1.0)]
</programlisting>

<para>The three values inside the parentheses are, in order, the
breakpoint's x, y, and smoothing values.  The smoothing value is
always written out&horbar;keep in mind that smoothing defaults to 1.0.
In this example, the second point is the stickpoint.</para>

<para>If you give the <classname>MKEnvelope</classname> a name before
you write the scorefile, the <classname>MKEnvelope</classname> is only
written in this long form once; subsequent references (in the
scorefile) are made to the <classname>MKEnvelope</classname> object by
its name.  To name an <classname>MKEnvelope</classname>, call the
<emphasis role="bold">MKNameObject()</emphasis> C function:</para>

<programlisting>
MKNameObject("env1", anEnvelope);
</programlisting>

<para>It's a good idea to name your <classname>MKEnvelope</classname>
objects.  This saves space in the scorefile and also makes processing
the file during a performance more efficient.</para>

<para>A named <classname>MKEnvelope</classname> appears in a scorefile
statement as:</para>

<programlisting>
BEGIN;
. . .
noteOn ... ampEnv:envelope env1=[(0.0, 0.0, 1.0) ... ] ... ;
. . .
</programlisting>

<para>(The noteOn type is used here only as an example.)  <emphasis
role="bold">envelope</emphasis> is a keyword that declares the
following name (<emphasis role="bold">env1</emphasis> in the example)
to represent an <classname>MKEnvelope</classname>.</para>

<para>If you write your own scorefile, you should be aware of the
following:</para>

      <itemizedlist>

<listitem><para> The x, y, and smoothing values can be expressions.
Because of this, the three values must be separated by commas.</para>
	  </listitem>

<listitem><para> The smoothing value is sticky; it applies to the
breakpoint in which it appears and to all subsequent breakpoints in
that <classname>MKEnvelope</classname> declaration (until another
smoothing value is encountered).</para>
	  </listitem>
<listitem><para> If you don't specify a smoothing value, it defaults
to 1.0.</para>
	  </listitem>
<listitem><para> You should declare and set all your
<classname>MKEnvelope</classname> objects as <emphasis
role="bold">envelope</emphasis> variables in the header of the
scorefile.  This makes reading the file more efficient.</para>
	  </listitem>
	</itemizedlist>

<para>For more on the scorefile format and ScoreFile language, see
<emphasis>Reference</emphasis>.</para>
      </sect3>
    </sect2>
    <sect2><title>The <classname>MKWaveTable</classname> Class</title>

<para><classname>MKWaveTable</classname> objects are used exclusively
in DSP synthesis to describe and create musical timbres.  While
<classname>MKWaveTable</classname> synthesis has limitations, it's a
particularly easy and direct way to create a library of sounds.
However, to intelligently define a <classname>MKWaveTable</classname>,
you need to be familiar with a few basic concepts of musical
acoustics.  <xref linkend="WhatIsSound"> in <xref linkend="Chapter2">
introduces some of these fundamentals; the cogent points from <xref
linkend="Chapter2"> are summarized and new concepts that pertain to
<classname>MKWaveTable</classname>s are introduced in the next
section.</para>

      <sect3><title>Summary of Musical Acoustics</title>

<para>When matter vibrates, a pressure disturbance is created in the
surrounding air.  The pressure disturbance travels as a wave to your
ears and you hear a sound.  A sound, particularly if it's a musical
sound, can be characterized by its <emphasis>waveform</emphasis>, the
shape of the air pressure's rise and fall.  Waveforms created by
musical instruments are generally periodic; this means that the
pressure rises and falls in a cyclical pattern.</para>

<para>A periodic waveform has two basic characteristics, frequency and
amplitude:</para>

      <itemizedlist>

<listitem><para> The number of pattern repetitions, or
<emphasis>periods</emphasis>, within a given amount of time determines
a sound's frequency (pitch).  Frequency is measured in
<emphasis>hertz</emphasis> (abbreviated Hz), or cycles per second.
For example, a musical sound with a period that repeats itself 440
times a second produces a tone at 440 Hz (A above middle C).</para>
	  </listitem>
<listitem><para> The amplitude of a sound wave is the amount of energy
in the air pressure disturbance.  Amplitude is heard as
loudness&horbar;the greater the energy, the louder the sound.  (There
are other factors that contribute to the loudness of a sound, but
amplitude is generally the most important.)  A number of different
methods are used to measure loudness; of greatest use for musical
purposes is to describe the loudness of a sound (or, as we shall see,
a component of a sound) in comparison with another sound (or sound
component).</para>
	  </listitem>
	</itemizedlist>
<para>A special waveform is the <emphasis>sine wave</emphasis>: Sine
waves are important to musical acoustics in that they define the basic
component used to describe musical sounds: Any periodic waveform can
be broken down into one or more sine waves.  The sine waves that make
up a musical sound have frequencies that are (usually) integer
multiples of a basic frequency called the
<emphasis>fundamental</emphasis>.  For example, if you pluck the B
string on a guitar, it produces a fundamental frequency of
approximately 494 Hz.  However, the sound that's produced contains
sine waves with frequencies that are integer multiples of 494:</para>

<programlisting>
494 * 1 = 494

494 * 2 = 988

494 * 3 = 1482

494 * 4 = 1976
</programlisting>

<para><emphasis>and so on</emphasis></para>

<para>Sine wave components, or <emphasis>partials</emphasis>, that are
related to each other as integer multiples of a fundamental frequency
are said to make up a <emphasis>harmonic series</emphasis>.  A musical
sound can also have partials that are inharmonically related to the
fundamental; for example, the shimmer and pungency of a bell's tone is
created by the abundance of inharmonic partials.  However, as
explained later, a <classname>MKWaveTable</classname> object is best suited to represent
timbres that are created from a harmonic series.</para>

<para>The partials in a sound have amplitudes that are measured in
relation to each other.  For the guitar, the amplitude of each
successive sine wave is generally less than that of the previous
partial.</para>

<para>The fundamental (the partial at the fundamental frequency)
needn't have the greatest amplitude of all the partials, nor must
successive partials decrease in amplitude.  Some instruments, such as
the bassoon, have very little energy at the fundamental.  Nonetheless,
your ears decode the information in a harmonic series such that there
is rarely confusion about the frequency of the fundamental; in other
words, we almost always hear the fundamental as the frequency that's
the least common denominator of the partials that make up the
sound.</para>
      </sect3>
      <sect3><title>Constructing a <classname>MKWaveTable</classname></title>

<para>A <classname>MKWaveTable</classname> object represents one complete period of a musical
waveform.  There are two ways to create a <classname>MKWaveTable</classname>, as embodied by
<classname>MKWaveTable</classname>'s subclasses, <classname>MKPartials</classname> and <classname>MKSamples</classname>:</para>

	<itemizedlist>

<listitem><para> With a <classname>MKPartials</classname> object, you can define a
<classname>MKWaveTable</classname> by specifying the individual partials that make up the
waveform.</para>
	  </listitem>
<listitem><para> A <classname>MKSamples</classname> object represents a waveform as a series
of sound samples.  It uses a <classname>Snd</classname> object
(defined by the SndKit) as its data.</para>
	  </listitem>
	</itemizedlist>
	<sect4><title>The <classname>MKPartials</classname> Class</title>

<para>You define a <classname>MKPartials</classname> object by supplying the frequency,
amplitude, and phase information for a series of partials.  This is
done through the method <emphasis
role="bold">setPartialCount:freqRatios:ampRatios:phases:orDefaultPhase:</emphasis>.
The first argument is the number of partials; the next three arguments
are arrays of <emphasis role="bold">double</emphasis> data that
specify the frequency ratios, amplitude ratios, and initial phases of
the partials, respectively.  You can also set the phase as a constant
by passing a <emphasis role="bold">double</emphasis> as the argument
to the <emphasis role="bold">orDefaultPhase:</emphasis> keyword.  In
this case, you must pass NULL as the argument to <emphasis
role="bold">phases:</emphasis>.</para>

<para>In the following example, a waveform is created from a series of
partials that are integer multiples of a fundamental frequency; the
partials decrease in amplitude as they increase in frequency.</para>

<programlisting>
/* Create the MKPartials object. */
id aPartials = [MKPartials new];
double freqs[] = {1.0,2.0,3.0,4.0,5.0,6.0};
double amps[] = {1.0,0.5,0.25,0.12,0.06,0.03};

/* Fill the object with data. */
[aPartials setPartialCount: 6
                freqRatios: freqs
                 ampRatios: amps
                    phases: NULL
            orDefaultPhase: 0.0];
</programlisting>

<para><emphasis role="bold">Note:</emphasis> Phase is generally
unimportant in creating musical timbres, although it can drastically
affect a waveform that's used as a low-frequency control signal, such
as vibrato.</para>

<para>The frequencies in a <classname>MKPartials</classname> object are specified as ratios,
or multiples, of a fundamental frequency (the fundamental is
represented by a frequency ratio of 1.0).  The actual (fundamental)
frequency of the waveform created from a <classname>MKPartials</classname> depends on the how
the object is used by the <classname>MKSynthPatch</classname> that
synthesizes it.  In general, the waveform is &ldquo;transposed&rdquo; to
produce the frequency specified in a <classname>MKNote</classname>'s
frequency parameter, <emphasis role="bold">MK_freq</emphasis>.
Similarly, the amplitude of each partial is relative to the value of
another parameter, usually <emphasis
role="bold">MK_amp</emphasis>.</para>
	</sect4>
      </sect3>
      <sect3><title>The <classname>MKSamples</classname> Class</title>

<para>The <classname>MKSamples</classname> class lets you create a <classname>MKWaveTable</classname> through
association with a <classname>Snd</classname> object (an instance of
the SndKit's <classname>Snd</classname> class).  This is done by
invoking the <classname>MKSamples</classname>' <emphasis role="bold">setSound:</emphasis>
method:</para>

<programlisting>
/* You must import the SndKit's header file. */
#import &lt;SndKit/SndKit.h&gt;
. . .

/* Create a MKSamples object and a Snd object. */
id aSamples = [MKSamples new];
id aSound = [Snd new];

/* Fill the Snd with data. */
. . .

/* Associate the Snd with the MKSamples. */
[aSamples setSound:aSound];
</programlisting>

<para>A copy of the <classname>Snd</classname> object is created and
stored in the <classname>MKSamples</classname> object when <emphasis
role="bold">setSound:</emphasis> is invoked, so it's important that
you fill the <classname>Snd</classname> with data before invoking the
method.  Chapter 2 describes ways to create Sound data.</para>

<para>You can also associate a <classname>MKSamples</classname> with a
<classname>Snd</classname> by reading a soundfile, through the
<emphasis role="bold">readSoundfile:</emphasis> method.  The <classname>MKSamples</classname>
object creates a <classname>Snd</classname> object and then reads the
soundfile by sending <emphasis
role="bold">newFromSoundfile:</emphasis> to the
<classname>Snd</classname>.  The argument is a UNIX pathname that must
include the soundfile-identifying &ldquo;.snd&rdquo; extension.</para>

<para>A <classname>MKSamples</classname>' <classname>Snd</classname> object must contain one
channel of 16-bit linear, sampled data.  The length of the data (the
number of samples) must be a power of two if it is to be used for an
oscillator table.
</para>
      </sect3>
      <sect3><title>Setting a <classname>MKWaveTable</classname> in a
      <classname>MKNote</classname></title>

<para>To hear the timbre represented by a
<classname>MKWaveTable</classname> object, you set the
<classname>MKWaveTable</classname> as a parameter of a
<classname>MKNote</classname> and then play the
<classname>MKNote</classname> using a
<classname>MKSynthPatch</classname> that recognizes the parameter.
Most of the Music Kit <classname>MKSynthPatch</classname>es recognize
the <emphasis role="bold">MK_waveform</emphasis> parameter:</para>

<programlisting>
/* Create a MKNote. */
id aNote = [MKNote new];

/* Set its MK_waveform value. */
[aNote setPar:MK_waveform toWaveTable:aPartials];
</programlisting>

<para>In this example, the value of <emphasis
role="bold">MK_waveform</emphasis> is set to the previously defined
<classname>MKPartials</classname> object, <emphasis
role="bold">aPartials</emphasis>.  The manner in which the
<classname>MKPartials</classname> object is used during synthesis
depends on the <classname>MKSynthPatch</classname> to which the
<classname>MKNote</classname> is sent.</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id=GroupingNotes>
<title>Grouping Notes</title>

<para>The <classname>MKPart</classname> and
<classname>MKScore</classname> classes are designed to group
<classname>MKNote</classname> objects.  As their names imply, a
<classname>MKPart</classname> represents a series of
<classname>MKNote</classname>s that are realized on the same
<classname>MKInstrument</classname>; a <classname>MKScore</classname> represents all or part of
a composition and consists of some number of
<classname>MKPart</classname>s.  For storage, a
<classname>MKScore</classname> can be written to the disk as a
scorefile or a midifile.</para>

<para>The first part of this section explains the methods used to add
<classname>MKNote</classname>s to <classname>MKPart</classname>s,
<classname>MKPart</classname>s to <classname>MKScore</classname>s, and
to write a <classname>MKScore</classname> as a file.  The second part,
<xref linkend="RetrievingMKScoresMKPartsAndMKNotes">, presents methods
and techniques for retrieving, querying, and further manipulating
<classname>MKPart</classname>s, <classname>MKScore</classname>s, and
the Notes they contain.  Finally, the special
<classname>MKNote</classname>s called <classname>MKPart</classname>
info and <classname>MKScore</classname> info are described.</para>

    <sect2><title>Constructing a
      <classname>MKScore</classname></title> <sect3><title>Adding a
      Note to a <classname>MKPart</classname></title>

<para>A <classname>MKPart</classname> is a time tag sorted collection
of <classname>MKNote</classname> objects.  A
<classname>MKPart</classname> can contain any number of
<classname>MKNote</classname>s.  While the
<classname>MKNote</classname>s within a <classname>MKPart</classname>
are sorted by time tag value, every <classname>MKNote</classname> in
the <classname>MKPart</classname> needn't have a unique time tag; a
<classname>MKPart</classname> can represent simultaneous (and
otherwise overlapping) <classname>MKNote</classname>s.  However, a
single <classname>MKNote</classname> can only belong to one
<classname>MKPart</classname> at a time.</para>

<para>There are three methods for adding a
<classname>MKNote</classname> to a
<classname>MKPart</classname>:</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">addToPart:</emphasis>, a
<classname>MKNote</classname> method</para>
	  </listitem>
<listitem><para> <emphasis role="bold">addNote:</emphasis>, a
<classname>MKPart</classname> method
</para>
	  </listitem>
<listitem><para> <emphasis role="bold">addNoteCopy:</emphasis>, also a
<classname>MKPart</classname> method</para>
	  </listitem>
	</itemizedlist>
<para>The first two are functionally equivalent, allowing you to add a
<classname>MKNote</classname> to a <classname>MKPart</classname> by
messaging either object:</para>

<programlisting>
[myNote addToPart:myPart];
/* is the same as */
[myPart addNote:myNote];
</programlisting>

<para>Since a <classname>MKNote</classname> object can only belong to
one <classname>MKPart</classname> at a time, when you add a
<classname>MKNote</classname> to a <classname>MKPart</classname>, it's
first removed from the <classname>MKPart</classname> that it's
currently a member of, if any.  Both <emphasis
role="bold">addNote:</emphasis> and <emphasis
role="bold">addToPart:</emphasis> return the <emphasis
role="bold">id</emphasis> of the <classname>MKNote</classname>'s old
<classname>MKPart</classname> (the <classname>MKPart</classname> from
which the <classname>MKNote</classname> was removed).</para>

<para><emphasis role="bold">addNoteCopy:</emphasis> creates (and
returns) a new <classname>MKNote</classname> object as a copy of its
argument and adds the copy to the receiver.  The argument
<classname>MKNote</classname> itself isn't removed from its
<classname>MKPart</classname>.  The method creates the
<classname>MKNote</classname> copy by invoking
<classname>MKNote</classname>'s copy method.</para>

<para>You can continue to modify a <classname>MKNote</classname>
(setting its parameter values, note type, time tag, and so on) after
it has been added to a <classname>MKPart</classname> object.  A
<classname>MKPart</classname> sorts its <classname>MKNote</classname>s
automatically, so you can add them in any order&horbar;you don't have to
add them by order of their time tag values.  If you change the time
tag of a <classname>MKNote</classname> after you add it to a
<classname>MKPart</classname>, the <classname>MKNote</classname> is
automatically repositioned in the <classname>MKPart</classname>.
</para>

<para>Methods for adding a collection of
<classname>MKNote</classname>s to a
<classname>MKPart</classname>&horbar;for instance, adding the contents
of one <classname>MKPart</classname> to another
<classname>MKPart</classname>&horbar;are described below, in 
<xref linkend="AddingAndRemovingGroupsOfNotes">.</para>
      </sect3>
      <sect3><title>Naming a <classname>MKPart</classname></title>

<para>A <classname>MKPart</classname> object has a print name that's
used when writing it to a scorefile (or, more accurately, when the
<classname>MKScore</classname> to which the
<classname>MKPart</classname> belongs is written to a scorefile).  The
<emphasis role="bold">MKNameObject()</emphasis> function is used to
name a <classname>MKPart</classname>; like all MusicKit names, a
<classname>MKPart</classname>'s name is case-sensitive and consists of
a letter followed by a string of alphanumeric characters:</para>

<programlisting>
MKNameObject("Solo", aPart);
</programlisting>

<para>To retrieve a <classname>MKPart</classname>'s name, call the C
function <emphasis role="bold">MKGetObjectName()</emphasis>:</para>

<programlisting>
char *aName = MKGetObjectName(aPart);
</programlisting>

      </sect3>
      <sect3><title>Adding a <classname>MKPart</classname> to a
      <classname>MKScore</classname></title>

<para>To add a <classname>MKPart</classname> to a
<classname>MKScore</classname>, invoke one of these methods:</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">addToScore:</emphasis>, a
<classname>MKPart</classname> method</para>
	  </listitem>
<listitem><para> <emphasis role="bold">addPart:</emphasis>, a
<classname>MKScore</classname> method</para>
	  </listitem>
	</itemizedlist>
<para>A <classname>MKScore</classname> can contain any number of
<classname>MKPart</classname>s; a <classname>MKPart</classname> can
belong to only one <classname>MKScore</classname> at a time.  Both of
the <classname>MKPart</classname>-adding methods first remove the
<classname>MKPart</classname> from its present
<classname>MKScore</classname>, if any.</para>

<para>Just as you can modify a <classname>MKNote</classname> after it
has been added to a <classname>MKPart</classname>, you can continue to
modify a <classname>MKPart</classname> (by adding and removing
<classname>MKNote</classname>s, for example) after it has been added
to a <classname>MKScore</classname>.</para>
      </sect3>
      <sect3><title>Writing a <classname>MKScore</classname> to a File</title>

<para>You write a scorefile by sending one of the following messages
to a <classname>MKScore</classname> object:</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">writeScorefile:</emphasis>
takes a file name (<emphasis role="bold">char *</emphasis>)
argument.</para>
	  </listitem>
<listitem><para> <emphasis
role="bold">writeScorefileStream:</emphasis> takes a stream pointer
(NXStream *) argument.</para>
	  </listitem>
	</itemizedlist>
<para>The first of these opens and closes the file for you.  Every
time you send the <emphasis role="bold">writeScorefile:</emphasis>
message, the named file is overwritten.  By convention, scorefiles are
given a &ldquo;.score&rdquo; extension.</para>

<para><emphasis role="bold">writeScorefileStream:</emphasis> expects a
stream pointer that's already open for writing.  The method leaves the
stream open after it returns, allowing you to write additional,
application-specific information to the end of the file.  It's left to
your application to close the stream.</para>

<para>Rather than write an entire <classname>MKScore</classname> to a
file, you can specify a particular section by sending the <emphasis
role="bold">writeScorefile:firstTimeTag:lastTimeTag:timeShift:</emphasis>
message (a similar method, with an initial keyword of <emphasis
role="bold">writeScorefileStream:</emphasis>, is provided for writing
a section of a <classname>MKScore</classname> to a stream).  For
example:</para>

<programlisting>
[myScore writeScorefile: "Adagio.score"
           firstTimeTag: 3.5
            lastTimeTag: 10.2
              timeShift: 0.0]
</programlisting>

<para>Here, only those <classname>MKNote</classname>s with time tag
values between 3.5 and 10.2, inclusive, are written to the file.  As a
convenience, you can use the constant MK_ENDOFTIME as the <emphasis
role="bold">lastTimeTag:</emphasis> argument to write from some
position in the <classname>MKScore</classname> to its end:</para>

<programlisting>
[myScore writeScorefile: mySfile
           firstTimeTag: 3.5
            lastTimeTag: MK_ENDOFTIME
              timeShift: 0.0]
</programlisting>

<para>To write from the beginning of the
<classname>MKScore</classname>, you specify 0.0 as the <emphasis
role="bold">firstTimeTag:</emphasis> argument.  The<emphasis
role="bold"> timeShift:</emphasis> takes a value that specifies the
number of beats by which the <classname>MKNote</classname>s are
time-shifted as they're represented in the file.  Only the file
representation is affected by this value; in other words, the
<classname>MKNote</classname>s themselves aren't time-shifted (their
time tags aren't affected).</para>

<para>For each of the scorefile-writing methods, there is an analogous
method that writes a Standard MIDI file.</para>
      </sect3>
    </sect2>
    <sect2 id="RetrievingMKScoresMKPartsAndMKNotes">
      <title>Retrieving <classname>MKScore</classname>s,
      <classname>MKPart</classname>s, and <classname>MKNotes</classname></title>
      <sect3>
	<title>Reading a File</title>

<para>You can fill a <classname>MKScore</classname> with information
simply by reading a scorefile (or MIDI file; for brevity, scorefiles
are used exclusively in the examples).  The methods provided for
reading a scorefile are analogous to those for writing:</para>
      <itemizedlist>

<listitem><para> <emphasis role="bold">readScorefile:</emphasis> takes
a file name argument.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">readScorefileStream:</emphasis>
takes an NXStream pointer argument.</para>
	  </listitem>
	</itemizedlist>
<para>When you read a scorefile into a <classname>MKScore</classname>
object, <classname>MKPart</classname> and
<classname>MKNote</classname> objects are automatically created to
accommodate the information in the file.</para>

<para>You can specify a section of the scorefile and a time shift on
that section by adding the <emphasis
role="bold">firstTimeTag:lastTimeTag:timeShift:</emphasis> keywords.
For example:</para>

<programlisting>
[myScore readScorefile: "Adagio.score"
          firstTimeTag: 6.5
           lastTimeTag: MK_ENDOFTIME
             timeShift: -6.5]
</programlisting>

<para>Notes represented in the file that have time tag values greater
than or equal to 6.5 are read into the <classname>MKScore</classname>.
Within the <classname>MKScore</classname>, each
<classname>MKNote</classname>'s time tag is shifted ahead in time
(toward the chronological beginning of a
<classname>MKPart</classname>) by 6.5 beats.</para>
      </sect3>
      <sect3><title>Finding a <classname>MKPart</classname> in a
      <classname>MKScore</classname></title>

<para>The complete set of a <classname>MKScore</classname>'s
<classname>MKPart</classname>s, regardless of how the
<classname>MKScore</classname> was created, can be retrieved through
<classname>MKScore</classname>'s <emphasis role="bold">part</emphasis>
method.  The method returns the <classname>MKPart</classname>s in a
<classname>NSArray</classname>.  The <classname>MKScore</classname> method <emphasis
role="bold">partCount</emphasis> gives the number of
<classname>MKPart</classname>s that it contains.</para>
      </sect3>
      <sect3><title>Retrieving a <classname>MKNote</classname> from a
      <classname>MKPart</classname></title>

<para>There are a number of ways to retrieve a
<classname>MKNote</classname> from a <classname>MKPart</classname>.
One way is to access the <classname>MKNote</classname> by its time tag
value through one of the following <classname>MKPart</classname>
methods:</para>
      <itemizedlist>

<listitem><para> The <emphasis role="bold">atTime:</emphasis> method
returns the first <classname>MKNote</classname> object with the
specified time tag value.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">atOrAfterTime:</emphasis>
returns the first <classname>MKNote</classname> with a time tag
greater than or equal to the argument.</para>
	  </listitem>
	</itemizedlist>
<para>Both methods take a <emphasis role="bold">double</emphasis>
argument and they both return <emphasis role="bold">nil</emphasis> if
they can't find an appropriate <classname>MKNote</classname>.  The
following example illustrates the difference between the two
methods:</para>

<programlisting>
/* Create a MKPart, two MKNotes, and an id for return values. */
MKPart *aPart = [MKPart new],
MKNote *aNote = [MKNote newSetTimeTag:2.0];
MKNote *bNote = [MKNote newSetTimeTag:3.0];
MKNote *returnNote;

/* Add the MKNotes to the MKPart. */
[aPart addNote:bNote];
[aPart addNote:aNote];

/* Retrieve the MKNote at time 1.5.  (Returns nil; no such MKNote.) */
returnNote = [aPart atTime:1.5];

/* Retrieve the MKNote at or after 1.5.  (Returns aNote.)  */
returnNote = [aPart atOrAfterTime:1.5];
</programlisting>

<para>You can also retrieve a <classname>MKNote</classname> by its
ordinal position within its <classname>MKPart</classname> by sending
the message <emphasis role="bold">nth:</emphasis> to the
<classname>MKPart</classname> object.  It takes an integer argument
<emphasis>n</emphasis> and returns the <emphasis>n</emphasis>th
<classname>MKNote</classname>, zero-based, in the
<classname>MKPart</classname>.  Using the same
<classname>MKPart</classname> object from the previous example, the
message</para>

<programlisting>
[aPart nth:1]
</programlisting>

<para>returns <emphasis role="bold">bNote</emphasis>, the second
<classname>MKNote</classname> in the <classname>MKPart</classname>.
Recall that within a <classname>MKPart</classname>,
<classname>MKNote</classname>s are ordered by their time tag values;
the order of <classname>MKNote</classname>s with equivalent time tags
reflects the order in which they were added to the
<classname>MKPart</classname>.</para>

<para>The time tag and the ordinal methods of retrieving
<classname>MKNote</classname>s are combined in the methods <emphasis
role="bold">atTime:nth:</emphasis> and <emphasis
role="bold">atOrAfterTime:nth:</emphasis>.  The first of these methods
returns the <emphasis>n</emphasis>th <classname>MKNote</classname>
with the specified time tag; through this method you can retrieve a
particular <classname>MKNote</classname> in a chord.  The <emphasis
role="bold">atOrAfterTime:nth:</emphasis> method returns the
<emphasis>n</emphasis>th <classname>MKNote</classname> with a time tag
equal to or greater than the first argument.</para>

<para>The <emphasis role="bold">next:</emphasis> method also retrieves
<classname>MKNote</classname>s based on ordinal position: It returns
the <classname>MKNote</classname> that immediately follows the
<classname>MKNote</classname> given as the argument.  <emphasis
role="bold">next:</emphasis> can be used to access each
<classname>MKNote</classname> in a <classname>MKPart</classname> in
turn:</para>

<programlisting>
/* Initially set aNote to the first MKNote in the MKPart. */ 
MKNote *aNote = [aPart nth:0];

/* Access each MKNote in the MKPart and change it to MK_mute. */ 
while(aNote = [aPart next:aNote])
    [aNote setNoteType:MK_mute];
</programlisting>

<para><emphasis role="bold">next:</emphasis> returns <emphasis
role="bold">nil</emphasis> if there is no next
<classname>MKNote</classname>, or if the argument isn't a member of
the <classname>MKPart</classname>.  A more efficient way of accessing
each <classname>MKNote</classname> in a <classname>MKPart</classname>
is to create a <classname>NSArray</classname> of the <classname>MKNote</classname>s in a
<classname>MKPart</classname> and step down the <classname>NSArray</classname>.  The previous
example can be rewritten as follows:</para>

<programlisting>
/* Create a Sequence over the MKPart's MKNotes. */ 
id notes = [aPart notes];
int noteCount = [aPart noteCount];
int i;

/* Access each MKNote in the Sequence and change its note type. */
for (i = 0; i &lt; noteCount; i++)
    [[notes objectAtIndex:i] setNoteType:MK_mute];
</programlisting>

      </sect3>
      <sect3><title>Removing a <classname>MKNote</classname> from a
      <classname>MKPart</classname></title>

<para>The <classname>MKPart</classname> class defines two methods for
removing individual <classname>MKNote</classname>s from a
<classname>MKPart</classname> object:</para>
      <itemizedlist>

<listitem><para> <emphasis role="bold">removeNote:</emphasis> removes
the <classname>MKNote</classname> object specified in the
argument.</para>
	  </listitem>
<listitem><para> <emphasis role="bold">removeNotes:</emphasis> removes
all <classname>MKNote</classname>s common to the receiver and the <classname>NSArray</classname>
specified in the argument.</para>
	  </listitem>
	</itemizedlist>
<para>You can also remove a <classname>MKNote</classname> from its
<classname>MKPart</classname> by sending the <emphasis
role="bold">removeFromPart:</emphasis> message to the
<classname>MKNote</classname> object.  The
<classname>MKPart</classname> object from which the
<classname>MKNote</classname> was removed is returned.</para>
      </sect3>
      <sect3 id="AddingAndRemovingGroupsOfNotes"><title>Adding and Removing Groups of <classname>MKNote</classname>s</title>

<para>The <classname>MKPart</classname> class defines methods that
allow you to add and remove <classname>MKNote</classname>s as a
collection.  There are two methods for adding a collection of
<classname>MKNote</classname>s:</para>

      <itemizedlist>

<listitem><para><emphasis
role="bold">addNotes:timeShift:</emphasis></para>
	  </listitem>

<listitem><para><emphasis
role="bold">addNoteCopies:timeShift:</emphasis></para>
	  </listitem>
	</itemizedlist>

<para>The first argument is a <classname>NSArray</classname> of
<classname>MKNote</classname>s.  The second argument is an optional
value in beats (a <emphasis role="bold">double</emphasis>) that's used
to offset each <classname>MKNote</classname>'s time tag.  The
<emphasis role="bold">addNotes:timeShift:</emphasis> method removes
each <classname>MKNote</classname> in the collection from the
<classname>MKPart</classname> that it's currently a member of before
adding it to the receiver.  The <emphasis
role="bold">addNoteCopies:timeShift:</emphasis> method adds copies of
each <classname>MKNote</classname> in the
<classname>NSArray</classname>.</para>

<para>To remove a <classname>NSArray</classname> of
<classname>MKNote</classname>s, you can invoke the method <emphasis
role="bold">removeNotes:</emphasis>, which takes a
<classname>NSArray</classname> of <classname>MKNote</classname>s and
removes each one from the receiver.</para>

<para>Finally, you can remove all the <classname>MKNote</classname>s
from a <classname>MKPart</classname> through the <emphasis
role="bold">empty</emphasis> method.</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id=RepresentationOfMIDI>
<title>Representation of MIDI in the MusicKit</title>

<para>In the MusicKit, MIDI messages are represented as
<classname>MKNote</classname>s, where each
<classname>MKNote</classname> can represent one ore more MIDI
messages.  The MIDI message is represented by a combination of the
<classname>MKNote</classname>'s type, tag and parameters.</para>

<para>The MusicKit takes care of verifying the validity of the MIDI
stream and throws away invalid messages, such as duplicate noteOffs or
noteOffs for inactive Key/Channel pairs.  However, you can turn off
this feature by enabling "inclusive translation mode" with the
function <emphasis
role="bold">MKSetInclusiveMidiTranslation()</emphasis>.</para>

<para>This discussion assumes a familiarity with MIDI.  For further
details, consult the MIDI Specification.  For further information no
methods for reading a Standard MIDI File, see the
<classname>MKScore</classname> class description.  For further
information on processing or sending MIDI in real time, see the
<classname>MKMidi</classname> class description.<emphasis role="bold">
</emphasis></para>

    <sect2><title>Converting MusicKit <classname>MKNote</classname>s
    to MIDI</title>

<para>These rules deal with sending MIDI messages to a
<classname>MKMidi</classname> object, which represents the OUT
jack on your MIDI interface, as well as writing
<classname>MKScore</classname> objects as Standard MIDI files.</para>

      <sect3><title>MIDI Channel Voice Messages</title>

<para>MIDI Channel Voice messages are the most common type of message.
For all the Channel Voice messages, the MIDI channel is determined as
follows:</para>

<para>For writing a <classname>MKScore</classname> object to a
Standard MIDI File, each <classname>MKNote</classname> is checked for
the presence of an <emphasis role="bold">MK_midiChan</emphasis>
parameter.  If one is found, its value ([1-16]) is used.  Otherwise,
if the <classname>MKPart</classname> info
<classname>MKNote</classname> has an <emphasis
role="bold">MK_midiChan</emphasis> parameter, it is used as the
default.  Otherwise a default of channel 1 is used.</para>

<para>For writing a <classname>MKNote</classname> to a
<classname>MKMidi</classname> object, if the
<classname>MKNote</classname> is sent via the 0'th
<classname>MKNoteReceiver</classname> of the
<classname>MKMidi</classname> object, each
<classname>MKNote</classname> is checked for the presence of an
<emphasis role="bold">MK_midiChan</emphasis> parameter.  If one is
found, its value ([1-16]) is used.  Otherwise, the channel of the
<classname>MKNoteReceiver</classname> is used.  For example, all
<classname>MKNote</classname>s sent via the 2nd
<classname>MKNoteReceiver</classname> are assigned to MIDI channel 2.
</para>

	<itemizedlist>
	  <listitem>
<para> A <emphasis role="bold">noteOn</emphasis> message is
represented by a <classname>MKNote</classname> object with the
noteType MK_noteOn.  Additionally, an <emphasis
role="bold">MK_keyNum</emphasis> parameter provides the key number
([0-127]) and the <emphasis role="bold">MK_velocity</emphasis>
parameter provides the velocity ([0-127]).  If no <emphasis
role="bold">MK_keyNum</emphasis> is present, the <emphasis
role="bold">MK_freq</emphasis> parameter is checked and, if it is
present, converted to a MIDI key number using the currently installed
TuningSystem.  Finally,a noteTag <emphasis>must</emphasis> be provided
so that noteOff Notes and polyphonic aftertouch Notes can be properly
matched.</para>

<para>Alternatively, you can send a <classname>MKNote</classname> of
type MK_noteDur with a duration supplied, which is equivalent to a
noteOn/noteOff pair.  In this case, no noteTag is needed, though it
may still be supplied if desired to match against polyphonic key
pressure <classname>MKNote</classname>s and other noteOn
<classname>MKNote</classname>s in this phrase.</para>

<para>The following actions are taken by the MusicKit to make sure
MusicKit semantics are properly converted to MIDI semantics:</para>

	<orderedlist>
	  <listitem><para>If two successive noteOn
<classname>MKNote</classname>s have the same noteTag and the same
<emphasis role="bold">MK_keyNum</emphasis> value, a noteOff message is
generated on the same channel and with the same key number as those
for the noteOn Notes.</para>
	  </listitem>

	  <listitem><para>If two successive noteOn
<classname>MKNote</classname>s have the same noteTag but different
<emphasis role="bold">MK_keyNum</emphasis> values, the second MIDI
noteOn message is followed by a MIDI noteOff message with the key
number of the first noteOn <classname>MKNote</classname>.  This is to
accommodate MIDI Mono Mode.</para>
	  </listitem>
	</orderedlist>

<para>For example, the following code creates a noteOn note and sends
it to MIDI OUT.  This is a very simple case with no <classname>MKConductor</classname> to
manage timing.</para>

<programlisting>
#import &lt;MusicKit/MusicKit.h&gt;
#import &lt;MusicKit/keynums.h&gt;

MKMidi *aMidi = [[MKMidi alloc] init]; /* Create MKMidi object */
MKNote *aNote = [[MKNote alloc] init]; /* Create a MKNote */

[aMidi run];                           /* Start it up */
[aNote setNoteTag:MKNoteTag()];        /* Set tag */
[aNote setPar:MK_keyNum toInt:c4k];    /* Set key number */
[aNote setPar:MK_velocity toInt:64];   /* Set velocity */

[aNote setPar:MK_midiChan toInt:1];    /* MIDI channel */
[aNote setNoteType:MK_noteOn];         /* Set type */
[[aMidi noteReceiver] receiveNote:aNote]; /* Send it */

[aMidi close];
</programlisting>

	  </listitem>

<listitem><para> A <emphasis role="bold">noteOff</emphasis> message is
represented by a <classname>MKNote</classname> object with the note
type <emphasis role="bold">MK_noteOff</emphasis>. You should give the
<classname>MKNote</classname> a noteTag that is the same as you gave
the corresponding noteOn <classname>MKNote</classname>.  When you send
such a <classname>MKNote</classname> to the
<classname>MKMidi</classname> object or write it to a Standard MIDI
file, the key number is determined by the
<classname>MKNote</classname>'s noteTag, which is matched against the
<classname>MKNote</classname> previously sent with the same tag. If
there is no active noteTag then and inclusive translation mode has
been selected (using the function <emphasis
role="bold">MKSettInclusiveMidiTranslation()</emphasis>), the
<classname>MKNote</classname> is checked for the presence of an
<emphasis role="bold">MK_keyNum</emphasis> parameter ([0-127]).
Otherwise, or if none is found, the noteOff is omitted. Additionally,
an <emphasis role="bold">MK_releaseVelocity</emphasis> parameter
provides the noteOff velocity.  <classname>MKNote</classname> that if
the presence or absence of <emphasis role="bold">MK_releaseVelocity
</emphasis>determines whether the MIDI is sent as a true MIDI noteOff
message or as a zero-velocity MIDI noteOn message.</para>

<para>If you are generating a series of notes in a single phrase
(i.e. using MIDI Mono Mode), keep in mind that MusicKit semantics
require only a single noteOff <classname>MKNote</classname> to
conclude the phrase, rather than a noteOff
<classname>MKNote</classname> for every noteOn
<classname>MKNote</classname>.  For example, if you send a series of
<classname>MKNote</classname>s with the same noteTag that are part of
a mono phrase, you should simply send a series of noteOns and one
noteOff at the end. The MusicKit does the proper translation to MIDI
semantics automatically.</para>
	  </listitem>

<listitem><para>A <emphasis role="bold">polyphonic
aftertouch</emphasis> (aka "key pressure") message is represented by a
<classname>MKNote</classname> object of type MK_noteUpdate.  The key
number is determined by the <classname>MKNote</classname>'s noteTag,
which is matched against the <classname>MKNote</classname> previously
sent with the same tag. If there is no active noteTag then, if
inclusive translation mode has been selected (using the function
<emphasis role="bold">MKSettInclusiveMidiTranslation()</emphasis>),
the <classname>MKNote</classname> is checked for the presence of an
<emphasis role="bold">MK_keyNum</emphasis> parameter.  If none is
found, the polyphonic aftertouch message is omitted.  The parameter
<emphasis role="bold">MK_keyPressure</emphasis> provides the value of
the key pressure, which is between 0 and 127.</para>
	  </listitem>

<listitem><para>A <emphasis role="bold">controller change</emphasis>
message is represented by a <classname>MKNote</classname> object with
the parameter <emphasis role="bold">MK_controlChange</emphasis>,
which provides the value of the
controller to be changed ([0-121]), while the parameter <emphasis
role="bold">MK_controlVal</emphasis> is the value of the controller
([0-127]).  If you send such a <classname>MKNote</classname> to a
<classname>MKSynthInstrument</classname>, its noteType should be set
to MK_noteUpdate.</para>
	  </listitem>

<listitem><para>A <emphasis role="bold">program change</emphasis>
message is represented a <classname>MKNote</classname> object with the
parameter <emphasis role="bold">MK_programChange</emphasis>, which 
provides the value of the program change ([0-127]).</para>
	</listitem>

<listitem><para>A <emphasis role="bold">channel pressure</emphasis>
(aka "after touch") message is represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_afterTouch</emphasis>, which provides the value of the
afterTouch.  If you send such a <classname>MKNote</classname> to a
<classname>MKSynthInstrument</classname>, its noteType should be set
to MK_noteUpdate.  Macros for common controller names are found in
<filename class=headerfile>MusicKit/midi_spec.h</filename>. For
example, <constant>MIDI_MODWHEEL</constant> is defined as 1.</para>
	</listitem>

<listitem><para>A <emphasis role="bold">pitch bend</emphasis> message
is represented by a <classname>MKNote</classname> object with the
parameter <emphasis role="bold">MK_pitchBend</emphasis>, which
provides the value of the pitch bend.  As in MIDI, pitch bend is a
14-bit signed integer, centered around 0x2000.  That is, 0 is maximum
negative bend and 0x3fff is maximum positive bend.  If you send such a
<classname>MKNote</classname> to a
<classname>MKSynthInstrument</classname>, its noteType should be set
to <emphasis>MK_noteUpdate</emphasis>.</para>
	  </listitem>
	</itemizedlist>
<para>For example, the following code plays a note and then does a
gradual pitch bend.</para>

<programlisting>
#import &lt;MusicKit/MusicKit.h&gt;
#import &lt;MusicKit/keynums.h&gt;

int i;
MKMidi *aMidi = [[MKMidi alloc] init];   /* Create MKMidi object */
MKNote *aNote = [[MKNote alloc] init];   /* Create a Note */
MKNote *pbNote = [[MKNote alloc] init];  /* Another one */

#define SEND(note)[[aMidi noteReceiver] receiveNote:note]

[aMidi run];                             /* Start it up */

[aNote setNoteTag:MKNoteTag()];          /* Set tag */
[aNote setPar:MK_keyNum toInt:c4k];      /* Set key number */
[aNote setPar:MK_velocity toInt:64];     /* Set velocity */
[aNote setPar:MK_midiChan toInt:1];      /* MIDI channel */
[aNote setNoteType:MK_noteOn];           /* Set type */

SEND(aNote);

[pbNote setNoteType:MK_noteUpdate];
[pbNote setPar:MK_midiChan toInt:1];     /* MIDI channel */

for (i=0; i&lt;0x3fff; i++) {
    [pbNote setPar:MK_pitchBend toInt:i]; /* Bend */
    SEND(pbNote);
    usleep(10000);                       /* Wait 10 milliseconds */
}

[aNote setNoteType:MK_noteOff];          /* Now stop the note */
SEND(aNote);
[aMidi close];
</programlisting>

<para>Note that several messages may be specified in a single
<classname>MKNote</classname> object, where feasible.  For example, a
<emphasis role="bold">noteOn</emphasis> can be combined with an
<emphasis role="bold">after touch</emphasis> message.  An example
where this is not possible is to set two controllers in a single
<classname>MKNote</classname>&horbar;this is impossible because only one
<emphasis role="bold">MK_controlChange</emphasis> parameter may be
present in a <classname>MKNote</classname>.</para>
      </sect3>
      <sect3><title>MIDI Channel Mode Messages</title>

<para>MIDI Channel Mode messages are represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_basicChan</emphasis> set to the basic channel ([1-16])
and <emphasis role="bold">MK_chanMode</emphasis> set to one of the
following int values (defined in <filename
class=headerfile>MusicKit/params.h</filename>):</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">MK_resetControllers
</emphasis>
</para>
	  </listitem>
<listitem><para> <emphasis
role="bold">MK_localControlModeOn</emphasis></para>
	  </listitem>

<listitem><para> <emphasis
role="bold">MK_localControlModeOff</emphasis>
</para>
	  </listitem>
<listitem><para> <emphasis role="bold">MK_allNotesOff</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_omniModeOff</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_omniModeOn</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_monoMode</emphasis>
</para></listitem>

<listitem><para> <emphasis
role="bold">MK_polyMode</emphasis></para></listitem>
	</itemizedlist>
<para>In addition, for <emphasis role="bold">monoMode</emphasis>, the
parameter <emphasis role="bold">MK_monoChans</emphasis> specifies the
number of Mono channels ([0-127).</para>
      </sect3>
      <sect3><title>MIDI System Messages</title>

      <itemizedlist>

<listitem><para> A <emphasis role="bold">MIDI time code quarter frame
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_timeCodeQ</emphasis>, with
a value as defined in the MIDI Time Code Specification
([0-127)].</para>
	  </listitem>
<listitem><para> A <emphasis role="bold">song position pointer
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_songPosition,
</emphasis>which is a 14-bit integer ([0-0x3ff]).  See the MIDI
Specification for details.</para>
	  </listitem>
<listitem><para> A <emphasis role="bold">song select
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_songSelect</emphasis> with
the integer value of the song to be selected ([0-127]).</para>
	  </listitem>
<listitem><para> A <emphasis role="bold">tune request
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_tuneRequest</emphasis>.
The value of the parameter is irrelevant&horbar;only its presence is
significant.</para>

	  </listitem>
<listitem><para>MIDI <emphasis role="bold">System Real
Time</emphasis> messages are represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_sysRealTime</emphasis> set to one of the following int
values (defined in 
<filename class=headerfile>MusicKit/params.h</filename>):</para>
	  </listitem>

<listitem><para> <emphasis role="bold">MK_sysClock</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_sysStart</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_sysContinue</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_sysStop</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_sysActiveSensing</emphasis>
</para>
	  </listitem>
<listitem><para> <emphasis
role="bold">MK_sysReset</emphasis></para></listitem>

<listitem><para> MIDI <emphasis role="bold">System
Exclusive</emphasis> messages are represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_sysExclusive</emphasis> with a <emphasis>string
value</emphasis>. The string consists of hexadecimal system exclusive
bytes separated by any non-digit delimiter. The musickit uses the
comma as a delimiter (',').  For example, "f0, 8,13,f7".  The string
may, but need not, begin with f0 and end with f7.  If these are
missing, they are automatically added.  Note that you should
<emphasis>not</emphasis> include the conventional C hex prefix "0x".
This will be interpreted as a single byte 0!</para>

<para>Note also that if you want to give each sysex byte a different
delay, you need to put it in a separate <classname>MKNote</classname>
object as a separate system exclusive message.  The MusicKit does not
support system exclusive messages that span
<classname>MKNote</classname> objects.</para>

<para>For example, the following program sends the system exclusive
message f0, 8 13 f7:</para>

<programlisting>
#import &lt;MusicKit/MusicKit.h&gt;

main() {
    MKMidi *aMidi = [[Midi alloc] init];    /* Create MKMidi object */
    MKNote *aNote = [[MKNote alloc] init];  /* Create a MKNote */

    [aMidi run];                            /* Start it up */
    [aNote setPar:MK_sysExclusive toString:"f0,8,13,f7"];
    [[aMidi noteReceiver] receiveNote:aNote]; /* Send it */
    [aMidi close];

    exit(0);
}
</programlisting>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>
    <sect2><title>Converting MIDI to MusicKit Notes</title>

<para>These rules deal with receiving MIDI messages from a
<classname>MKMidi</classname> object that represents the MIDIN jack on
your interface, as well as reading Standard MIDI files into
<classname>MKScore</classname> objects.</para>

<para>Note that the <classname>MKNote</classname>s created by a
<classname>MKMidi</classname> object and sent during a performance
should not be stored or modified.  The rule here is "copy on modify or
store"&horbar;to store or modify a <classname>MKNote</classname> simply
send it the <emphasis role="bold">copy</emphasis> message to create a
new copy.</para>

      <sect3><title>MIDI Channel Voice Messages</title>

<para>MIDI Channel Voice messages are the most common type of message.
For all the Channel Voice messages, the MIDI channel is specified as
follows:</para>

<para>For reading a <classname>MKScore</classname> object from a
Standard MIDI File, the way the channel is interpreted depends on the
"level" of the MIDI file.  See the Standard MIDI File Specification
for more information on Standard MIDI Files.</para>

<para>For a level 0 file, each <classname>MKPart</classname>
corresponds to a MIDI channel.  Therefore, each
<classname>MKPart</classname> info is given a <emphasis
role="bold">MK_midiChan</emphasis> parameter that specifies its
channel ([1-16]).  The <classname>MKScore</classname> method <emphasis
role="bold">midiPart:</emphasis> takes a channel argument and returns
a <classname>MKPart</classname> with that channel specified in its
info <classname>MKNote</classname>.</para>

<para>For a level 1 or level 2 file, each
<classname>MKNote</classname> is given a <emphasis
role="bold">MK_midiChan</emphasis> parameter in the range [1-16].  In
addition, the <classname>MKPart</classname> info is given a <emphasis
role="bold">MK_midiChan</emphasis> parameter of the first
<classname>MKNote</classname> found in that
<classname>MKPart</classname>, since it is a common case that all
<classname>MKNote</classname>s in a track have the same
channel.</para>

<para>For receiving incoming <classname>MKNote</classname>s from a
<classname>MKMidi</classname> object, the way the channel is specified
depends on how the method <emphasis
role="bold">setMergeInput:</emphasis> was invoked.  If you send
<emphasis role="bold">[midiObj setMergeInput:YES]</emphasis>, then
each <classname>MKNote</classname> is sent out the zero'th
<classname>MKNoteSender</classname> with the MIDI channel specified in
a <emphasis role="bold">MK_midiChan</emphasis> parameter.  Keep in
mind that this applies only to MIDI Chanel Voice messages.  For all
other kinds of messages, the <classname>MKNote</classname>s are sent
out the 0'th <classname>MKNoteSender</classname>.  On the other hand,
if you send <emphasis role="bold">[midiObj
setMergeInput:NO]</emphasis>, each <classname>MKNote</classname> is
sent out the c'th <classname>MKNoteSender</classname>, where c is the
MIDI channel; in this case, no <emphasis
role="bold">MK_midiChan</emphasis> is supplied.</para>

      <itemizedlist>

<listitem><para>For each <emphasis role="bold">noteOn</emphasis>
message, a <classname>MKNote</classname> object is created and
forwarded to the appropriate <classname>MKNoteSender</classname>, as
explained above.  It is also given a noteType of MK_noteOn, <emphasis
role="bold">MK_keyNum</emphasis> parameter that provides the key
number ([0-127]) and a <emphasis role="bold">MK_velocity</emphasis>
parameter that provides the velocity ([0-127]).  Additionally, it is
given a noteTag ([0-MAXINT]) corresponding to its Key Number and
Channel.  However, you should not depend on the particular value of
the noteTag to derive the Key Number and Channel&horbar;use the
parameters instead.  The noteTag is essential in that it makes it
possible to match noteOff and polyphonic key pressure
<classname>MKNote</classname>s with the corresponding noteOn
<classname>MKNote</classname>s.</para>

<para>Currently multiple noteOns on the same Key Number and Channel
are interpreted as rearticulations, rather than as additional
voices.</para>
	  </listitem>

<listitem><para> For each <emphasis role="bold">noteOff</emphasis>
message for which an unmatched noteOn was previously received , a
<classname>MKNote</classname> object is created with type MK_noteOff.
It is given a noteTag that is the same as you gave the corresponding
noteOn <classname>MKNote</classname>.  If inclusive MIDI translation
mode is selected (using the function <emphasis
role="bold">MKSettInclusiveMidiTranslation()</emphasis>), then a
<emphasis role="bold">MK_keyNum</emphasis> parameter is additionally
included ([0-127]) and unmatched noteOffs are passed along to the
application, rather than being filtered out.</para>

<para>If multiple noteOff messages are received (for a particular
Channel/Note number) without intervening noteOn messages, only the
first noteOff message is converted into a
<classname>MKNote</classname> object.  The others are suppressed.
However, if inclusive MIDI translation mode is selected, the noteOff
is not surpressed and is passed on to the application.</para>

<para>If a noteOff message has a release velocity of 0, the <emphasis
role="bold">MK_releaseVelocity</emphasis> parameter in the
corresponding <classname>MKNote</classname> object is omitted.</para>
	  </listitem>

<listitem><para> For each <emphasis role="bold"> polyphonic aftertouch
</emphasis>(aka "key pressure") message for a channel/key number for
which a noteOn was received, a <classname>MKNote</classname> object is
created of type MK_noteUpdate, with a noteTag that matches the noteOn
received on the same channel/key number pair.  The key number is not
explicitly included, unless inclusive translation mode is enabled, in
which case a <emphasis role="bold">MK_keyNum</emphasis> parameter is
additionally included.  The key pressure is specified in the parameter
<emphasis role="bold">MK_keyPressure</emphasis> ([0-127]).</para>
	  </listitem>

<listitem><para> For each<emphasis role="bold"> controller change
</emphasis>message, a <classname>MKNote</classname> is created with
the parameter <emphasis role="bold">MK_controlChange</emphasis>,
which specifies the value of the
controller to be changed ([0-121]), and the parameter <emphasis
role="bold">MK_controlVal</emphasis>, which specifies the value of the
controller ([0-127]).  The noteType is set to MK_noteUpdate.</para>
	  </listitem>

<listitem><para> For each<emphasis role="bold"> program change
</emphasis>message, a <classname>MKNote</classname> is created with
the parameter <emphasis role="bold">MK_programChange</emphasis>, which
provides the value of the program change ([0-127]).  The noteType is
set to MK_noteUpdate.</para>
	  </listitem>

<listitem><para> For each<emphasis role="bold"> channel pressure
</emphasis>(aka "after touch") <emphasis role="bold">
</emphasis>message, a <classname>MKNote</classname> is created with
the parameter <emphasis role="bold">MK_afterTouch,
</emphasis>which provides the value
of the afterTouch ([0-127]).  The noteType is set to
MK_noteUpdate.</para>
	  </listitem>

<listitem><para> For each<emphasis role="bold"> pitch bend
</emphasis>message, a <classname>MKNote</classname> is created with
the parameter <emphasis role="bold">MK_pitchBend,
</emphasis>which provides the value
of the afterTouch ([0-0x3fff]).  The noteType is set to
MK_noteUpdate.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
      <sect3><title>MIDI Channel Mode Messages</title>

<para>Incoming Channel Mode messages are handled by the
<classname>MKMidi</classname> object by fashioning them into
<classname>MKNote</classname> objects and sending them to the 0'th
<classname>MKNoteSender</classname>.  Similarly, when a Standard MIDI
file containing Channel Mode messages is read, they are turned into
<classname>MKNote</classname>s and added to the
<classname>MKPart</classname> returned by sending the
<classname>MKScore</classname> the message <emphasis
role="bold">midiPart:</emphasis> with an argument of 0.</para>

<para>MIDI Channel Mode messages are represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_basicChan</emphasis> set to the basic channel ([1-16])
and <emphasis role="bold">MK_chanMode</emphasis> set to one of the
following int values (defined in 
<filename class=headerfile>MusicKit/params.h</filename>):</para>

      <itemizedlist>

<listitem><para> <emphasis role="bold">MK_resetControllers
</emphasis></para>
	  </listitem>
<listitem><para> <emphasis
role="bold">MK_localControlModeOn</emphasis></para>
	</listitem>

<listitem><para> <emphasis
role="bold">MK_localControlModeOff</emphasis>
</para>
	  </listitem>
<listitem><para> <emphasis role="bold">MK_allNotesOff</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_omniModeOff</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_omniModeOn</emphasis>
</para></listitem>

<listitem><para> <emphasis role="bold">MK_monoMode</emphasis>
</para></listitem>

<listitem><para> <emphasis
role="bold">MK_polyMode</emphasis></para></listitem>
	</itemizedlist>
<para>In addition, for <emphasis role="bold">monoMode</emphasis>, the
parameter <emphasis role="bold">MK_monoChans</emphasis> specifies the
number of Mono channels ([0-127).</para>
      </sect3>
      <sect3><title>MIDI System Common Messages</title>

<para>Incoming System messages are handled by the
<classname>MKMidi</classname> object by fashioning them into
<classname>MKNote</classname> objects and sending them to the 0'th
<classname>MKNoteSender</classname>.  Similarly, when a Standard MIDI
file containing System messages are read, they are turned into
<classname>MKNote</classname>s and added to the
<classname>MKPart</classname> returned by sending the
<classname>MKScore</classname> the message <emphasis
role="bold">midiPart:</emphasis> with an argument of 0.</para>

      <itemizedlist>

<listitem><para> A <emphasis role="bold">MIDI time code quarter frame
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_timeCodeQ</emphasis>, with
a value as defined in the MIDI Time Code Specification
([0-127)].</para>
	  </listitem>

<listitem><para> A <emphasis role="bold">song position pointer
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_songPosition,
</emphasis>which is a 14-bit integer ([0-0x3ff]).  See the MIDI
Specification for details.</para>
	  </listitem>

<listitem><para> A <emphasis role="bold">song select
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_songSelect</emphasis> with
the integer value of the song to be selected ([0-127]).</para>
	  </listitem>

<listitem><para> A <emphasis role="bold">tune request
</emphasis>message is represented by a <classname>MKNote</classname>
with the parameter <emphasis role="bold">MK_tuneRequest</emphasis>.
The value of the parameter is irrelevant&horbar;only its presence is
significant.</para>
	  </listitem>

	  <listitem>
	    <para> MIDI <emphasis role="bold">System Real
Time</emphasis> messages are represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_sysRealTime</emphasis> set to one of the following int
values (defined in <filename class=headerfile>MusicKit/params.h</filename>):</para>

	    <itemizedlist>
	      <listitem><para> <emphasis role="bold">MK_sysClock</emphasis>
</para></listitem>

	      <listitem><para> <emphasis role="bold">MK_sysStart</emphasis>
</para></listitem>

	      <listitem><para> <emphasis role="bold">MK_sysContinue</emphasis>
</para></listitem>
	    
	      <listitem><para> <emphasis role="bold">MK_sysStop</emphasis>
</para></listitem>

	      <listitem><para> <emphasis role="bold">MK_sysActiveSensing</emphasis>
</para></listitem>

	      <listitem><para> <emphasis role="bold">MK_sysReset</emphasis></para></listitem>

	    </itemizedlist>
	  </listitem>

	  <listitem>
	    <para>MIDI <emphasis role="bold">System
Exclusive</emphasis> messages are represented by a
<classname>MKNote</classname> object with the parameter <emphasis
role="bold">MK_sysExclusive</emphasis> with a <emphasis>string
value</emphasis>. The string consists of hexadecimal system exclusive
bytes separated by a comma.  For example, "f0, 8,13,f7".  The string
begins with f0 and ends with f7.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>
    <sect2<title>Reading and Writing Standard MIDI Files</title>

<para>In addition to the conversions described above, a few special
rules apply when converting to or from a Standard MIDI file.</para>

<para>Standard MIDI Files come in three varieties: level 0, level 1
and level 2. The MusicKit always writes level 1 files.  It reads all
three varieties.</para>

<para>When a level 0 file is read, the Channel Voice messages are
written into 16 <classname>MKPart</classname>s, one for each channel.
Channel Mode and System messages are combined in an additional
<classname>MKPart</classname>.  The midi channel of a particular
<classname>MKPart</classname> can be determined by examining the
<emphasis role="bold">MK_midiChan</emphasis> parameter of the
<classname>MKPart</classname> info <classname>MKNote</classname>.  The
special system <classname>MKPart</classname> has no <emphasis
role="bold">MK_midiChan</emphasis> parameter.</para>

<para>When a level 1 file is read, each track is written to a separate
<classname>MKPart</classname>.  The track number is set in the
<classname>MKPart</classname> info's <emphasis
role="bold">MK_track</emphasis> parameter.  SMTPTE offset is set in
the <emphasis role="bold">MK_smpteOffset</emphasis> parameter of the
<classname>MKScore</classname> info.</para>

<para>When a level 2 file is read, each track is written to a separate
<classname>MKPart</classname>.  The track number is set in the
<classname>MKPart</classname> info's <emphasis
role="bold">MK_sequence</emphasis> parameter.  SMTPTE offset is set in
the <emphasis role="bold">MK_smpteOffset</emphasis> parameter of the
<classname>MKPart</classname> info.</para>

<para>If an <emphasis role="bold">MK_smpteOffset</emphasis> is
included, it is encoded as a <emphasis>string</emphasis> consisting of
five hex numbers, separated by spaces.  Similarly, when writing a
Standard MIDI file, the MusicKit expects to see such a string as the
value of the <emphasis role="bold">MK_smpteOffset</emphasis>
parameter.  See Standard MIDI file spec for details.
</para>

<para>When reading a file, tempo is encoded in the <emphasis
role="bold">MK_tempo</emphasis> parameter of the
<classname>MKScore</classname>'s info and also represented in
<classname>MKNote</classname>s with a <emphasis
role="bold">MK_tempo</emphasis> parameter.  The
<classname>MKScore</classname> class method <emphasis
role="bold">+setMidifilesEvaluateTempo:</emphasis> controls whether
tempo is merely passed along to the application (if the argument to
<emphasis role="bold">setMidifilesEvaluateTempo:</emphasis> is YES) or
whether it is factored into the <classname>MKNote</classname>s'
timestamps.  If you want the tempo track to be meaningful, you should
set 
<emphasis role="bold">setMidifilesEvaluateTempo:NO</emphasis>. Similarly, when
writing, the <classname>MKScore</classname> info's tempo is written,
as are any <classname>MKNote</classname>s with <emphasis
role="bold">MK_tempo</emphasis> parameters, and the value set with
<emphasis role="bold">+setMidifilesEvaluateTempo:</emphasis>
determines whether tempo is factored into the time stamps
written.</para>

<para>Copyright is represented in the <classname>MKScore</classname>'s
info as an <emphasis role="bold">MK_copyright</emphasis> parameter
with a string value.
</para>

<para>The info of each <classname>MKPart</classname> that corresponds
to a track is represented as an <emphasis
role="bold">MK_instrumentName</emphasis> parameter if a corresponding
meta-event appears in the file.  This parameter has a string
value.</para>

<para>Other MIDI file meta-events such as time signature, lyric,
etc. appear as corresponding <classname>MKNote</classname> parameters
in mute <classname>MKNote</classname>s in the appropriate
<classname>MKPart</classname>.  These include <emphasis
role="bold">MK_lyric</emphasis>, <emphasis
role="bold">MK_marker</emphasis>, <emphasis
role="bold">MK_cuePoint</emphasis>, <emphasis
role="bold">MK_text</emphasis>, <emphasis
role="bold">MK_timeSignature</emphasis> and <emphasis
role="bold">MK_keySignature</emphasis>. These all have string
values.</para>
    </sect2>
  </sect1>
</chapter>
