{\rtf0\ansi{\fonttbl\f0\fnil Times-Roman;\f1\ftech Symbol;\f2\fmodern Ohlfs;}
\paperw16220
\paperh12580
\margl120
\margr0
{\colortbl;\red0\green0\blue0;}
\f0\b0\i0\ulnone\ql\fs24\fi0\li0\gray0\fc0\cf0\up0\dn0 Copyright 
\f1 ã
\f0 1990 by NeXT Computer, Inc.  All Rights Reserved.\
Copyright 
\f1 ã
\f0 1995 by Stanford University.  All Rights Reserved.\
\

\pard\tx3120\tx3620\tx4120\fs16\li2620\fc0\cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 Allpass1UG\

\fs16 \

\pard\tx7140\b0\fs28\li2100\fc0\cf0 INHERITS FROM	UnitGenerator\

\fs16 \

\fs28 DECLARED IN	musickit/unitgenerators/unitgenerators.h\

\fs16 \
\
\

\fs28 CLASS DESCRIPTION\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 Allpass1UG is a one-pole, one-zero filter.  The value of the filter coefficient is set directly.  The filter's transfer function is given as\

\fs16 \

\fs28\fc1\cf1 		                     bb0 + 1/z\
		      H(z) =  ±±±±±±±±\
		                     1 + bb0/z\
\
where bb0 is the filter coefficient.   Thus, the pole is at -bb0 and the zero is at -1/bb0.  The difference equation used to implement the filter in the DSP is\
\
			y(n) = bb0 * x(n) + x(n-1) - bb0 * y(n-1); 
\pard\tx7140\fs16\li2100\fc0\cf0 \
\

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc1\cf1 where x(n) denotes the input signal at time n, and y(n) is the output signal.  This is the so-called ªdirect-form-1º digital filter structure.  It has the property that the filter can only overflow if the output overflows.  (In other words, 
\i internal
\i0  overflow is not possible.)  For stability, bb0 must lie between -1.0 and 1.0.\

\pard\tx7140\li2100\fc0\cf0 \
\
OPTIMIZATION\
\

\pard\tx3120\tx3620\tx4120\li2620\fc0\cf0 Allpass1UG is fastest if the input memory space is x in which case three inner-loop instructions are required.  Otherwise, four inner-loop instructions are used.\

\pard\tx7140\li2100\fc0\cf0 \
\
MEMORY SPACES\

\fs16 \

\pard\tx3120\tx3620\tx4120\b\fs28\li2620\fc0\cf0 Allpass1UG
\i ab\

\b0 a	
\i0 output\

\i b
\i0 	input \

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 \
INSTANCE METHODS\

\fs16 \

\b \

\fs28 setInput:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setInput:
\b0\i aPatchpoint\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the input patchpoint to 
\i aPatchpoint
\i0 .  Returns 
\b self
\b0 , or 
\b nil
\b0  if the argument isn't a patchpoint.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setOutput:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setOutput:
\b0\i aPatchpoint\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the output patchpoint to 
\i aPatchpoint
\i0 .  Returns 
\b self
\b0 , or 
\b nil
\b0  if the argument isn't a patchpoint.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setBB0:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setBB0:
\b0\i (double)bb0\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the filter coefficient to 
\i bb0
\i0 .  For stability, the coefficient should be within the bounds\
\
	
\f1 -
\f0 1.0 < 
\i bb0
\i0  < 1.0\

\fs16 \

\fs28 Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 clear\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b clear\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Clears filter memory, i.e., sets the value of the two state variables (used for x(n-1) and y(n-1)) to 0.0.  Returns 
\b self
\b0 .\

\pard\tx7140\b\fs16\li2100\fc0\cf0 \

\pard\tx3120\tx3620\tx4120\b0\li2620\fc0\cf0 \

\pard\tx7140\b\fs28\li2100\fc0\cf0 idleSelf\

\pard\f1\b0\li2620\fc0\cf0 - 
\f0\b idleSelf
\b0\i \

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never send this message.  It's invoked by sending the 
\b idle 
\b0 message to the object.  \
Sets the output patchpoint to 
\i sink
\i0 ,
\i  
\i0 thus ensuring that the object does not produce any output.  Note that you must send 
\b setOutput:
\b0  and 
\b run 
\b0 again to use the UnitGenerator after sending 
\b idle
\b0 .\

\fs16 \

\fs28 \

\fs16 \

}
