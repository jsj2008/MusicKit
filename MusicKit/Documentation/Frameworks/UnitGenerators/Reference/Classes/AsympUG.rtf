{\rtf0\ansi{\fonttbl\f2\fnil Times-Roman;\f3\ftech Symbol;\f1\fmodern Courier;}
\paperw16220
\paperh13540
\margl120
\margr0
{\colortbl;\red0\green0\blue0;}
\f2\b0\i0\ulnone\ql\fs24\fi0\li0\gray0\fc0\cf0\up0\dn0 Release 2.0  Copyright 
\f3 ã
\f2 1990 by NeXT Computer, Inc.  All Rights Reserved.\
Revised for Release 4.2  Copyright 
\f3 ã
\f2 1996 by CCRMA, Stanford University.  All Rights Reserved.\
\

\pard\tx3120\tx3620\tx4120\fs16\li2620\fc0\cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 AsympUG\

\fs16 \

\pard\tx7140\b0\fs28\li2100\fc0\cf0 INHERITS FROM	UnitGenerator\

\fs16 \

\fs28 DECLARED IN	musickit/unitgenerators/unitgenerators.h\

\fs16 \
\
\

\fs28 CLASS DESCRIPTION\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 AsympUG is an exponential (asymptotic) Envelope handler that plays a Music Kit Envelope on the DSP. It is very similar to AsympenvUG and has almost the same Objective C protocol. However, unlike AsympenvUG, which loads the entire Envelope into DSP memory, AsympUG feeds the Envelope to the DSP one segment at a time. This means AsympUG is more well-suited to very long Envelopes that would not fit in DSP memory. For example, an entire piece may be specified as one long Envelope. AsympUG also uses less DSP code than AsympenvUG. However, AsympUG is not well-suited to handling Envelopes in interactive real-time applications, such as playing a MIDI keyboard and hearing sound immediately. For such applications, it is better to use AsympenvUG. \
\
AsympUG objects are normally used to provide dynamic scaling of a musical attribute.  To this end, the output of an AsympUG is typically connected to the frequency or amplitude input of an OscgafiUG object or used as input to an InterpUG, Mul2UG, ScaleUG, etc. Although typically used to convey Envelopes, AsympUG may also be used as a simple exponential ramper, without an explicit Envelope object. Methods are provided that let you set the rate directly, or as a time limit (referred to as  ªT60º) that defines when the target will have been perceptually reached.  \

\fs16 \

\fs28 For each Envelope segment, AsympUG creates an exponential signal that approaches a limit (the ªtargetº) at a particular rate, where the rate expresses the precentage of the remaining journey that's taken with each step:\

\fs16 \

\fs28 	
\i output
\i0  = 
\i previousOutput
\i0  + (
\i rate
\i0  * (
\i target ±  previousOutput
\i0 ))\
	
\i previousOutput
\i0  = 
\i output\

\fs16 \

\i0\fs28 For example, if the rate is 0.1 and the target is 1.0, the samples generated by the AsympUG are\

\fs16 \

\fs28 	0.1, 0.19, 0.271, 0.343, 0.409, 0.4685, ...\

\fs16 \

\fs28 Exponential envelopes have the advantage of being "self-limiting". That is,  they seek their targets from any starting point. This allows for efficient implementation of long connected Envelope "phrases", one of the primary advantages of the Music Kit's Note representation. In addition, if, for some reason, the host processor gets a little bit behind, due to time-sharing, the envelope will not continue unbounded toward disaster. \
 \
Envelope data is mapped onto the exponential representation as follows:\
\
The Envelope's yArray[n] is the target, considered to be in the infinite future.The Envelope's xArray[n] is the time of the right-hand side of the segment (i.e. the time to interrupt the trajectory toward yArray[n]). The Envelope's smoothingArra[n] is the smoothing constant to get to yArray[n]. If smoothingArra[n] is 0, the point  is reached immediately. If smoothingArra[n] is 1.0, the point is reached,  within about -48dB at the time of the next update. If smoothingArra[n] is larger, the point is not reached within -48dB by the time of the next update. A value of smoothingArra[n] of infinity will cause the envelope to never change value. The first point, xArray[0], is assumed to be the right-hand side of the non-existant first segment. yArray[0] is the initial point (which may or may not be used, depending on the value of the instance variable useInitialvalue (see below)). smoothingArra[0] is ignored. 	\
The envelope has a "stick point". When the envelope handler reaches the stick point, it does not proceed to the next point until it receives the 
\b -finish
\b0  message. If there is no stick point, the 
\b -finish
\b0  message is ignored. If the envelope handler has not yet reached the stick point when the 
\b -finish
\b0  message is received, the envelope handler proceeds to the first point after the stick point and continues from there.  Keep in mind that while AsympUG uses the clockConductor (see Conductor Class Description) for timing of envelope breakpoint values, 
\b -finish
\b0  is sent based on the arrival of a 
\b noteOff
\b0  to the SynthPatch, which is (usually) managed by another Conductor.\
\
Music Kit Envelopes are usually associated with a set of parameters, such as attackTime, releaseTime, etc. The C function 
\b MKUpdateAsymp()
\b0  is provided to conveniently manage setting the AsympUG's attributes according to a given Envelope and a set of Note parameters.  By using 
\b MKUpdateAsymp()
\b0 , you need only set the AsympUG's output patchpoint; all other methods are invoked for you.  For more information, see the Class Description for the Envelope class.\
\
A few other points to keep in mind: \
\
´ You should not change the contents of a Music Kit Envelope object while an AsympUG is using it. \
´ The methods 
\b -setYScale:yOffset: 
\b0 and 
\b -setReleaseXScale: 
\b0 are provided by AsympUG, but not by AsympenvUG. \
´ TransitionTime, which is specified in the method -
\b resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:
\b0 , is supported by AsympUG, but not by AsympenvUG. 
\b \

\b0\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 INSTANCE VARIABLES\

\fs16 \

\pard\tx7140\tx10180\tx10680\i\fs28\fi-4540\li7140\fc0\cf0 Inherited from Object
\i0 	Class	isa;\

\fs16 \

\i\fs28 Inherited from  UnitGenerator
\i0 	id	synthPatch;\

\pard\tx10180\tx10680\fi-520\li7660\fc0\cf0 id	orchestra;\
BOOL	isAllocated;\
MKUGArgStruct	*args;\
MKSynthStatus	status;\
MKOrchMemStruct	relocation;\

\pard\tx7140\tx10180\tx10680\i\fi-4540\li7140\fc0\cf0 \
Declared in AsympUG
\i0 	id	anEnv;\

\pard\tx10180\tx10680\fi-520\li7660\fc0\cf0 double	
(*scalingFunc)();\
int	
envelopeStatus;\
int	arrivalStatus;\
double	timeScale;\
double	releaseTimeScale;\
double	yScale;\
double	yOffset;\
double	targetX;\
BOOL	useInitialValue;\
int	curPt;\

\pard\tx7140\tx10180\tx10680\fs16\fi-4540\li7140\fc0\cf0 \

\fs28\fc1\cf1 anEnv	The envelope, if any. \
\
scalingFunc	scalingFunc is a double-valued scaling function of two arguments:\
                                    	the current double value and the UnitGenerator instance id.\
	If funPtr is NULL, the identity mapping is used.\
\
envelopeStatus	Status of last envelope point accessed.\
	E.g. if we just set the target which is the stickpoint, envelopeStatus is\
                                     	MK_stickPoint. \
\
arrivalStatus	Status of actual progression on the DSP. E.g. if we have already interrupted the trajectory to the stickpoint, arrivalStatus is MK_stickPoint.\
\
timeScale	time scaling. The smoothing values are scaled as well. \
\
releaseTimeScale	For the post-stick-point segment. \
\
yScale	Y scale\
\
yOffset	Y offset\
\
targetX	X value of current target. \
\
useInitialValue	Controls how initial value of envelope is used. \
\
curPt	Current envelope point. \

\pard\tx7140\li2100\fc0\cf0 \
MEMORY SPACES\

\fs16 \

\pard\tx3120\tx3620\tx4120\b\fs28\li2620\fc0\cf0 AsympUG
\i a\

\b0 a	
\i0 output \

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 INSTANCE METHODS\

\fs16 \

\b \

\fs28 abortEnvelope\

\f3\b0\fi-1020\li3620 - 
\f2\b abortEnvelope\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Disassociates the AsympUG from its Envelope.  If the AsympUG is running, it stops reading breakpoints. It continues heading for its current target.  Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 envelope\

\f3\b0\fi-1020\li3620 - 
\f2\b envelope\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the Envelope that's associated with the AsympUG, or 
\b nil
\b0  if none.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 envelopeStatus\

\f3\b0\fi-1020\li3620 - 
\f2\b (MKEnvStatus)envelopeStatus\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the status of the most recently accessed Envelope breakpoint. Note that the DSP may not yet have reached that point. For example, if the stickpoint's target was just set, envelopeStatus is MK_stickPoint, even though the DSP is just beginning its exponential approach to the stickpoint. The value returned by 
\b envelopeStatus
\b0  is either MK_stickPoint, MK_lastPoint, or MK_noEnvError.  If the AsympUG's Envelope hasn't been set, MK_noMorePoints is returned.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 finishSelf\

\f3\b0\fi-1020\li3620 - 
\f2 (double)
\b finishSelf\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 You never invoke this method; it's invoked automatically when the AsympUG receives the 
\b finish
\b0  message.  If the object has yet to see or is waiting at its Envelope's stickpoint, this causes it to head for the first breakpoint after the stickpoint, and then on the end of the Envelope.  If the AsympUG's Envelope contains no stickpoint, this method has no effect. Returns the time in seconds until the Envelope is expected to finish, plus a small grace time given by 
\b MKGetPreemptDuration
()
\b0 . This time may be changed by calling  
\b MKSetPreemptDuration()
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 idleSelf\

\pard\f3\b0\li2620\fc0\cf0 - 
\f2\b idleSelf
\b0\i \

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never send this message.  It's invoked by sending the 
\b idle 
\b0 message to the object.  \
Sets the output patchpoint to 
\i sink
\i0 ,
\i  
\i0 thus ensuring that the object does not produce any output.  Note that you must send 
\b setOutput:
\b0  and 
\b run 
\b0 again to use the UnitGenerator after sending 
\b idle
\b0 .\

\fs16 \

\pard\tx7140\b\fs28\li2100\fc0\cf0 preemptEnvelope\

\f3\b0\fi-1020\li3620 - 
\f2\b preemptEnvelope\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Causes the AsympUG to head for the last breakpoint in its Envelope, using a rate that's computed from the value set through the 
\b MKSetPreemptDuration()
\b0  function (the default preempt duration is 0.006 seconds).  This method is invoked automatically by a SynthInstrument object when it preempts a SynthPatch that contains AsympUG objects.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b resetEnvelope:
\b0\i envelope\

\b\i0\fi0 yScale:
\b0 (double)
\i yScaleValue
\b\i0  \
yOffset:
\b0 (double)
\i yOffsetValue\

\b\i0 xScale:
\b0 (double)
\i xScaleValue
\b\i0  \
releaseXScale:
\b0 (double)
\i releaseXScaleValue\

\b\i0 funcPtr:
\b0 (double(*)())
\i yScaleFunction\

\b\i0 transitionTime:
\b0 (double)
\i transition\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 This method is similar to the 
\b setEnvelope:...
\b0  method but for this difference:  If the AsympUG is running, its current value isn't  reset to the new Envelope's first y value; instead, the new Envelope's first breakpoint is ignored and the Asymp's rate is reset such that the second breakpoint of the new Envelope is (virtually) reached within 
\i transition
\i0  seconds.  This affords are more graceful transition into the new Envelope.  If 
\i transition 
\i0 (as with any of the other double values) is MK_NODVAL, it is ignored.  As with the 
\b setEnvelope:...
\b0  method, you typically call the 
\b MKUpdateAsymp()
\b0  function rather than invoke this method.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setCurVal:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setCurVal:
\b0\i (double)value\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the current value of the AsympUG to 
\i value
\i0 .  The new value overrides the previous  sample as shown in the computation in the class description above.  If the object is already  processing an envelope, that envelope is not interrupted. Returns 
\b self
\b0 . \

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 runSelf\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b runSelf
\b0\i \

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never send this message.  It's invoked by sending the 
\b run 
\b0 message to the object.  Starts the Envelope, if any, on its way. Returns 
\b self
\b0 . \

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setConstant:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setConstant:
\b0 (double)
\i val\

\pard\tx3120\tx3620\tx4120\i0\li2620\fc0\cf0 \
Aborts any running Envelope and sets the AsympUG to produce 
\i val 
\i0 as a constant value.  Equivalent to invoking 
\b abortEnvelope
\b0 , followed by 
\b setTarget:
\b0\i val
\i0 , followed by 
\b setCurVal:
\b0\i val
\i0 .\

\pard\tx7140\b\li2100\fc0\cf0 \
setEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setEnvelope:
\b0\i envelope\

\b\i0\fi0 yScale:
\b0 (double)
\i yScaleValue
\b\i0  \
yOffset:
\b0 (double)
\i yOffsetValue\

\b\i0 xScale:
\b0 (double)
\i xScaleValue
\b\i0  \
releaseXScale:
\b0 (double)
\i releaseXScaleValue\

\b\i0 funcPtr:
\b0 (double(*)())
\i yScaleFunction\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Associates the AsympUG with the given Envelope and arguments.  When the AsympUG is run, it automatically schedules the breakpoints from its Envelope to be fed to itself through message requests with the clockConductor.  If this method is invoked while the AsympUG is running, the object's current value is immediately set to the (scaled and offset) y value of the first breakpoint in the new Envelope.   When continuity is desired with the previous invocation, use the 
\b resetEnvelope:...
\b0  method instead.\

\fs16 \

\fs28 The 
\i yScaleValue
\i0  and 
\i yOffsetValue
\i0  arguments scale and offset the AsympUG target values as each breakpoint is reached;  
\i xScaleValue
\i0  and 
\i releaseXScaleValue
\i0  modify the rate before and after the Envelope's stickpoint is reached, respectively.  \

\fs16 \

\fs28 The 
\i yScaleFunction
\i0  argument is a pointer to an optional function that performs additional, possibly dynamic, target scaling.  The fuction takes two arguments, a 
\b double
\b0  that gives the AsympUG's current value, and the object's 
\b id
\b0 .  The function is called once for each breakpoint.  \

\fs16 \

\fs28 Typically, you call the 
\b MKUpdateAsymp()
\b0  function rather than invoking this method.  The function provides a slightly easier interface to AsympUG management in the context of a SynthPatch.  \

\fs16 \

\fs28  If 
\i envelope
\i0  isn't an Envelope, 
\b nil
\b0  is returned.  In addition, if 
\i envelope
\i0  is 
\b nil
\b0 , the current Envelope, if any, is aborted.  Otherwise returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setOutput:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setOutput:
\b0\i aPatchpoint\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the output patchpoint to 
\i aPatchpoint
\i0 .  Returns 
\b self
\b0 , or 
\b nil
\b0  if the argument isn't a patchpoint.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setRate:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setRate:
\b0\i (double)rate\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the rate at which the AsympUG approaches its target, where 
\i rate
\i0  is the percentage of the remaining journey that's stepped off at each sample.  The value of 
\i rate
\i0 , which should be between 0.0 and 0.125.  (It should be between 0.0 and 1.0, but for historical reasons the outer limit stands at 0.125.  In any case, a rate of 0.125 means that the target is virtually reached in less than two ticks, which is quite fast).  More precisely, this method sets the rate of the exponential. (1-e^T/tau), where T is sampling period and tau is the time constant.If the AsympUG is already processing an Envelope, the new rate is simply inserted, overriding the current value, and the Envelope proceeds otherwise unaffected.  Returns 
\b self
\b0 .\

\fs16 \

\fs28 See also: 
\b ± setT60:\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 setReleaseXScale:\

\f3\b0\fi-1020\li3620 - 
\f2\b setReleaseXScale:
\b0 (double)
\i releaseXScaleValue\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Resets the value by which the release time of the AsympUG's Envelope is scaled.   This only has an affect on subsequent breakpointsÐyou can't, for example, extend the life of an AsympUG by increasing its release scale after the object has read (and is heading for) its last breakpoint.  Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setTargetVal:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setTargetVal:
\b0\i (double)target\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the target to 
\i target
\i0 , which should be between 0.0 and 1.0.  The new target is simply inserted, overriding the current target.  If the object is already  processing an envelope, that envelope is not interrupted. Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setT60:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setT60:
\b0\i (double)seconds\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Computes the AsynpUG's rate such that the target is perceptually reached (to within -60dB of the target) in 
\i seconds
\i0  seconds.  Returns 
\b self
\b0 .\

\fs16 \

\fs28 See also: 
\b ± setRate:\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 setT48:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setT48:
\b0\i (double)seconds\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Computes the AsynpUG's rate such that the target is perceptually reached (to within -48dB of the target) in 
\i seconds
\i0  seconds.  Same as 
\f1\fs24 [self setRate:5.52/(seconds*srate)]
\fs28 .
\f2  Returns 
\b self
\b0 .\

\fs16 \

\fs28 See also: 
\b ± setRate:\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 setYScale:yOffset:\

\f3\b0\fi-1020\li3620 - 
\f2\b setYScale:
\b0 (double)
\i yScaleValue
\b\i0  yOffset:
\b0 (double)
\i yOffsetValue\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Resets the values by which the AsympUG scales and offsets its Envelope's y values.  If the object is running, its current value is appropriately modified.  Returns 
\b nil
\b0  if the AsympUG has no Envelope, otherwise returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\fs28\li2100\fc0\cf0 useInitialValue:\

\f3\b0\fi-1020\li3620 - 
\f2\b useInitialValue:
\b0 (BOOL)
\i yesOrNo\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Controls how the Envelope is handled when it is "retriggered" (i.e. 
\b run
\b0  is invoked before the preceeding Envelope has finished.) If 
\i yesOrNo
\i0 , the first value of the Envelope is set as the AsympUG's first output. Otherwise, the AsympUG continues from whatever its current value happens to be to the second point of the Envelope. This method is rarely needed, since the same functionality is provided by 
\b resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:
\b0 . It is included as an optimization, when it is known that all parameters are the same.\

\fs16 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

}
