{\rtf0\ansi{\fonttbl\f2\fnil Times-Roman;\f3\ftech Symbol;\f1\fmodern Courier;}
\paperw16220
\paperh12580
\margl120
\margr0
\f2\b0\i0\ulnone\ql\fs24\fi0\li0\gray0\fc0\cf0\up0\dn0 Release 4.2  Copyright 
\f3 ã
\f2 1996 by CCRMA, Stanford University.  All Rights Reserved.\
\

\pard\tx3120\tx3620\tx4120\fs16\li2620\fc0\cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 AsympenvUG\

\fs16 \

\pard\tx7140\b0\fs28\li2100\fc0\cf0 INHERITS FROM	UnitGenerator\

\fs16 \

\fs28 DECLARED IN	musickit/unitgenerators/unitgenerators.h\

\fs16 \
\
\

\fs28 CLASS DESCRIPTION\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 AsympenvUG is an Envelope handler that plays a Music Kit Envelope on the DSP. It is very similar to AsympUG and has almost the same Objective C protocol. However, unlike AsympUG, which feeds the Envelope to the DSP one segment at a time, AsympenvUG loads the entire Envelope (actually, tables derived from the Envelope data) into DSP memory. This means AsympenvUG is more well-suited to critical interactive real-time applications, such as playing a MIDI keyboard and hearing sound immediately. It also means that there is a limit to the length of the envelopes it can handle, since there is a limited amount of DSP memory. In practice, envelopes are not usually very long, so this restriction is usually not a problem. In short, it is usually best to use AsympenvUG if critical interactive real-time is a concern, but AsympUG is better for situations with very long Envelopes or where real-time response is not an issue.\
\
AsympenvUG objects are normally used to provide dynamic scaling of a musical attribute.  To this end, the output of an AsympenvUG is typically connected to the frequency or amplitude input of an OscgafiUG object or used as input to an InterpUG, Mul2UG, ScaleUG, etc. Although typically used to convey Envelopes, AsympUG may also be used as a simple exponential ramper, without an explicit Envelope object. Methods are provided that let you set the rate directly, or as a time limit (referred to as  ªT60º) that defines when the target will have been perceptually reached.  \

\fs16 \

\fs28 For each Envelope segment, AsympenvUG creates an exponential signal that approaches a limit (the ªtargetº) at a particular rate, where the rate expresses the precentage of the remaining journey that's taken with each step:\

\fs16 \

\fs28 	
\i output
\i0  = 
\i previousOutput
\i0  + (
\i rate
\i0  * (
\i target ±  previousOutput
\i0 ))\
	
\i previousOutput
\i0  = 
\i output\

\fs16 \

\i0\fs28 For example, if the rate is 0.1 and the target is 1.0, the samples generated by the AsympUG are\

\fs16 \

\fs28 	0.1, 0.19, 0.271, 0.343, 0.409, 0.4685, ...\

\fs16 \

\fs28 Exponential envelopes have the advantage of being "self-limiting". That is,  they seek their targets from any starting point. This allows for efficient implementation of long connected Envelope "phrases", one of the primary advantages of the Music Kit's Note representation. In addition, if, for some reason, the host processor gets a little bit behind, due to time-sharing, the envelope will not continue unbounded toward disaster. \
 \
Envelope data is mapped onto the exponential representation as follows:\
\
The Envelope's yArray[n] is the target, considered to be in the infinite future.The Envelope's xArray[n] is the time of the right-hand side of the segment (i.e. the time to interrupt the trajectory toward yArray[n]). The Envelope's smoothingArra[n] is the smoothing constant to get to yArray[n]. If smoothingArra[n] is 0, the point  is reached immediately. If smoothingArra[n] is 1.0, the point is reached,  within about -48dB at the time of the next update. If smoothingArra[n] is larger, the point is not reached within -48dB by the time of the next update. A value of smoothingArra[n] of infinity will cause the envelope to never change value. The first point, xArray[0], is assumed to be the right-hand side of the non-existant first segment. yArray[0] is the initial point (which may or may not be used, depending on the value of the instance variable useInitialvalue (see below)). smoothingArra[0] is ignored. 	\
The envelope has a "stick point". When the envelope handler reaches the stick point, it does not proceed to the next point until it receives the 
\b -finish
\b0  message. If there is no stick point, the 
\b -finish
\b0  message is ignored. If the envelope handler has not yet reached the stick point when the 
\b -finish
\b0  message is received, the envelope handler proceeds to the first point after the stick point and continues from there.  \
\
Music Kit Envelopes are usually associated with a set of parameters, such as attackTime, releaseTime, etc. The C function 
\b MKUpdateAsymp()
\b0  is provided to conveniently manage setting the AsympUG's attributes according to a given Envelope and a set of Note parameters.  By using 
\b MKUpdateAsymp()
\b0 , you need only set the AsympenvUG's output patchpoint; all other methods are invoked for you.  For more information, see the Class Description for the Envelope class.\
\
As with AsympUG, you should not change the contents of a Music Kit Envelope object while an AsympenvUG is using it. Furthermore, Envelope data is cached on the DSP and referenced using the Envelope object id for speed and efficiency. This has the advantage of allowing several AsympenvUGs to share Envelope data and avoids wasting DSP memory. However, this also implies that if you change the data in an Envelope object, these changes may not take effect, because the Music Kit continues to use the old representation. Therefore, if you do change an Envelope's data, you should send the message 
\b +envelopeHasChanged:
\b0 , passing the Envelope object as the argument. Also, you should not free any Envelope objects that have been used in a Music Kit performance until the Orchestra has been closed. Otherwise, a re-used id may cause the AsympenvUG to use an incorrect cached Envelope.\

\b \

\b0 There are a few other differences between AsympUG and AsympenvUG:\
\
´ The methods 
\b -setYScale:yOffset: 
\b0 and 
\b -setReleaseXScale: 
\b0 have no effect. They are included only for compatability with 
\b MKUpdateAsymp()
\b0 . This implies that it is not possible to change the scale and offset of an Envelope that is in progress.\
\
´ TransitionTime, which is specified in the method -
\b resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:
\b0 , is currently ignored. It is included only for compatability with 
\b MKUpdateAsymp()
\b0 .
\b \

\b0\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 MEMORY SPACES\

\fs16 \

\pard\tx3120\tx3620\tx4120\b\fs28\li2620\fc0\cf0 AsympenvUG
\i a\

\b0 a	
\i0 output \

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 INSTANCE METHODS\

\fs16 \

\b \

\fs28 abortEnvelope\

\f3\b0\fi-1020\li3620 - 
\f2\b abortEnvelope\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Disassociates the AsympenvUG from its Envelope.  The Envelope sticks on its current value.  Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 envelope\

\f3\b0\fi-1020\li3620 - 
\f2\b envelope\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the Envelope that's associated with the AsympenvUG, or 
\b nil
\b0  if none.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 finishSelf\

\f3\b0\fi-1020\li3620 - 
\f2 (double)
\b finishSelf\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 You never invoke this method; it's invoked automatically when the AsympenvUG receives the 
\b finish
\b0  message.  If the object has yet to see or is waiting at its Envelope's stickpoint, this causes it to head for the first breakpoint after the stickpoint, and then on the end of the Envelope.  If the AsympenvUG's Envelope contains no stickpoint, this method has no effect. Returns the time in seconds until the Envelope is expected to finish, plus a small grace time given by 
\b MKGetPreemptDuration()
\b0 . This time may be changed by calling  
\b MKSetPreemptDuration()
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 idleSelf\

\pard\f3\b0\li2620\fc0\cf0 - 
\f2\b idleSelf
\b0\i \

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never send this message.  It's invoked by sending the 
\b idle 
\b0 message to the object.  \
Sets the output patchpoint to 
\i sink
\i0 ,
\i  
\i0 thus ensuring that the object does not produce any output.  Note that you must send 
\b setOutput:
\b0  and 
\b run 
\b0 again to use the UnitGenerator after sending 
\b idle
\b0 .\

\fs16 \

\pard\tx7140\b\fs28\li2100\fc0\cf0 preemptEnvelope\

\f3\b0\fi-1020\li3620 - 
\f2\b preemptEnvelope\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Causes the AsympenvUG to head for the last breakpoint in its Envelope, using a rate that's computed from the value set through the 
\b MKSetPreemptDuration()
\b0  function (the default preempt duration is 0.006 seconds).  This method is invoked automatically by a SynthInstrument object when it preempts a SynthPatch that contains AsympenvUG objects.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b resetEnvelope:
\b0\i envelope\

\b\i0\fi0 yScale:
\b0 (double)
\i yScaleValue
\b\i0  \
yOffset:
\b0 (double)
\i yOffsetValue\

\b\i0 xScale:
\b0 (double)
\i xScaleValue
\b\i0  \
releaseXScale:
\b0 (double)
\i releaseXScaleValue\

\b\i0 funcPtr:
\b0 (double(*)())
\i yScaleFunction\

\b\i0 transitionTime:
\b0 (double)
\i transition\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 This method is similar to the 
\b setEnvelope:...
\b0  method but for this difference:  If the AsympenvUG is running, its current value isn't reset to the new Envelope's first y value; instead, the new Envelope's first breakpoint is ignored and the Asymp's rate is reset such that it proceeds toward the second breakpoint. This affords are more graceful transition into the new Envelope.  
\i transition 
\i0 is currently ignored. As with the 
\b setEnvelope:...
\b0  method, you typically call the 
\b MKUpdateAsymp()
\b0  function rather than invoke this method.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setCurVal:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setCurVal:
\b0\i (double)value\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the current value of the AsympenvUG to 
\i value
\i0 .  The new value overrides the previous sample as shown in the computation in the class description above.  If the object is already  processing an envelope, that envelope is not interrupted. Returns 
\b self
\b0 . \

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 runSelf\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b runSelf
\b0\i \

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never send this message.  It's invoked by sending the 
\b run 
\b0 message to the object.  Starts the Envelope, if any, on its way. Returns 
\b self
\b0 . \

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setConstant:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setConstant:
\b0 (double)
\i val\

\pard\tx3120\tx3620\tx4120\i0\li2620\fc0\cf0 \
Aborts any running Envelope and sets the AsympenvUG to produce 
\i val 
\i0 as a constant value.  Equivalent to invoking 
\b abortEnvelope
\b0 , followed by 
\b setTarget:
\b0\i val
\i0 , followed by 
\b setCurVal:
\b0\i val
\i0 .\

\pard\tx7140\b\li2100\fc0\cf0 \
setEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setEnvelope:
\b0\i envelope\

\b\i0\fi0 yScale:
\b0 (double)
\i yScaleValue
\b\i0  \
yOffset:
\b0 (double)
\i yOffsetValue\

\b\i0 xScale:
\b0 (double)
\i xScaleValue
\b\i0  \
releaseXScale:
\b0 (double)
\i releaseXScaleValue\

\b\i0 funcPtr:
\b0 (double(*)())
\i yScaleFunction\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Associates the AsympenvUG with the given Envelope and arguments.  When the AsympenvUG is run, it automatically schedules the breakpoints from its Envelope to be fed to itself through message requests with the clockConductor.  If this method is invoked while the AsympenvUG is running, the object's current value is immediately set to the (scaled and offset) y value of the first breakpoint in the new Envelope.   When continuity is desired with the previous invocation, use the 
\b resetEnvelope:...
\b0  method instead.\

\fs16 \

\fs28 The 
\i yScaleValue
\i0  and 
\i yOffsetValue
\i0  arguments scale and offset the AsympenvUG target values as each breakpoint is reached;  
\i xScaleValue
\i0  and 
\i releaseXScaleValue
\i0  modify the rate before and after the Envelope's stickpoint is reached, respectively.  \

\fs16 \

\fs28 The 
\i yScaleFunction
\i0  argument is a pointer to an optional function that performs additional, possibly dynamic, target scaling.  The fuction takes two arguments, a 
\b double
\b0  that gives the AsympenvUG's current value, and the object's 
\b id
\b0 .  The function is called once for each breakpoint.  \

\fs16 \

\fs28 Typically, you call the 
\b MKUpdateAsymp()
\b0  function rather than invoking this method.  The function provides a slightly easier interface to AsympenvUG management in the context of a SynthPatch.  \

\fs16 \

\fs28  If 
\i envelope
\i0  isn't an Envelope, 
\b nil
\b0  is returned.  In addition, if 
\i envelope
\i0  is 
\b nil
\b0 , the current Envelope, if any, is aborted.  Otherwise returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setOutput:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setOutput:
\b0\i aPatchpoint\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the output patchpoint to 
\i aPatchpoint
\i0 .  Returns 
\b self
\b0 , or 
\b nil
\b0  if the argument isn't a patchpoint.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setRate:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setRate:
\b0\i (double)rate\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the rate at which the AsympenvUG approaches its target, where 
\i rate
\i0  is the percentage of the remaining journey that's stepped off at each sample.  The value of 
\i rate
\i0 , which should be between 0.0 and 0.125.  (It should be between 0.0 and 1.0, but for historical reasons the outer limit stands at 0.125.  In any case, a rate of 0.125 means that the target is virtually reached in less than two ticks, which is quite fast).  More precisely, this method sets the rate of the exponential. (1-e^T/tau), where T is sampling period and tau is the time constant.If the AsympenvUG is already processing an Envelope, the new rate is simply inserted, overriding the current value, and the Envelope proceeds otherwise unaffected.  Returns 
\b self
\b0 .\

\fs16 \

\fs28 See also: 
\b ± setT60:\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 setReleaseXScale:\

\f3\b0\fi-1020\li3620 - 
\f2\b setReleaseXScale:
\b0 (double)
\i releaseXScaleValue\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Has no effect. Implemented for compatability with 
\b AsympUG
\b0 .  Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setTargetVal:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setTargetVal:
\b0\i (double)target\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the target to 
\i target
\i0 , which should be between 0.0 and 1.0.  The new target is simply inserted, overriding the current target.  If the object is already  processing an envelope, that envelope is not interrupted. Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setT60:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setT60:
\b0\i (double)seconds\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Computes the AsynpUG's rate such that the target is perceptually reached (to within -60dB of the target) in 
\i seconds
\i0  seconds.  Returns 
\b self
\b0 .\

\fs16 \

\fs28 See also: 
\b ± setRate:\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 setT48:\

\pard\f3\b0\fi-1020\li3620\fc0\cf0 - 
\f2\b setT48:
\b0\i (double)seconds\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Computes the AsynpUG's rate such that the target is perceptually reached (to within -48dB of the target) in 
\i seconds
\i0  seconds.  Same as 
\f1\fs24 [self setRate:5.52/(seconds*srate)]
\fs28 .
\f2  Returns 
\b self
\b0 .\

\fs16 \

\fs28 See also: 
\b ± setRate:\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 setYScale:yOffset:\

\f3\b0\fi-1020\li3620 - 
\f2\b setYScale:
\b0 (double)
\i yScaleValue
\b\i0  yOffset:
\b0 (double)
\i yOffsetValue\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Has no effect. Implemented for compatability with 
\b AsympUG
\b0 .  Returns 
\b self
\b0 .\

\fs16 \

\pard\tx7140\b\fs28\li2100\fc0\cf0 useInitialValue:\

\f3\b0\fi-1020\li3620 - 
\f2\b useInitialValue:
\b0 (BOOL)
\i yesOrNo\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Controls how the Envelope is handled when it is "retriggered" (i.e. 
\b run
\b0  is invoked before the preceeding Envelope has finished.) If 
\i yesOrNo
\i0 , the first value of the Envelope is set as the AsympenvUG's first output. Otherwise, the AsympenvUG continues from whatever its current value happens to be to the second point of the Envelope. This method is rarely needed, since the same functionality is provided by 
\b resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:
\b0 . It is included as an optimization, when it is known that all parameters are the same.\

\fs16 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

}
