{\rtf0\ansi{\fonttbl\f0\fnil Times-Roman;\f1\ftech Symbol;\f2\fmodern Courier;}
\paperw16220
\paperh13540
\margl120
\margr0
{\colortbl;\red0\green0\blue0;}
\f0\b0\i0\ulnone\ql\fs24\fi0\li0\gray0\fc0\cf0\up0\dn0 Release 2.0  Copyright 
\f1 ã
\f0 1990 by NeXT Computer, Inc.  All Rights Reserved.\
Release 4.2  Updates Copyright 
\f1 ã
\f0 1996 by Stanford University.  All Rights Reserved.\
\

\pard\tx3120\tx3620\tx4120\fs16\li2620\fc0\cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 Envelope\

\fs16 \

\pard\tx7140\b0\fs28\li2100\fc0\cf0 INHERITS FROM	Object\

\fs16 \

\fs28 DECLARED IN	musickit.h\

\fs16 \
\
\

\fs28 CLASS DESCRIPTION\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 The Envelope class provides basic support for creating line segment functions.  An Envelope consists of a series of 
\i breakpoints
\i0  each consisting of three values:  
\i x
\i0 , 
\i y
\i0 , and 
\i smoothing
\i0 .  The 
\i x
\i0  and 
\i y
\i0  values locate a value 
\i y
\i0  at a particular time 
\i x
\i0 . There is also a 
\i smoothing
\i0  value associated with each breakpoint that is used primarily in 
\b AsympUG
\b0 , a UnitGenerator that creates asymptotic envelope functions on the DSP.  
\i Smoothing 
\i0 defines the shape of the curve between breakpoints.\
\
There are two ways to use an Envelope: as a continuous function during DSP synthesis or to return a discrete value 
\i y
\i0  for a given 
\i x
\i0 .  \
\
To fill an Envelope object with data, you invoke the method\

\fs16 \

\b\fs28 	setPointCount:\
	xArray:\
	orSamplingPeriod:\
	yArray:\
	smoothingArray:\
	orDefaultSmoothing:\

\b0\fs16 \

\fs28 The argument to 
\b setPointCount:
\b0  specifies the number of breakpoints in the Envelope; the arguments to 
\b xArray:
\b0 , 
\b yArray:
\b0 , and 
\b smoothingArray:
\b0  are pointers to arrays of 
\i x
\i0 , 
\i y
\i0 , and 
\i smoothing
\i0  values for the Envelope's breakpoints.  The range of musically useful 
\i y
\i0  values depends on the parameter that the Envelope will affect. For example, amplitude normally is between 0.0 and 1.0, while frequency is expressed in Hz and assumes values over the range of human  hearing.  The breakpoints in an Envelope must succeed each other in time; thus, the values in the 
\i x
\i0  array must get successively larger.  By default, the 
\i x
\i0  values are taken as seconds, although this interpretation can be modified through the use of auxilliary parameters, as explained below.  \

\fs16 \

\fs28 While you must always supply an array of 
\i y
\i0  values, the same isn't true for 
\i x
\i0  and 
\i smoothing
\i0 .  Rather than provide an 
\i x
\i0  array, you can specify, as the argument to 
\b orSamplingPeriod:
\b0 , a 
\i sampling period
\i0  that's used as an 
\i x
\i0  increment:  The 
\i x 
\i0 value of the first breakpoint is 0.0, successive 
\i x
\i0  values are integer multiples of the sampling period value.  Similarly, you can supply a constant 
\i smoothing
\i0  value, as the argument to 
\b orDefaultSmoothing:
\b0 , rather than provide a 
\i smoothing
\i0  array.  In the presence of both an 
\i x
\i0  array and a sampling period, or both a 
\i smoothing
\i0  array and a default 
\i smoothing
\i0 , the array takes precedence.\

\fs16 \

\fs28 The shorthand method 
\b setPointCount:xArray:yArray: 
\b0 can also be used to fill an Envelope with data.\

\fs16 \

\fs28 Envelopes are described as having three parts:  attack, sustain, and release.  You can set the sustain portion of an Envelope by designating one of its breakpoints as the 
\i stickpoint
\i0  through the 
\b setStickPoint:
\b0  method.  Everything up to the stickpoint is the Envelope's attack; everything after the stickpoint is its release.  When the stickpoint is reached during DSP synthesis, its y value is sustained until a 
\b noteOff
\b0  arrives to signal the release (keep in mind that a 
\b noteDur
\b0  is split into a 
\b noteOn
\b0 /
\b noteOff
\b0  pair by 
SynthInstrument
\b  
\b0 objects).\

\fs16 \

\fs28 An Envelope object is set as the value of a Note's parameter through Note's 
\b setPar:toEnvelope:
\b0  method.  Parameters that accept Envelope objects usually have associated with them several other parameters that interpret the Envelope by scaling and offsetting the Envelope's 
\i x
\i0  and 
\i y
\i0  values.   For example, the 
\b MK_ampEnv
\b0  parameter takes an Envelope as its value; 
\b  MK_amp0 
\b0 and
\b  MK_amp1
\b0  are constant-valued parameters that scale and offset the y values in 
\b MK_ampEnv
\b0  according to the formula\

\fs16 \

\fs28 	(
\i scale
\i0 * y) + 
\i offset\

\fs16 \

\i0\fs28 where 
\i scale
\i0  is calculated as 
\b MK_amp1
\b0  ± 
\b MK_amp0
\b0  and offset is simply the value of 
\b MK_amp0
\b0 .  In other words, 
\b MK_amp0
\b0  defines the interpreted value when 
\i y
\i0  is 0.0 and 
\b MK_amp1
\b0  is the interpreted value when 
\i y
\i0  is 1.0.  \
While an Envelopes's x values are normally taken as an absolute time in seconds, SynthPatches usually provide additional parameters that let you reset the attack and release durations.  For example, the 
\b MK_ampAtt
\b0  parameter  resets the duration of the attack portion of a Note's amplitude Envelope; similarly, 
\b MK_ampRel
\b0  resets the release duration. \
\
When used in DSP synthesis, Envelope objects are applied by a UnitGenerator such as 
\b AsympUG
\b0 .  
AsympUG creates asymptotic curves between breakpoints.  The shape of a  segment going into a particular breakpoint is determined by that breakpoint's 
\i smoothing
\i0  value (the 
\i smoothing
\i0  value of the first breakpoint is ignored).  
\i Smoothing
\i0  values should be between 0.0 and 1.0 where 0.0 means no 
\i smoothing
\i0  (a stairstep function), and 1.0 takes the entire duration between points to arrive at (near) the 
\i y
\i0  value.  More precisely, a 
\i smoothing
\i0  of 1.0 signifies that the 
AsympUG
\b  
\b0 will reach within -48dB of the 
\i y 
\i0 value.   A smoothing in excess of 1.0 causes the\
AsympUG trajectory to fall short of the next point's 
\i y
\i0  value.  See the AsympUG class description for the formula used to compute the asymptotic function.\

\fs16 \

\fs28 Although Envelope objects are most commonly used in  DSP synthesis, they can also be used to return a discrete value of 
\i y
\i0  for a given 
\i x
\i0 , as provided in the method 
\b lookupYForX:
\b0 .  Discrete-value lookup is useful for controlling the way a constant-valued parameter evolves over a 
\i series
\i0  of Notes.  If the 
\i x
\i0  value doesn't correspond exactly to a breakpoint in the Envelope, the method does a linear interpolation between the immediately surrounding breakpoints.  \
\
Envelopes are automatically created by the Music Kit in a number of circumstances, such as when reading a Scorefile.  The function 
\b MKSetEnvelopeClass() 
\b0 allows you to specify that your own subclass of Envelope be used when Envelopes are automatically created.   \
\
See also:  Note, AsympUG\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 INSTANCE VARIABLES\

\fs16 \

\pard\tx7140\tx10180\tx10680\i\fs28\fi-4540\li7140\fc0\cf0 Inherited from Object
\i0 	Class	isa;\

\fs16 \

\i\fs28 Declared in Envelope
\i0 	double	defaultSmoothing;\

\pard\tx10180\tx10680\fi-520\li7660\fc0\cf0 double	samplingPeriod;\
double	*xArray;\
double	*yArray;\
double	*smoothingArray;\
int	stickPoint;\
int	pointCount;\

\pard\tx7140\tx10180\tx10680\fs16\fi-4540\li7140\fc0\cf0 \

\fs28 defaultSmoothing 	Smoothing for all breakpoints (used in the absence of the smoothing array).\

\fs16 \

\fs28 samplingPeriod 	Constant x-increment (used in the absence of the x array).\

\fs16 \

\fs28 xArray 	Array of x (time) values, if any.\

\fs16 \

\fs28 yArray 	Arrays of y (data) values\

\fs16 \

\fs28 smoothingArray 	Array of smoothing values, if any.\

\fs16 \

\fs28 stickPoint 	The object's stickpoint.\

\fs16 \

\fs28 pointCount 	Number of breakpoints in the object.\

\pard\tx7140\fs16\li2100\fc0\cf0 \
\
\

\fs28 METHOD TYPES\

\fs16 \

\pard\tx7140\tx10180\tx10680\fs28\fi-4540\li7140\fc0\cf0 Creating and freeing	
\f1 - 
\f0 copy\

\pard\tx10180\tx10680\f1\fi-520\li7660\fc0\cf0 - 
\f0 free\

\f1 - 
\f0 init\

\pard\tx7140\tx10180\tx10680\fs16\fi-5040\li7660\fc0\cf0 \

\fs28 Modifying the object	
\f1 - 
\f0 setPointCount:xArray:orSamplingPeriod: \

\fi0 yArray:smoothingArray:\
orDefaultSmoothing: \

\pard\tx10180\tx10680\f1\fi-520\li7660\fc0\cf0 - 
\f0 setPointCount:xArray:yArray: \

\f1 - 
\f0 setStickPoint:\

\pard\tx7140\tx10180\tx10680\fs16\fi-4540\li7140\fc0\cf0 \

\fs28 Querying the object	
\f1 - 
\f0 attackDur\

\pard\tx10180\tx10680\f1\fi-520\li7660\fc0\cf0 - 
\f0 defaultSmoothing\

\f1 - 
\f0 getNth:x:y:smoothing: \

\f1 - 
\f0 lookupYForX: \

\f1 - 
\f0 lookupYForXAsymptotic: \

\f1 - 
\f0 pointCount\

\f1 - 
\f0 releaseDur\

\f1 - 
\f0 samplingPeriod\

\f1 - 
\f0 smoothingArray\

\f1 - 
\f0 stickPoint\

\f1 - 
\f0 xArray\

\f1 - 
\f0 yArray\

\pard\tx7140\tx10180\tx10680\fs16\fi-4540\li7140\fc0\cf0 \

\fs28 Writing the object	
\f1 - 
\f0 writeScorefileStream:\

\fs16 \

\fs28 Archiving the object	
\f1 - 
\f0 write:\

\pard\tx10180\tx10680\f1\fi-520\li7660\fc0\cf0 - 
\f0 read:\

\pard\tx7140\fs16\li2100\fc0\cf0 \
\
\

\fs28 INSTANCE METHODS\

\fs16 \

\b \

\fs28 attackDur\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b attackDur\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the duration of the attack portion of the object.  This is the difference between the 
\i x
\i0  value of the first breakpoint and the 
\i x
\i0  value of the stickpoint.  If the object doesn't have a stickpoint (or if the stickpoint is out of bounds), the duration of the entire Envelope is returned.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 copy\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b copy\

\fs16\fc1\cf1 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc1\cf1 Copies Envelope and its arrays.\

\pard\b\fs16\fi-1020\li3620\fc0\cf0 \

\pard\tx7140\li2100\fc0\cf0 \

\fs28 defaultSmoothing\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b defaultSmoothing\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the object's default smoothing value, or MK_NODVAL if there's a smoothing array.  (Use 
\b MKIsNoDVal
()
\b0  to check for MK_NODVAL.)\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 free\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b free\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Frees the object and its contents and removes its name, if any, from the Music Kit name table.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 getNth:x:y:smoothing:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (MKEnvStatus)
\b getNth:
\b0 (int)
\i n
\i0  \

\b\fi0 x:
\b0 (double *)
\i xPtr
\i0  \

\b y:
\b0 (double *)
\i yPtr
\i0  \

\b smoothing:
\b0 (double *)
\i smoothingPtr\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Returns, by reference, the 
\i x
\i0 , 
\i y
\i0 , and smoothing values for the 
\i n
\i0 'th breakpoint in the object counting from breakpoint 0.  The method's return value is a constant that describes the position of the 
\i n
\i0 'th breakpoint:\

\fs16 \

\pard\tx7140\tx9160\tx11180\b\fs28\li3120\fc0\cf0 Position	Constant \

\pard\tx7140\tx7140\tx9160\tx9160\tx11180\tx11180\b0\li3120\fc0\cf0 last point in the object	MK_lastPoint \
stickpoint	MK_stickPoint \
point out of bounds	MK_noMorePoints \
any other point	MK_noEnvError\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 If the object's y array is 
\b NULL, 
\b0 or its 
\i x
\i0  array is NULL and its sampling period is 0.0,  
\b MK_noMorePoints
\b0  is returned.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 init\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b init\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Initializes the object by setting its default smoothing to 1.0, its sampling period to 1.0, and its stickpoint to MAXINT.  You invoke this method when a creating a new Envelope.  A subclass implementation should send 
\b [super init]
\b0  before performing its own initialization.  \

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 lookupYForX:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b lookupYForX:
\b0 (double)
\i xVal\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Returns the y value that corresponds to 
\i xVal
\i0 .  If 
\i xVal
\i0  doesn't fall exactly on one of the object's breakpoints, the return value is computed as a linear interpolation between the y values of the nearest breakpoints on either side of 
\i xVal
\i0 .  If 
\i xVal
\i0  is out of bounds, this returns the first or last y value, depending on which boundary was exceeded.  If the object's y array is NULL, this returns MK_NODVAL.  (Use 
\b MKIsNoDVal()
\b0  to check for MK_NODVAL.)\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 lookupYForXAsymptotic:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b lookupYForXAsymptotic:
\b0 (double)
\i xVal\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Same as 
\b lookupYForX
\b0 , but assumes an asymptotic envelope, such as is produced by the AsympUG UnitGenerator.  \

\fs16 \

\pard\tx7140\b\fs28\li2100\fc0\cf0 pointCount\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (int)
\b pointCount\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the number of breakpoints in the object.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 read:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b read:
\b0 (NXTypedStream *)
\i stream\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never invoke this method directly; to read an archived Envelope, call the 
\b NXReadObject()
\b0  C function.  Note that 
\b init
\b0  isn't sent to an unarchived Envelope.  Reads data and sets object name (using 
\b MKNameObject
()
\b0 ), if any.\
\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 releaseDur\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b releaseDur\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the duration of the release portion of the object.  This is the difference between the 
\i x
\i0  value of the stickpoint and the 
\i x
\i0  value of the final breakpoint.  Returns 0.0 if the object doesn't have a stickpoint, or if the stickpoint is out of bounds.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 samplingPeriod\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b samplingPeriod\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the sampling period, or MK_NODVAL if there's an 
\i x
\i0  array.  (Use 
\b MKIsNoDVal() 
\b0 to check for MK_NODVAL.)\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setPointCount:xArray:orSamplingPeriod:yArray:smoothingArray:\

\pard\b0\fi-1020\li3620\fc0\cf0 orDefaultSmoothing:\

\fs16 \

\f1\fs28 - 
\f0\b setPointCount:
\b0 (int)
\i n
\i0  \

\b\fi0 xArray:
\b0 (double *)
\i xPtr
\i0  \

\b orSamplingPeriod:
\b0 (double)
\i period
\i0  \

\b yArray:
\b0 (double *)
\i yPtr
\i0  \

\b smoothingArray:
\b0 (double *)
\i smoothingPtr
\i0  
\b \
orDefaultSmoothing:
\b0 (double)
\i smoothing\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Fills the object with data by copying the values from 
\i xPtr
\i0 , 
\i yPtr
\i0 , and 
\i smoothingPtr
\i0 . If 
\i xPtr
\i0  is NULL, the object's sampling period is set to 
\i period
\i0  (otherwise 
\i period
\i0  is ignored).  Similarly, 
\i smoothing
\i0  is used as the object's default smoothing in the absence of 
\i smoothingPtr
\i0 .  If 
\i yPtr
\i0  is NULL, the object's y array is unchanged.  Returns the object.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setPointCount:xArray:yArray:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setPointCount:
\b0 (int)
\i n
\i0  \

\b\fi0 xArray:
\b0 (double *)
\i xPtr
\i0  \

\b yArray:
\b0 (double *)
\i yPtr\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 This is a cover for the more complete 
\b setPointCount:xArray:orSamplingPeriod:
\b0 ... method.  The object's smoothing specification is unchanged (keep in mind that smoothing is initialized to a constant 1.0).  If 
\i xPtr
\i0  or 
\i yPtr
\i0  is NULL, the object's 
\i x 
\i0 or 
\i y
\i0  array is unchanged, respectively.  In either of these cases, it is the sender's responsibility to insure that the new value of 
\i n
\i0  is the same as the 
\i pointCount
\i0  of the old array.  Returns the object.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setStickPoint:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setStickPoint:
\b0 (int)
\i index\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the object's stickpoint to the 
\i index
\i0 'th breakpoint, counting from 0.  Returns the object, or 
\b nil
\b0  if 
\i index
\i0  is out of bounds.  Setting the stickpoint to MAXINT removes it.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 smoothingArray\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double *)
\b smoothingArray\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns a pointer to the object's smoothing array, or NULL if none.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 stickPoint\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (int)
\b stickPoint\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the stickpoint, or MAXINT if none.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 writeScorefileStream:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b writeScorefileStream:
\b0 (NXStream *)
\i aStream\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Writes the object to the stream 
\i aStream
\i0  in scorefile format.  The stream must already be open.  The object's breakpoints are written, in order, as 
\b (
\b0 x
\b ,
\b0  y
\b ,
\b0  smoothing
\b )
\b0  with the stickpoint followed by a vertical bar.  For example, a simple three-breakpoint Envelope describing an arch might look like this (the second breakpoint is the stickpoint):\

\fs16 \

\pard\f2\fs24\li3120\fc0\cf0 (0.0, 0.0, 0.0) (0.3, 1.0, 0.05) | (0.5, 0.0, 0.2)\

\pard\tx3120\tx3620\tx4120\f0\fs16\li2620\fc0\cf0 \

\fs28 Returns 
\b nil
\b0  if the object's y array is NULL.  Otherwise returns the object.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 xArray\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double *)
\b xArray\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns a pointer to the object's 
\i x
\i0  array, or NULL if none.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 yArray\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double *)yArray\

\fs16 \

\fs28 Returns a pointer to the objectobjectobject's 
\i y
\i0  array, or NULL if none.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 write:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b write:
\b0 (NXTypedStream *)
\i stream\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 You never invoke this method directly; to archive an Envelope, call the 
\b NXWriteObject()
\b0  C function.  Writes data and object name (using 
\b MKGetObjectName
()
\b0 ) if any.\
\

\fs16 \

\fs28 \

\fs16 \

}
