{\rtf0\ansi{\fonttbl\f0\fnil Times-Roman;\f1\ftech Symbol;\f4\fswiss Helvetica;\f2\fmodern Courier;}
\paperw16220
\paperh13540
\margl120
\margr0
{\colortbl;\red0\green0\blue0;}
\f0\b0\i0\ulnone\ql\fs24\fi0\li0\gray0\fc0\cf0\up0\dn0 Release 2.0  Copyright 
\f1 ã
\f0 1990 by NeXT Computer, Inc.  All Rights Reserved.\
Release 4.1 Updates Copyright 
\f1 ã
\f0 1994 by CCRMA, Stanford University.\
\

\pard\tx3120\tx3620\tx4120\fs16\li2620\fc0\cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\pard\b\li1100\fc0\cf0 \
\
\
\

\fs36 UnitGenerator
\f4  \

\fs16 \

\pard\tx7140\f0\b0\fs28\li2100\fc0\cf0 INHERITS FROM	Object\

\fs16 \

\fs28 DECLARED IN	musickit.h\

\fs16 \
\
\

\fs28 CLASS DESCRIPTION\

\fs16 \

\pard\tx3120\tx3620\tx4120\fs28\li2620\fc0\cf0 UnitGenerators are the building blocks of DSP music synthesis.  Each UnitGenerator subclass represents a modular DSP program (a 
\i unit generator
\i0 ) that provides a particular synthesis operation, such as waveform generation, filtering, and mixing.  Sound is synthesized by dowloading unit generators to the DSP, interconnecting them, and making them run.  \

\fs16 \

\fs28 To download a copy of a particular unit generator to the DSP, you send the 
\b allocUnitGenerator:
\b0  message to an open Orchestra object, passing the class of the UnitGenerator that represents the unit generator.  For example, to download a copy of the unoise unit generator (which generates white noise), you allocate an instance of the UnoiseUG class: \

\fs16 \

\pard\f2\fs24\li3120\fc0\cf0 /* Create an Orchestra and a variable for the UnitGenerator. */\
id anOrch = [Orchestra new];\
id aNoise;\
/* Open the Orchestra; check for failure. */\
if (![anOrch open])\
. . .\
\
/* The UnitGenerator object is created at the same time that the\
 * unit generator program is download to the DSP. \
 */\
aNoise = [anOrch allocateUnitGenerator:[UnoiseUGx class]];\

\pard\tx3120\tx3620\tx4120\f0\fs16\li2620\fc0\cf0 \

\fs28 Notice that the receiver of the 
\b class
\b0  message in the final line of the example is UnoiseUGx. 
\i  
\i0 The ªxº is explained later in this class description
\i .    \

\fs16 \

\i0\fs28 To connect two UnitGenerators together, you allocate a 
\i patchpoint
\i0  through which they can communicate.  A patchpoint is a type of SynthData object that's designed to be used for just this purpose, to communicate data from the output of one UnitGenerator to the input of another.  For example, to connect our UnoiseUGx object to a sound-output UnitGenerator, such as Out1aUGx, a patchpoint must be allocated and then passed as the argument in an invocation of UnoiseUGx's 
\b setOutput:
\b0  method and Out1aUGx's 
\b setInput:
\b0  method.  But in order to do this, you have to understand a little bit about DSP memory spaces:\

\fs16 \

\fs28 The DSP's memory is divided into three sections, P, X, and Y:  P memory holds program data; X and Y contain data.  Unit generator programs are always downloaded to P memory; the memory represented by a SynthData object is allocated in either X or Y, as the argument to Orchestra's 
\b allocSynthData:
\b0  method is MK_xData or MK_yData.  In general, there's no difference between the two data memory spaces (the one difference is mentioned below); dividing data memory into two partitions allows the DSP to be used more efficiently (although it presents some complications to the programmer, which you're living through right now).  Most of the methods defined in the UnitGenerator class are subclass responsiblities or are provided to help define the functionality of a subclass.  The most important of these are 
\b runSelf
\b0 , 
\b idleSelf
\b0 , and 
\b finishSelf
\b0 .  These methods implement the behavior of the object in response to the 
\b run
\b0 , 
\b finish
\b0 , and 
\b idle
\b0  messages, respectively.\

\fs16 \

\fs28 In addition to implementing the subclass responsibility methods, you should also provide methods for poking values into the memory arguments of the DSP unit generator that the UnitGenerator represents.  For example, an oscillator UnitGenerator would provide a 
\b setFreq:
\b0  method to set the frequency of the unit generator that's running on the DSP.\

\fs16 \

\fs28 UnitGenerator subclasses are created from DSP macro code.  The utility 
\b dspwrap
\b0  turns a DSP macro into a UnitGenerator 
\i master
\i0  class, implementing some of the subclass responsibility methods.\

\fs16 \

\fs28 It also creates a number of classes that inherit from your UnitGenerator subclass; these are called 
\b leaf
\b0  classes.  A leaf class represents a specific memory space configuration on the DSP.  For example, OnePoleUG is a one-pole filter UnitGenerator master class provided by the Music Kit.  It has an input and an output argument that refer to either the x or the y memory spaces on the DSP.  To provide for all memory space configurations, 
\b dspwrap
\b0  creates the leaf classes OnePoleUGxx, OnePoleUGxy, OnePoleUGyx, and OnePoleUGyy.\

\fs16 \

\fs28 You can modify a master classÐfor example, the 
\b setFreq:
\b0  method mentioned above would be implemented in a master classÐbut you never create an instance of one.  UnitGenerator objects are always instances of leaf classes.\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 INSTANCE VARIABLES\

\fs16 \

\pard\tx7140\tx10180\tx10680\i\fs28\fi-4540\li7140\fc0\cf0 Inherited from Object
\i0 	Class	isa;\

\fs16 \

\i\fs28 Declared in UnitGenerator
\i0 	id	synthPatch;\

\pard\tx10180\tx10680\fi-520\li7660\fc0\cf0 id	orchestra;\
BOOL	isAllocated;\
MKUGArgStruct	*args;\
MKSynthStatus	status;\
MKOrchMemStruct	relocation;\

\pard\tx7140\tx10180\tx10680\fs16\fi-4540\li7140\fc0\cf0 \

\fs28 synthPatch 	The SynthPatch that owns this object, if any.\

\fs16 \

\fs28 orchestra 	The Orchestra on which the object is allocated.\

\fs16 \

\fs28 isAllocated 	YES if allocated\

\fs16 \

\fs28 args 	The object's DSP memory arguments\

\fs16 \

\fs28 status 	The object's status\

\fs16 \

\fs28 relocation 	The object's relocation information\

\pard\tx7140\fs16\li2100\fc0\cf0 \
\
\

\fs28 METHOD TYPES\

\fs16 \

\pard\tx7140\tx10180\tx10680\fs28\fi-4540\li7140\fc0\cf0 Modifying the object	
\f1 - 
\f0 dealloc\

\pard\tx10180\tx10680\fi-520\li7660\fc0\cf0 + enableErrorChecking: \

\f1 - 
\f0 finish\

\f1 - 
\f0 finishSelf\

\f1 - 
\f0 free\

\f1 - 
\f0 freeSelf\

\f1 - 
\f0 idle\

\f1 - 
\f0 idleSelf\

\f1 - 
\f0 moved\

\f1 - 
\f0 run\

\f1 - 
\f0 runSelf\

\f1 - 
\f0 setAddressArg:to: \

\f1 - 
\f0 setAddressArgToSink: \

\f1 - 
\f0 setAddressArgToZero: \

\f1 - 
\f0 setDatumArg:to: \

\f1 - 
\f0 setDatumArg:toLong:\

\f1 - 
\f0 init\

\pard\tx7140\tx10180\tx10680\fs16\fi-4540\li7140\fc0\cf0 \

\fs28 Querying the object	+ argCount\

\pard\tx10180\tx10680\f1\fi-520\li7660\fc0\cf0 - 
\f0 argCount\
+ argName: \
+ argSpace: \
+ classInfo\

\f1 - 
\f0 classInfo\

\f1 - 
\f0 instanceNumber\

\f1 - 
\f0 isAllocated\

\f1 - 
\f0 isFreeable\
+ masterUGPtr\

\f1 - 
\f0 orchestra\
+ orchestraClass\

\f1 - 
\f0 referenceCount\

\f1 - 
\f0 relocation\

\f1 - 
\f0 resources\

\f1 - 
\f0 runsAfter: \
+ shouldOptimize: \

\f1 - 
\f0 status\

\f1 - 
\f0 synthPatch\

\f1 - 
\f0 writeSymbolsToStream:\

\pard\tx7140\fs16\li2100\fc0\cf0 \
\
\

\fs28 CLASS METHODS\

\fs16 \

\b \

\fs28 argCount\

\pard\b0\fi-1020\li3620\fc0\cf0 + (unsigned)
\b argCount\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the number of memory arguments in the receiver's DSP code.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 argName:\

\pard\b0\fi-1020\li3620\fc0\cf0 + (char *)
\b argName:
\b0 (unsigned)
\i argNum\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Returns the name of the receiver's 
\i argNum
\i0 'th DSP code argument, as declared in the DSP unit generator source code.  The name isn't copied.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 argSpace:\

\pard\b0\fi-1020\li3620\fc0\cf0 + (DSPMemorySpace)
\b argSpace:
\b0 (unsigned)
\i argNum\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Returns the memory space to or from which the address-valued argument 
\i argNum
\i0  reads or writes.  If 
\i argNum
\i0  isn't an address-valued argument, returns DSP_MS_N.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 classInfo\

\pard\b0\fi-1020\li3620\fc0\cf0 + (MKLeafUGStruct *)
\b classInfo\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the receiver's leaf structure.  A subclass responsibility, this method is automatically generated by 
\b dspwrap
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 enableErrorChecking:\

\pard\b0\fi-1020\li3620\fc0\cf0 + 
\b enableErrorChecking:
\b0 (BOOL)
\i yesOrNo\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets whether various error checks are done, such as verifying that UnitGenerator arguments and Synthdata memory spaces are correct.  The default is NO. You should send enableErrorChecking:YES when you are debugging UnitGenerators or SynthPatches, then disable it when your application is finished.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 masterUGPtr\

\pard\b0\fi-1020\li3620\fc0\cf0 + (MKMasterUGStruct *)
\b masterUGPtr\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the receiver's master structure.  A subclass responsibility, this method is automatically generated by 
\b dspwrap
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 orchestraClass\

\pard\b0\fi-1020\li3620\fc0\cf0 + 
\b orchestraClass\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 This method always returns the Orchestra class.  It's provided for applications that extend the Music Kit to use other synthesis hardware.  If you're using more than one type of hardware, you should create a subclass of UnitGenerator for each.  The default hardware is that represented by Orchestra, the DSP56001.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 shouldOptimize:\

\pard\b0\fi-1020\li3620\fc0\cf0 + (BOOL)
\b shouldOptimize:
\b0 (unsigned)
\i arg\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 A subclass can override this method to reduce the command stream on an argument-by-argument basis, returning 
\b YES
\b0  if 
\i arg
\i0  should be optimized, 
\b NO
\b0  if it shouldn't.  The default implementation always returns 
\b NO
\b0 .\

\fs16 \

\fs28 Optimization of means that if the argument it's set to the same value twice, the second setting is supressed.  You should never optimize an argument that the receiver's DSP code itself might change.\

\fs16 \

\fs28 Argument optimization applies to the entire classÐall instances of the UnitGenerators leaf classes inherit an argument's optimizationÐand it can't be changed during a performance.\

\fs16 \

\pard\tx7140\li2100\fc0\cf0 \
\

\fs28 INSTANCE METHODS\

\fs16 \

\b \

\fs28 argCount\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (unsigned)
\b argCount\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the number of memory arguments in the receiver's DSP code.  The same value is returned by the 
\b argCount
\b0  class method.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 classInfo\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (MKLeafUGStruct *)
\b classInfo\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns a pointer to the receiver's leaf structure.  The same structure pointer is returned by the 
\b classInfo
\b0  class method.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 dealloc\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b dealloc\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Deallocates the receiver and frees its SynthPatch, if any.  Returns 
\b nil
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 finish\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b finish\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Finishes the receiver's activity by sending 
\b finishSelf
\b0  and then sets its status to MK_finishing.  You never subclass this method; 
\b finishSelf
\b0  provides subclass finishing instructions.  Returns the value of 
\b [selffinishSelf]
\b0 , which is taken as the amount of time, in seconds, before the receiver can be idled.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 finishSelf\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (double)
\b finishSelf\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 A subclass may override this method to provide instructions for finishing.  Returns the amount of time needed to finish; The default returns 0.0.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 free\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b free\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Only the Orchestra may free a UnitGenerator.  This method is overridden to do nothing and a private version is used internally.  A subclass can provide specialized behavior by implementing 
\b freeSelf
\b0 .\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 freeSelf\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b freeSelf\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 You never invoke this method directly, it's invoked from 
\b free
\b0 .  A subclass may implement this method to provide specialized behavor.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 idle\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b idle\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Idles the receiver by sending 
\b [self idleSelf]
\b0  and then sets its status to MK_idle.  You never subclass this method; 
\b idleSelf
\b0  provides subclass idle instructions.  The idle state is defined as the UnitGenerator's producing no output.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 idleSelf\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b idleSelf\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 A subclass may override this method to provide instructions for idling.  The default does nothing and returns the receiver.  Most UnitGenerator subclasses implement 
\b idleSelf
\b0  to patch their outputs to sink, a location that, by convention, nobody reads.  UnitGenerators that have inputs, such as Out2sumUG, implement 
\b idleSelf
\b0  to patch their inputs to zero, a location that always holds the value 0.0.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 init\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b init\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Invoke this method when the receiver is is created, after its code is loaded.  If this method returns 
\b nil
\b0 , the receiver is automatically freed by the Orchestra.  A subclass implementation should send 
\b [super init]
\b0  before doing its own initialization and should immediately return 
\b nil
\b0  if 
\b [super init]
\b0  returns 
\b nil
\b0 .  The default implementation returns self.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 instanceNumber\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - (
\f0\fc1\cf1 int
\f1\fc0\cf0 )
\f0\b instanceNumber\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns a low integer that uniquely identifies this UnitGenerator.  This integer is unique for the duration of the execution of the program, unlike object 
\b id
\b0  values, which may be reassigned after an object is freed.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 isAllocated\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (BOOL)
\b isAllocated\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns YES if the receiver has been allocated (by its Orchestra), NO if it hasn't.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 isFreeable\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (BOOL)
\b isFreeable\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Invoked by the Orchestra to determine whether the receiver may be freed.  Returns YES if it can, NO if it can't.  (A UnitGenerator can be freed if it isn't currently allocated or its SynthPatch can be freed.)\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 moved\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b moved\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 You never invoke this method.  It's invoked by the Orchestra if it had to move the receiver during compaction.  A subclass can override this method to perform special behavior.  The default does nothing.  The return value is ignored.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 orchestra\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b orchestra\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the receiver's Orchestra object.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 referenceCount\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (int)
\b referenceCount\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 If this object is installed in its Orchestra's shared table, returns the number of objects that have allocated it. Otherwise returns 1 if it is allocated, 0 if it is not.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 relocation\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (MKOrchMemStruct *)
\b relocation\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns a pointer to the structure that describes the receiver's location on the DSP.  You can access the fields of the structure without caching it first, for example:\

\fs16 \

\pard\f2\fs24\li3120\fc0\cf0 [aUnitGenerator relocation]->pLoop\

\pard\tx3120\tx3620\tx4120\f0\fs16\li2620\fc0\cf0 \

\fs28 returns the starting location of the receiver's pLoop code.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 resources\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (MKOrchMemStruct *)
\b resources\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Return a pointer to the structure that describes the receiver's memory requirements.  Each field of the structure represents a particular Orchestra memory segment; its value represents the number of words that the segment requires.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 run\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b run\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Starts the receiver by sending 
\b [selfrunSelf]
\b0  and then sets its status to MK_running.  You never subclass this method; 
\b runSelf
\b0  provides subclass runtime instructions.  A UnitGenerator must be sent 
\b run
\b0  before it can be used.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 runSelf\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b runSelf\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Subclass implementation of this method provides instructions for making the object's DSP code usable (as defined by the subclass).  You never invoke this method directly, it's invoked automatically by the 
\b run
\b0  method.  The default does nothing and returns the receiver.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 runsAfter:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (BOOL)
\b runsAfter:
\b0\i aUnitGenerator\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Returns 
\b YES
\b0  if the receiver is executed after 
\i aUnitGenerator
\i0 .  Execution order is determined by comparing the objects' pLoop addresses.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setAddressArg:to:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setAddressArg:
\b0 (unsigned)
\i argNum 
\b\i0 to:
\b0\i memoryObj\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the addresst-valued argument 
\i argNum
\i0  to 
\i memoryObj
\i0 .  If 
\i argNum
\i0  (as an index) is out of bounds, an error is generated and 
\b nil
\b0  is returned.  Otherwise returns the receiver.  This is ordinarily only invoked by a subclass.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setAddressArgToSink:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setAddressArgToSink:
\b0 (unsigned)
\i argNum\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the address-valued argument 
\i argNum
\i0  to the sink patchpoint.  (Sink is a location which, by convention, is never read.) If 
\i argNum
\i0  (as an index) is out of bounds, an error is generated and 
\b nil
\b0  is returned.  Otherwise returns the receiver.  This is ordinarily only invoked by a subclass.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setAddressArgToZero:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setAddressArgToZero:
\b0 (unsigned)
\i argNum\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the address-valued argument 
\i argNum
\i0  to a zero patchpoint.  (A zero patchpoint is a location with a constant 0 value; by convention the patchpoint is never written to.) If 
\i argNum
\i0  (as an index) is out of bounds, an error is generated and 
\b nil
\b0  is returned.  Otherwise returns the receiver.  This is ordinarily only invoked by a subclass.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setDatumArg:to:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setDatumArg:
\b0 (unsigned)
\i argNum 
\b\i0 to:
\b0 (DSPDatum)
\i val\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the datum-valued argument 
\i argNum
\i0  to 
\i val
\i0 .  If 
\i argNum
\i0  is an L-space argument (two 24-bit words), its high-order word is set to 
\i val
\i0  and its low-order word is cleared.  If 
\i argNum
\i0  (as an index) is out of bounds, an error is generated and 
\b nil
\b0  is returned.  Otherwise returns the receiver.  This is ordinarily invoked by a subclass.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 setDatumArg:toLong:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b setDatumArg:
\b0 (unsigned)
\i argNum 
\b\i0 toLong:
\b0 (DSPLongDatum *)
\i val\

\fs16 \

\pard\tx3120\tx3620\tx4120\i0\fs28\li2620\fc0\cf0 Sets the datum-valued argument 
\i argNum
\i0  to 
\i val
\i0 .  If 
\i argNum
\i0  isn't an L-space argument (it can't accommodate a 48-bit value) its value is set to the high 24-bits of 
\i val
\i0 .  If 
\i argNum
\i0  (as an index) is out of bounds, an error is generated and 
\b nil
\b0  is returned.  Otherwise returns the receiver.  This is ordinarily only invoked by a subclass.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 status\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0 (int)
\b status\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the receiver's status, one of MK_idle, MK_running, and MK_finishing.\

\fs16 \

\pard\tx7140\b\li2100\fc0\cf0 \

\fs28 synthPatch\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b synthPatch\

\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Returns the SynthPatch that the receiver is part of, if any.\

\fs16 \

\fs28 \

\pard\tx7140\b\li2100\fc0\cf0 writeSymbolsToStream:\

\pard\f1\b0\fi-1020\li3620\fc0\cf0 - 
\f0\b\fc1\cf1 writeSymbolsToStream:
\b0 (NXStream *)
\i st
\b\fc0\cf0 \

\i0\fs16 \

\pard\tx3120\tx3620\tx4120\b0\fs28\li2620\fc0\cf0 Writes the UnitGenerator as a portion of a DSP .lod file.  You normally don't invoked this method.  It's invoked by Orchestra's 
\b writeSymbolTable:
\b0 .\

\fs16 \

\fs28 \

\fs16 \

}
