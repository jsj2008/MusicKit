{\rtf0\ansi{\fonttbl\f0\froman Times-Roman;\f1\ftech\fcharset2 Symbol;\f2\fmodern Courier;
}
{\colortbl;\red255\green255\blue255;}
\paperw15780\paperh15800
\pard\ql\qnatural

\f0\fs24 \cf0 Release 2.0  Copyright 
\f1 „
\f0 1990 by NeXT Computer, Inc.  All Rights Reserved.\
\pard\tx3120\tx3620\tx4120\ql\qnatural
\cf0 Release 4.0 additions Copyright 
\f1 „
\f0 1993 by CCRMA, Stanford University.  All Rights Reserved.\
MIDI Time Code additions Copyright 
\f1 „ 1993 
\f0 by Pinnacle Research.\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \
\pard\li1100\ql\qnatural

\b \cf0 \
\
\
\

\fs36 MKConductor\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b0\fs28 \cf0 INHERITS FROM	NSObject\

\fs16 \

\fs28 DECLARED IN	MusicKit.h\

\fs16 \
\
\

\fs28 CLASS DESCRIPTION\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs28 \cf0 The MKConductor class defines the mechanism that controls the timing of a MusicKit performance.  A MKConductor's most important tasks are to schedule the sending of MKNotes by MKPerformers (and MKMidi), and to control the timing of MKEnvelope objects during DSP synthesis.  Even in the absence of MKPerformers and MKEnvelopes, you may want to use a MKConductor to take advantage of the convenient scheduling mechanism that it provides.\

\fs16 \

\fs28 Each instance of MKConductor contains a message request queue, a list of messages that are to be sent to particular objects at specific times.  To enqueue a message request with a MKConductor, you invoke the 
\b sel:to:atTime:argCount:
\b0  or 
\b sel:to:withDelay:argCount:
\b0  method.  The former sends a message at a specific time measured in beats from the time the MKConductor started performing, while the latter sends the message a specified number of beats after the request is received.  Once you have made a message request through these methods, you can't rescind the action; if you need more control over message requests–for example, if you need to be able to reschedule or remove a request–you should use the following C functions:\

\fs16 \
\pard\tx3120\tx3620\tx4120\tx4620\li3120\fi-520\ql\qnatural

\fs28 \cf0 ∑	
\b MKNewMsgRequest()
\b0  creates and returns a new message request structure.\

\fs16 \

\fs28 ∑	
\b MKScheduleMsgRequest()
\b0  places a previously created message request (structure) in a specific MKConductor's message request queue.\

\fs16 \

\fs28 ∑	
\b MKRepositionMsgRequest()
\b0  repositions a message request within a MKConductor's queue.\

\fs16 \

\fs28 ∑	
\b MKCancelMsgRequest()
\b0  removes a message request.\

\fs16 \

\fs28 ∑	
\b MKRescheduleMsgRequest()
\b0  is a convenience function that cancels a request and then creates a new one.\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs28 \cf0 For more information on these functions, see Chapter 3, "C Functions."\

\fs16 \

\fs28 The MKConductor class provides two special message request queues, one that contains messages that are sent at the beginning of a performance and another for messages that are sent after a performance ends.  The class methods 
\b beforePerformanceSel:to:argCount:
\b0  and 
\b afterPerformanceSel:to:argCount: 
\b0 enqueue message requests in the before- and after-performance queues, respectively.\

\fs16 \

\fs28 A MusicKit performance starts when the MKConductor class receives the 
\b startPerformance
\b0  message.  At that time, the MKConductor class sends the messages in its before-performance queue and then the MKConductor instances start processing their individual message request queues.  As a message is sent, the request that prompted the message is removed from its queue.  The performance ends when the MKConductor class receives 
\b finishPerformance
\b0 , at which time the after-performance messages are sent.  Any message requests that remain in the individual MKConductors' message request queues are removed.   Note, however, that the before-performance queue isn't similarly cleared.  If you invoke 
\b beforePerformanceSel:to:argCount: 
\b0 during a performance, the message request will survive a subsequent 
\b finishPerformance
\b0  and will affect the next performance.  \

\fs16 \

\fs28 By default, if all the MKConductors' queues become empty at the same time (not including the before- and after-performance queues), 
\b finishPerformance
\b0  is invoked automatically.  This is convenient if you're performing a MKPart or MKScore and you want the performance to end when all the MKNotes have been played.  However, for many applications, such as those that create and perform MKNotes in response to a user's actions, universally empty queues isn't necessarily an indication that the performance is over.  To allow a performance to continue even if all the queues are empty, send 
\b setFinishWhenEmpty:NO 
\b0 to the MKConductor class.\

\fs16 \

\fs28 You can pause and resume an entire performance through methods sent to the MKConductor class:\

\fs16 \
\pard\tx3120\tx3620\tx4120\tx4620\li3120\fi-520\ql\qnatural

\fs28 \cf0 ∑	
\b pausePerformance
\b0  causes all MKConductor instances to stop processing their message request queues.  \

\fs16 \

\fs28 ∑	
\b resumePerformance
\b0  resumes a paused performance.  \

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs28 \cf0 These messages are ignored if a performance isn't in progress.\

\fs16 \

\fs28 You can pause and resume individual MKConductor objects through the 
\b pause
\b0  and 
\b resume
\b0  methods.  In addition, you can pause a MKConductor object for a predetermined number of seconds (not beats) through 
\b pauseFor:
\b0 .  To offset the begin time of a MKConductor
\b  
\b0 object before a performance starts, invoke 
\b setTimeOffset:
\b0 .  Here again, the arguments is taken as seconds.  You can also offset the begin time of a MKConductor object by an indeterminate amount of time by sending it the 
\b pause
\b0  message before a performance begins and then sending it 
\b resume
\b0  while the performance is in progress.  After a performance has ended, all currently paused MKConductor objects are (virtually) resumed.  Thus, a MKConductor object is guaranteed not to be paused when a performance starts (unless, of course, you have specifically sent it the 
\b pause
\b0  message since 
\b finishPerformance
\b0  was last sent).\

\fs16 \

\fs28 A MKConductor object can be given a delegate that's sent the 
\b hasPaused:
\b0  message when the MKConductor is paused and 
\b hasResumed:
\b0  when the MKConductor resumes.  As in the AppKit's delegate paradigm, a delegate messages is sent only if the delegate responds to it.  \

\fs16 \

\fs28 The rate at which a MKConductor object processes its message request queue can be set through either the 
\i Tempo Protocol
\i0  or the 
\i Time Map Protocol.
\i0    The 
\i Tempo Protocol
\i0  consists of the following two methods (you may use either):\

\fs16 \
\pard\tx3120\tx3620\tx4120\tx4620\li3120\fi-520\ql\qnatural

\fs28 \cf0 ∑	
\b setTempo:
\b0  sets the rate as beats per minute.\
∑	
\b setBeatSize:
\b0  sets the size of an individual beat, in seconds. \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \

\fs28 You can change a MKConductor's tempo anytime, even during a performance.  If your application requires multiple simultaneous tempi, you need to create more than one MKConductor, one for each tempo.  A MKConductor's tempo is initialized to 60.0 beats per minute.\
\
An alternative way to modify tempo is to use a tempo track or "Time Map".   This protocol relies on the MKConductor's delegate to implement two methods that specify the mapping between "beat time" and "clock time."  If the delegate implements one of these methods, it must implement both.  By implementing these methods, the delegate specifies that it is using the 
\i Time Map Protocol
\i0 .   The two methods are 
\b beatToClock:from:
\b0  and 
\b clockToBeat:from:
\b0 .  These methods map from pre-tempo to post-tempo time.  For details, see \
	
\b  /Local/Library/Frameworks/MusicKit.framework/Resources/English.lproj/Documentation/Concepts/MusicPerformance.rtfd
\b0 \

\fs16 \

\fs28 The responsiveness of a performance to the user's actions depends on whether the MKConductor class is clocked and upon the value of the performance's 
\i delta time
\i0 .  By default, the MKConductor class is clocked which means that message request queues are processed in a timely fashion:  If, for example, two requests are specified to be sent one beat apart, then the message sending mechanism sends the first message and then, one beat later, sends the second message.  When the MKConductor class is clocked, a running NSApplication object is assumed to be present.  If you don't need interactive control over a performance, you may find it beneficial to have the messages in the message request queues sent one after another as quickly as possible, while depending on another device, such as the DSP or MIDI drivers, to handle the timing of the actual realization (this is further explained in the descriptions of the MKOrchestra and MKMidi classes).  To allow the queues to be processed in this way, you set the MKConductor class to be unclocked by sending it the 
\b setClocked:NO
\b0  message.  If you set the MKConductor class to be unclocked, be aware that the 
\b startPerformance
\b0  method doesn't return until the performance is over.  (In this situation, sending 
\b setFinishWhenEmpty:NO
\b0  to the MKConductor class is ill-advised since 
\b startPerformance
\b0  would never return.)  \

\fs16 \

\fs28 Setting a performance's delta time further refines the responsiveness of a performance. Delta time is set through the 
\b setDeltaT:
\b0  class method; the argument defines an imposed time lag, in seconds, between the MKConductor's notion of time and that of the DSP and MIDI device drivers.  It acts as a timing cushion that can help to maintain rhythmic integrity by granting your application a sort of computational head start:  As you set the delta time to larger values, your application has more time to process MKNotes before they are realized.  However, this computational advantage is obtained at the expense of degraded responsiveness.  Choosing the proper delta time value depends on how responsive your application needs to be.  For example, if you are driving DSP synthesis from MIDI input (in other words, you have a MKMidi object connected to a MKSynthInstrument–this is usually the most demanding scenario in terms of desired real-time response), a delta time of as much as 10 milliseconds (0.01 seconds) is generally acceptable.  If you are adjusting MKNote parameters by moving a NSSlider with the mouse, a delta time of 100 milliseconds or more can be tolerated.  Finding the right delta time for your application is largely a matter of experimentation.\

\fs16 \

\fs28 Every MKConductor instance has a notion of the current time measured in its own tempo, as returned by sending it the 
\b time
\b0  message.  The returned value is the number of beats the receiver has spent in performance and doesn't include the receiver's time offset, any time it has spent while paused, nor does it include the performance's delta time.  The MKConductor class also responds to the 
\b time
\b0  message; it returns the current duration of the performance in seconds, excluding any time that the entire performance has been paused (and also excluding deltat time).  The value returned by the 
\b time
\b0  message, whether sent to the MKConductor class or to an instance, is actually the time at which the last message from any of the MKConductors' queues was sent.  This latency is present because the MKConductor class updates its notion of time (from which all the MKConductor instances compute their time) only when a message from one of the request queues is sent.  If your application sends a message (or calls a C function) in response to an asynchronous event, it must first update the MKConductors' notions of time by bracketing the code you invoke with
\b  [MKConductor
\b0  
\b lockPerformance] 
\b0 and 
\b [MKConductor unlockPerformance]
\b0  .  You should send these messages before performing tasks such as pausing or resuming a MKConductor–you should even send them immediately before sending 
\b finishPerformance
\b0 .  If, for yet another example, your application sends MKNotes directly to MKInstruments, you should send 
\b lockPerformance
\b0  immediately before each MKNote is sent and 
\b unlockPerformance 
\b0 afterwards.  (This API supercedes the older 
\b adjustTime
\b0 , which will still work only if the MusicKit is not run in a separate thread.   See 
\b +useSeparateThread:
\b0 .)\

\fs16 \

\fs28 MKConductors and MKPerformers have a special relationship:  Every MKPerformer object is controlled by an instance of MKConductor, as set through MKPerformer's 
\b setConductor:
\b0  method.  While a MKPerformer can be controlled by only one MKConductor, a single MKConductor can control any number of MKPerformers.  As a MKPerformer acquires successive MKNotes, it enqueues, with its associated MKConductor, requests for the MKNotes to be sent to its connected MKInstruments.  This enqueuing is performed automatically through a mechanism defined by the MKPerformer class.  As a convenience, the MusicKit automatically creates an instance of MKConductor called the 
\i defaultConductor
\i0 ; if you don't set a MKPerformer's MKConductor directly, it's controlled by the defaultConductor.    You can retrieve the defaultConductor (in order to set its tempo or to enqueue message requests, for example) by sending the 
\b defaultConductor
\b0  message to the MKConductor class.  \

\fs16 \

\fs28 The MusicKit also creates an instance of MKConductor called the 
\i clockConductor
\i0 , which you can retrieve through the 
\b clockConductor
\b0  class method.  The clockConductor has an unchangeable tempo of 60.0 beats per minute and can't be paused.  While the clockConductor can be used to control MKPerformers, its most important task is to control the timing of MKEnvelope objects during DSP synthesis.  All MKEnvelopes are controlled by the clockConductor automatically.  The clockConductor also controls the duration of any MKNoteDurs that you send directly to an MKInstrument.  In other words, the duration of such a MKNote is always computed using the 60.0 beats-per-minute tempo of the clockConductor.  \

\fs16 \

\fs28 The clockConductor's queue is treated like any other queue:  You can enqueue message requests with the clockConductor just as you would with any other MKConductor.  This also means that the clockConductor's queue contributes to a determination of whether all the queues are empty.\
\
MKConductors can synchronize to incoming MIDI time code.   This functionality is described in \
\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b \cf0 /Local/Library/Frameworks/MusicKit.framework/Resources/English.lproj/Documentation/Concepts/SpecialTopics/MIDITimeCode.rtf\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 \

\fs16 \

\fs28 See also:  MKPerformer, MKOrchestra, MKMidi\

\fs16 \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\

\fs28 INSTANCE VARIABLES\

\fs16 \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\i\fs28 \cf0 Inherited from NSObject
\i0 	Class	isa;\

\fs16 \

\fs28 Declared in MKConductor	double	time;\
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural
\cf0 double	nextMsgTime;\
double	beatSize;\
double	timeOffset;\
BOOL	isPaused;\
id	delegate;\
id	activePerformers;\
id	MTCSynch;\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs16 \cf0 \

\fs28 time 	Current time in beats.\

\fs16 \

\fs28 nextMsgTime 	Time, in seconds, when the object is scheduled to send its next message.\
	
\fs16 \

\fs28 beatSize 	The duration of a single beat, in seconds.\

\fs16 \

\fs28 timeOffset 	Performance time offset, in seconds.\

\fs16 \

\fs28 isPaused 	
\b YES
\b0  if this object is currently paused.\

\fs16 \

\fs28 delegate 	The object's delegate.\
\pard\tx7140\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs28 \cf0 activePerformers	NSMutableArray object of active performers using this conductor.  Don't alter this NSMutableArray.\
\pard\tx7140\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs28 \cf0 MTCSynch	MIDI time code synchronization object, if any.\
\pard\tx7140\li2100\ql\qnatural

\fs16 \cf0 \

\fs28 \
METHOD TYPES\

\fs16 \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs28 \cf0 Creating a MKConductor	
\f1 - 
\f0 copy \
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural
\cf0 + allocFromZone:\
+ alloc\
± init\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs16 \cf0 \

\fs28 Modifying the class	+ setClocked: \
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural
\cf0 + setFinishWhenEmpty:\
+ setDelegate:\
+ setDeltaT:\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs16 \cf0 \

\fs28 Querying the class	+ clockConductor\
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural
\cf0 + currentConductor\
+ defaultConductor\
+ delegate\
+ finishWhenEmpty\
+ inPerformance\
+ isClocked\
+ isEmpty\
+ isPaused\
+ time\
+ deltaT\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs16 \cf0 \

\fs28 Modifying the object	
\f1 - 
\f0 setBeatSize: \
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural

\f1 \cf0 - 
\f0 setTempo: \

\f1 - 
\f0 setTimeOffset:\

\f1 - 
\f0 setDelegate: \

\f1 - 
\f0 setMTCSynch:\
\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural
\cf0 Querying the object	
\f1 - 
\f0 activePerformers\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\f1 \cf0 \U9 - 
\f0 beatSize\
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural

\f1 \cf0 -
\f0  clockTime\

\f1 -
\f0  delegate\

\f1 - 
\f0 isCurrentConductor\

\f1 - 
\f0 isPaused\

\f1 - 
\f0 MTCSynch\

\f1 - 
\f0 tempo\

\f1 - 
\f0 time\

\f1 - 
\f0 timeOffset\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs16 \cf0 \

\fs28 Controlling a performance	+ adjustTime\
	+ finishPerformance\
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural

\f1 \cf0 - 
\f0 pause\

\f1 - 
\f0 pauseFor:\
+ pausePerformance\

\f1 - 
\f0 resume\
+ resumePerformance\
+ startPerformance\
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural

\b \cf0 \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\b0 \cf0 Multiple thread control	+ lockPerformance\
	+ lockPerformanceNoBlock\
	+ performanceThread: \
	+ sendMsgToApplicationThreadSel:to:argCount: \
	+ setInterThreadThreshold
\b :
\b0 \
	+ setThreadPriority
\b :
\b0 \
	+ unlockPerformance	\
	+ useSeparateThread\
\
Requesting messages	+ afterPerformanceSel:to:argCount: \
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural
\cf0 + beforePerformanceSel:to:argCount: \
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural

\f1 \cf0 - 
\f0 emptyQueue\

\f1 - 
\f0 sel:to:atTime:argCount: \

\f1 - 
\f0 sel:to:withDelay:argCount:\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\fs16 \cf0 \

\fs28 Archiving	
\f1 -
\f0  finishUnarchiving:\
\pard\tx10180\tx10680\li7660\fi-520\ql\qnatural

\f1 \cf0 -
\f0  read\

\f1 -
\f0  write\
\pard\tx7140\li2100\ql\qnatural

\fs16 \cf0 \
\
\

\fs28 CLASS METHODS\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 alloc\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b alloc\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Creates and returns a new MKConductor object with a tempo of 60.0 beats per minute, allocated from the default zone.  You must send 
\b init 
\b0 to the new instance.  If a performance is currently in progress, this does nothing and returns 
\b nil
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 adjustTime\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b adjustTime\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i\b0\fs28 \cf0 This method is superceded by 
\b +lockPerformance 
\b0 and 
\b +unlockPerformance
\b0 .
\i0   \
\
Updates every MKConductor's notion of time.  This method may be invoked just before you send a message or call a C function that affects the performance.  Typical examples include methods that are in response to the user's actions, methods that send MKNotes directly to MKInstruments, and methods, such as 
\b pause
\b0  and 
\b resume
\b0 , that are sent to a MKConductor object or to the MKConductor class.  You do not need to send this message if you are invoked in response to MKConductor or MKMidi messages.  Returns the receiver.\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 afterPerformanceSel:to:argCount:\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (MKMsgStruct *)
\b afterPerformanceSel:
\b0 (SEL)
\i aSelector
\i0  \
\pard\li3620\ql\qnatural

\b \cf0 to:
\i\b0 toObject
\i0  \

\b argCount:
\b0 (int)
\i argCount,...\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Enqueues a request for 
\i aSelector
\i0  to be sent to 
\i toObject
\i0  immediately after the current (or next) performance ends.  
\i argCount
\i0  specifies the number of four-byte arguments to 
\i aSelector
\i0  followed by the arguments themselves, separated by commas (two arguments, maximum).  You can enqueue as many of these requests as you want; they're sent in the order that they were enqueued.  Returns a pointer to a 
\i message request structure that can be passed to 
\i0\b a C function such as MKCancelMsgRequest()
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 beforePerformanceSel:to:argCount:\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (MKMsgStruct *)
\b beforePerformanceSel:
\b0 (SEL)
\i aSelector
\i0  \
\pard\li3620\ql\qnatural

\b \cf0 to:
\i\b0 toObject
\i0  \

\b argCount:
\b0 (int)
\i argCount,...\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Enqueues a request for 
\i aSelector
\i0  to be sent to 
\i toObject
\i0  at the beginning of the next performance.  
\i argCount
\i0  specifies the number of four-byte arguments to 
\i aSelector
\i0  followed by the arguments themselves, separated by commas (two arguments, maximum).  You can enqueue as many of these requests as you want; they're sent in the order that they were enqueued.  Returns a pointer to a 
\i message request structure that can be passed to 
\i0\b a C function such as MKCancelMsgRequest()
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 clockConductor\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b clockConductor\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the clockConductor.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 currentConductor\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs16 \cf0 \

\fs28 + 
\b currentConductor\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the MKConductor instance that's currently sending a message, or 
\b nil
\b0  if no message is being sent.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 defaultConductor\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b defaultConductor\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the defaultConductor.\

\fs16 \
\
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 deltaT
\b0 \
\pard\li3620\fi-1020\ql\qnatural

\b \cf0 + 
\b0 (double)
\b  deltaT
\b0 \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural
\cf0 \
Returns the delta time in seconds.\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 finishPerformance\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b finishPerformance\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Ends the performance.  All enqueued messages are removed (from MKConductor instances' message queues–not from the before- and after-performance queues) and the 
\b after-performance
\b0  messages are sent
\b .  
\b0 If
\b  finishWhenEmpty
\b0  is 
\b YES
\b0 , this message is automatically sent when all message queues are exhausted.  Returns 
\b nil
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 finishWhenEmpty\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (BOOL)
\b finishWhenEmpty\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if the performance will finish when all MKConductors' message queues are empty, 
\b otherwise returns NO
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 inPerformance\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (BOOL)
\b inPerformance\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if a performance is currently taking place (even if it's paused), otherwise returns 
\b NO
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 isClocked\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (BOOL)
\b isClocked\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if the performance is clocked, 
\b NO
\b0  if it isn't.  By default, a performance is clocked.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 isEmpty\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (BOOL)
\b isEmpty\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if a performance is in progress and all the MKConductor instances' message request queues are are empty, otherwise returns 
\b NO.\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural
\cf0 \

\fs28 isPaused\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + (BOOL)
\b isPaused\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if the performance is paused, otherwise returns 
\b NO
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 lockPerformance\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 +
\f0\b  lockPerformance
\f1\b0 \
\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\f0 \cf0 In a separate-threaded performance, this method gets the MusicKit lock, then sends 
\b [MKConductor adjustTime]
\b0 . 
\b lockPerformance
\b0  may be called multiple times -- e.g. if you lock twice you must unlock twice to give up the lock.  In a performance that is not separate-threaded, this method is the same as 
\b +adjustTime
\b0 . \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\fs16 \cf0  \
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 lockPerformanceNoBlock\
\pard\li3620\fi-1020\ql\qnatural
\cf0 + 
\b0 (BOOL)
\b lockPerformanceNoBlock\
\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 Same as lockPerformance but does not wait and returns NO if the lock is  unavailable.  If the lock is successful, sends 
\b [MKConductor adjustTime]
\b0  and returns YES. You rarely use this method.  It is provided for cases where you would prefer to give up than to wait (e.g. when simultaneously doing graphic animation.)\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 pausePerformance\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b pausePerformance\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Pauses the performance.  The performance is suspended until the MKConductor class receives the 
\b resumePerformance
\b0  message.  You can't pause an unclocked performance; returns 
\b nil
\b0  if the performance is unclocked.  Otherwise returns the receiver.  This message is ignore and the receiver is returned if a performance isn't in progress.  You cannot pause a performance in which a MKConductor is synchronizing to MIDI time code.   An attempt to do so will be ignored.     \
\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 performanceThread\
\pard\li3620\fi-1020\ql\qnatural
\cf0 + 
\b0 (cthread_t) 
\b performanceThread\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 \
In a separate-threaded MusicKit performance, returns the c-thread used in that performance.  When the thread has exited, returns NO_CTHREAD. \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 resumePerformance\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b resumePerformance\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Resumes a  performance, allowing it to continue from where it was paused.  If the performance is unclocked, return 
\b nil
\b0 , otherwise returns the receiver.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 sendMsgToApplicationThreadSel:to:argCount: \
\pard\li3620\fi-1020\ql\qnatural
\cf0 +sendMsgToApplicationThreadSel:
\b0 (SEL)
\i aSelector
\i0\b  \
  to:
\b0 (id)
\i toObject
\i0\b \
  argCount:
\b0 (int)
\i argCount
\i0\b , . . .\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0  \
If called from the MusicKit thread, sends an Objective-C message from the MusicKit thread to the Application's main thread.  This is the only safe way to invoke the Application Kit from within the MusicKit's thread.  The message will be run in the application as soon as the Application event loop threshold is NX_BASETHRESHOLD.  To increase the priority of  MusicKit-sent messages, use 
\b +setInterThreadThreshold:
\b0 .  If called from the Application Kit thread, or there is no separate-threaded performance going on, this is the same as sending aSelector directly to toObject. \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 setClocked:\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b setClocked:
\b0 (BOOL)
\i yesOrNo\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 If 
\i yesOrNo
\i0  is 
\b YES
\b0  (the default), the MKConductors dispatches each message at the specified time, waiting if necessary.  If 
\b NO
\b0 , messages are sent as quickly as possible.  In an unclocked performance, a subsequent startPerformance message doesn't return until the performance is over, thus effectively disabling the user interface.  Does nothing and returns 
\i\b nil
\b0  
\i0 if a performance is in progress, otherwise returns the receiver.
\i   
\i0  Unclocked performances involving MIDI time code conductors are not supported.   
\fs22 \
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 \
setDeltaT:\
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural
\cf0 + setDeltaT: 
\b0 (double) 
\i newDeltaT
\i0\b \
\pard\tx7140\tx10180\tx10680\li7140\fi-4540\ql\qnatural

\b0 \cf0 Set the delta time in seconds.\
\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural
\cf0 See also:  
\b MKSetDeltaT()
\b0 .
\b \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
setFinishWhenEmpty:\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b setFinishWhenEmpty:
\b0 (BOOL)
\i yesOrNo\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 If 
\i yesOrNo
\i0  is 
\b YES
\b0  (the default), the performance is terminated when all the MKConductors' message queues are empty.  If 
\b NO
\b0 , the performance continues until the 
\b finishPerformance
\b0  message is sent to the MKConductor class.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 setInterThreadThreshold:\
\pard\li3620\fi-1020\ql\qnatural
\cf0 +setInterThreadThreshold:
\b0 (int)
\i newThreshold
\i0\b \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\b0\fs16 \cf0  \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs28 \cf0 Resets Display Postscript threshold used for interthread communication.  This message may only be sent from the Application thread.  Otherwise, it is ignored.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
setMTCSynch:\
\pard\li3620\fi-1020\ql\qnatural
\cf0 ± setMTCSynch:
\i\b0 aMidiObject
\i0\b \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\b0\fs16 \cf0  \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs28 \cf0 Sets the MKConductor to synchronize to MIDI time code coming in on the specified MIDI object.  Keep in mind that only one MKConductor at a time may have an MTCSynch object.   Unclocked performances involving MIDI time code conductors are not supported.   
\fs22  
\fs28 Hence,
\b  setMTCSynch: 
\b0 sends 
\f2\fs24 [MKConductor setClocked:YES];.
\f0\fs28  For details, see 
\b MIDITimeCode.rtf 
\b0 described above.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
startPerformance\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b startPerformance\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Starts a performance.  All MKConductor objects begin at the same time.  If the performance is clocked and you don't have a running Application object (NSApplication), this does nothing and returns 
\b nil
\b0 .  In all other cases, the receiver is returned; however, if the performance is unclocked, this method doesn't return until the performance is over.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 setThreadPriority:\
\pard\li3620\fi-1020\ql\qnatural
\cf0 + setThreadPriority:
\b0 (float)
\i priorityFactor
\i0\b \
\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method sets the thread priority of the following and all subsequent performances.  The priority change takes effect when the 
\b startPerformance
\b0  method is invoked and is set back to its original value in the 
\b finishPerformance
\b0  method.  In a separate-threaded performance, the thread that is affected is the performance thread.  In the case of a performance that is not separate-threaded, the thread affected is the one that invoked the 
\b startPerformance
\b0  method.\
\
Priority is specified as a "priorityFactor" between 0.0 and 1.0.  1.0 corresponds to the maximum priority of a user process, 0.0 corresponds to the base priority. The default value is 0.0.\
 \
In addition, if priorityFactor is greater than 0, the MusicKit uses Mach's "fixed priority thread scheduling policy".  (See the Mach documentation for details on thread scheduling policies. )  This scheduling policy is more advantageous for real-time processes than  the ordinary time sharing policy. \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b\fs28 \cf0 time\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 + 
\b (double)time\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Same as 
\f2\fs24 [[MKConductor clockConductor] time]
\f0\b\fs28 .
\b0   Returns the current performance time, in seconds.  This doesn't include time that the performance has been paused, nor does it include the performance's delta time.  If a performance isn't in progress, MK_NODVAL is returned .  Use 
\b MKIsNoDVal()
\b0  to check for this return value.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
unlockPerformance\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 + 
\f0\b unlockPerformance\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\ql\qnatural

\b0\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs28 \cf0 Undoes lockPerformance.  In a separate-threaded performace, sends 
\b [MKOrchestra flushTimedMessages] 
\b0 and then gives up the MusicKit lock.  In a performance that is not separate-threaded, this method is the same as MKOrchestra's 
\b flushTimedMessages
\b0 , except that the flush is done only when the last recursive lock is given up (See MKOrchestra.h.)\
\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 useSeparateThread\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 +
\b useSeparateThread:
\b0 (BOOL)
\i yesOrNo
\i0 ;\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 	\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 If invoked with an argument of YES, all following performances will be run in a separate Mach thread.  Some restrictions apply to separate-threaded performances as follows:  You may not do any drawing or appkit calls from the separate thread.  If you need to send a message to the appkit, use 
\b +sendMsgToApplicationThreadSel:  to:argCount:
\b0 .  
\b \
\

\b0 Default is NO.  You should not send this message if any MKMidi objects are open (or running or stopped. ) \
 
\b \

\b0\fs16 \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\

\fs28 INSTANCE METHODS\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 activePerformers\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b activePerformers\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns a List of currently active Performers that are assigned to this MKConductor.  The NSMutableArray is 
\i not 
\i0 copied and should not be freed or altered.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 beatSize\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b beatSize\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the size of the receiver's beat in seconds.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 clockTime\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b clockTime\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 A convenience method.  Returns the current clock time for the object.  If the object is synchronizing to MIDI time code, the value returned is the current MIDI time code time, the same value returned by MKMidi's 
\b time
\b0  method.   If the object is not synchronizing to MIDI time code, the value returend is the same value as the value returned by  
\f2\fs24 [[MKConductor clockConductor] time]
\f0\fs28 .\
\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 copy\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b copy\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns a new MKConductor created through 
\b [MKConductor new]
\b0 .\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 delegate\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b delegate\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the receiver's delegate object, as set through the 
\b setDelegate:
\b0  method.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 emptyQueue\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b emptyQueue\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Removes all message requests from the receiver's message request queue and returns the receiver.    Doesn't send any of the messages.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 finishUnarchiving\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b finishUnarchiving\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 You never invoke this method directly; to read an archived MKConductor, call the 
\b NXReadObject()
\b0  C function.  This method is invoked by 
\b NXReadObject()
\b0  which returns the value returned by this method, as follows:  If the unarchived MKConductor was the clockConductor (when it was archived), this method frees the new object and returns the current clockConductor.  If a performance is in progress, the new object is freed and the defaultConductor is returned.  If a performance isn't in progress and the new object was the defaultConductor, the current defaultConductor takes the new object's tempo and time offset, the new object is freed, and the defaultConductor is returned.  Otherwise, the new object is successfully added to your application's pool of MKConductor instances and 
\b nil
\b0  is returned.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 init\
\pard\li3620\fi-1020\ql\qnatural

\b0 \cf0 ± 
\b init\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Initializes a new MKConductor.  You must send this message after using 
\b alloc 
\b0 or 
\b allocFromZone: 
\b0 to create a MKConductor.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 isCurrentConductor\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (BOOL)
\b isCurrentConductor\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if the receiver is currently sending a message from its message request queue.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 isPaused\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (BOOL)
\b isPaused\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns 
\b YES
\b0  if the receiver is paused.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 MTCSynch\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b MTCSynch\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the Midi object previously set with 
\b setMTCSynch:
\b0 , or 
\b nil 
\b0 if none.  Keep in mind that only one MKConductor at a time may have an MTCSynch object.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 pause\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b pause\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Pauses the performance of the receiver and sends 
\b hasPaused:
\b0  to its delegate.  The effect is restricted to the present performance.  Invoke 
\b resume
\b0  to unpause a MKConductor.  You can't pause the clockConductor; returns 
\b nil
\b0  in this case (and the delegate message isn't sent).  Otherwise returns the receiver.  Note that you can pause a MKConductor object before a performance begins.  You cannot pause a MKConductor that is synchronizing to MIDI time code.  An attempt to do so is ignored.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 pauseFor:
\b0 (double)
\i seconds\
\pard\li3620\fi-1020\ql\qnatural

\f1\i0 \cf0 - 
\f0\b pause\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 A convenience method.  Pauses the performance of the receiver, sends 
\b hasPaused:
\b0  to its delegate, and schedules a request for 
\b resume
\b0  to be sent to the receiver in 
\i seconds
\i0  seconds.  If the receiver is currently paused through a previous invocation of this method, the current 
\b resume
\b0  request supercedes the previous one.  The effect is restricted to the present performance.  You can't pause the clockConductor; returns 
\b nil
\b0  in this case (and the delegate message isn't sent).  Otherwise returns the receiver.  Note that you can invoke this method before a performance begins; the 
\b resume
\b0  message is enqueued to be sent 
\i seconds
\i0  seconds after the performance starts.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 read:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b read:
\b0 (NXTypedStream *)
\i stream\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 You never invoke this method directly; to read an archived MKConductor, call the 
\b NXReadObject()
\b0  C function.  \

\fs16 \

\fs28 SEE ALSO: 
\f1 - 
\f0\b finishUnarchiving\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\fs16 \cf0 \
\pard\tx7140\li2100\ql\qnatural
\cf0 \

\fs28 resume\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b resume\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Resumes the receiver's performance and returns the receiver.  If the receiver isn't currently paused, this has no effect.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 sel:to:atTime:argCount:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b sel:
\b0 (SEL)
\i aSelector
\i0  \
\pard\li3620\ql\qnatural

\b \cf0 to:
\i\b0 toObject
\i0  \

\b atTime:
\b0 (double)
\i time
\i0  \

\b argCount:
\b0 (int)
\i argCount,...\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Places, in the receiver's message request queue, a request for 
\i aSelector
\i0  to be sent to 
\i toObject
\i0  at time 
\i time
\i0  beats from the beginning of the receiver's performance.  
\i argCount
\i0  specifies the number of four-byte arguments to 
\i aSelector
\i0  followed by the arguments themselves, seperated by commas (two arguments, maximum). \

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 sel:to:withDelay:argCount:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b sel:
\b0 (SEL)
\i aSelector
\i0  \
\pard\li3620\ql\qnatural

\b \cf0 to:
\i\b0 toObject
\i0  \

\b withDelay:
\b0 (double)
\i beats
\i0  \

\b argCount:
\b0 (int)
\i argCount,...\

\fs16 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Places, in the receiver's message request queue, a request for 
\i aSelector
\i0  to be sent to 
\i toObject
\i0  at time 
\i beats
\i0  beats from the receiver's notion of the current time.  To ensure that the receiver's notion of time is up to date, you should send 
\b lockPerformance
\b0  before invoking this method and 
\b unlockPerformance 
\b0 afterwards.   
\i argCount
\i0  specifies the number of four-byte arguments to 
\i aSelector
\i0  followed by the arguments themselves, seperated by commas (two arguments, maximum).\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 setBeatSize:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b setBeatSize:
\b0 (double)
\i newBeatSize\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Sets the tempo by changing the size of a beat to 
\i newBeatSize
\i0 , measured in seconds.  The default beat size is 1.0 (one second).  Attempts to set the tempo of the clockConductor are ignored.  Returns the previous beat size.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 setDelegate:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b setDelegate:
\i\b0 delegate\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Sets the receiver's delegate object to 
\i delegate
\i0  and returns the receiver.  The delegate is sent 
\b hasPaused:
\b0  and 
\b hasResumed:
\b0  as the receiver is paused and resumed, respectively. \

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 setTempo:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b setTempo:
\b0 (double)
\i newTempo\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Sets the receiver's tempo to 
\i newTempo
\i0 , measured in beats per minute.  Attempts to set the tempo of the clockConductor are ignored.  Returns the previous tempo.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 setTimeOffset:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b setTimeOffset:
\b0 (double)
\i newTimeOffset\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 Sets the receiver's performance time offset to 
\i newTimeOffset
\i0  seconds.  Keep in mind that since the offset is measured in seconds, it's not affected by the receiver's tempo.  Attempts to set the offset of the clockConductor are ignored.  Returns the previous time offset.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 tempo\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b tempo\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the receiver's tempo in beats per minute.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 time\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 -
\f0  (double)
\b time\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the receiver's notion of the current time in beats.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 timeOffset\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0 (double)
\b timeOffset\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0\fs28 \cf0 Returns the receiver's performance time offset in seconds.\

\fs16 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \

\fs28 write:\
\pard\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b write:
\b0 (NXTypedStream *)
\i stream\
\pard\li3620\fi-1020\ql\qnatural

\fs16 \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\i0\fs28 \cf0 You never invoke this method directly; to archive a MKConductor, call the 
\b NXWriteObject()
\b0  C function.  An archived MKConductor maintains its 
\b beatSize
\b0  and 
\b timeOffset
\b0  instance variables.\

\fs16 \
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\li1100\ql\qnatural

\b\fs36 \cf0 MKConductor Delegate\
\
\pard\tx7140\li2100\ql\qnatural

\b0\fs28 \cf0 The following methods may be implemented by the instance delegate. The messages get sent, if the delegate responds to them, after the MKConductor's status has changed:\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
beatToClock:from:\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b beatToClock:
\b0 (double)
\i val 
\i0\b from:
\i\b0 sender
\i0\b  \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method is sent to the delegate by a MKConductor instance, but only if the delegate responds to it.  It is sent to map "beat time" (the time as represented in the score) to "clock time", the time after any tempo  mappings have been performed.    If the delegate implements 
\b beatToClock:from:
\b0 , it must also implement 
\b clockToBeat:from:
\b0 .  The delegate's implementation must be inexpensive, as this method is called many times.  \
For meaningful behavior, the implementation of these methods must follow the following rules:\
\
   1. Each is the inversion of the other.  Thus, for any value 
\i x
\i0 , the following must be true:\
	\
	
\f2\fs24 [clockToBeat:[beatToClock: x from:obj] from:obj]==x\

\f0\fs28      and	\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\f2\fs24 \cf0   	[beatToClock:[clockToBeat: x from:obj] from:obj]==x\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\f0\fs28 \cf0 \
    2. Each must return values that are monotonically increasing with respect to their argument. That is, if 
\i x
\i0  is greater than 
\i y
\i0 , then:\
\
	
\f2\fs24 [beatToClock: x from:obj] > [beatToClock:y from:obj]\

\f0\fs28     and
\f2\fs24            	[clockToBeat: x from:obj] > [clockToBeat:y from:obj]\

\f0\fs28 \
     3.  Each must be time-invarient.  That is, invoking one of these methods with a particular value must always produce the same result, for the duration of a performance.  \
\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 clockToBeat:from:\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b clockToBeat:
\b0 (double)
\i val 
\i0\b from:
\i\b0 sender
\i0\b  \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method is the inverse of 
\b beatToClock:from:.   
\b0 See 
\b beatToClock:from:
\b0  for details.\
\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 conductorCrossedLowDeltaTThreshold\
conductorCrossedHighDeltaTThreshold\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b conductorCrossedHighDeltaTThreshold \

\f1\b0 - 
\f0\b conductorCrossedLowDeltaTThreshold\
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 These method are sent to the delegate (if it responds to them) by a MKConductor class to warn it that the performance is about to fall out of real time.    When computation gets heavy and the reserve of deltaTime falls below the low water mark, 
\b conductorCrossedLowDeltaTThreshold
\b0  is invoked.   When computation lightens up and the deltaTime is recovered, 
\b conductorCrossedHighDeltaTThreshold
\b0  is invoked.   As an example of the use of this mechanism, you might slow down the tempo in your 
\b conductorCrossedLowDeltaTThreshold
\b0  implementation or reduce in some other way the amount of computation.   The high and low thresholds are set with the C functions \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b \cf0 MKSetLowDeltaTThreshold() 
\b0 and
\b  MKSetHighDeltaTThreshold().
\b0 \
\
See also:  
\b setDeltaT:
\b0 , 
\b MKSetDeltaT()
\b0 .
\b \
\
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 conductorDidPause:\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b conductorDidPause:
\i\b0 sender
\i0\b  \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method is sent to the delegate by a MKConductor instance, but only if the delegate responds to it.  It is sent after the MKConductor pauses.  This notification is especially useful when synchronizing to MIDI time code.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
conductorDidResume:\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b conductorDidResume:
\i\b0 sender
\i0\b  \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method is sent to the delegate by a MKConductor instance, but only if the delegate responds to it.  It is sent after the MKConductor resumes.  This notification is especially useful when synchronizing to MIDI time code.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
conductorDidSeek:\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b conductorDidSeek:
\i\b0 sender
\i0\b  \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method is sent to the delegate (if it responds to it) when MIDI time code starts coming at a new point in time and the MKConductor has just seeked.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
conductorWillSeek:\
\pard\tx7140\li3620\fi-1020\ql\qnatural

\f1\b0 \cf0 - 
\f0\b conductorWillSeek:
\i\b0 sender
\i0\b  \
\pard\tx7140\li2100\ql\qnatural
\cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 This method is sent to the delegate (if it responds to it) when MIDI time code starts coming at a new point in time and the MKConductor is about to  seek.\
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
\pard\tx3120\tx3620\tx4120\li2620\ql\qnatural

\b0 \cf0 \
\pard\tx7140\li2100\ql\qnatural

\b \cf0 \
\
}
