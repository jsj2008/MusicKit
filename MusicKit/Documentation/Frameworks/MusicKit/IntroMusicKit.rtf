{\rtf0\ansi{\fonttbl\f0\froman Times-Roman;\f1\ftech\fcharset2 Symbol;\f2\fswiss Helvetica;
}
{\colortbl;\red255\green255\blue255;}
\paperw16220\paperh12580
\pard

\f0\fs24 \cf0 Release 4.0  Copyright 
\f1 „
\f0 1993 by CCRMA, Stanford University.  All Rights Reserved.\
\
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\fs16 \cf0 \

\fs28 \

\fs16 \

\fs28 \

\fs16 \
\pard\ql\qnatural

\i\fs88 \cf0 Music Kit\

\fs16 \
\
\
\
\
\
\
\
\pard\tx5640\li5640\fi-3540\ql\qnatural

\f2\i0\b\fs28 \cf0 Library:	
\f0\b0 MusicKit.framework, dsp.framework, MKPerformMIDI.framework.  \
	Also, optionally unitgenerators.framework, synthpatches.framework\

\fs16 \

\f2\b\fs28 Header File Directory:	
\f0\b0 /Local/Library/Frameworks/MusicKit.framework/Headers/  \
	/Local/Library/Frameworks/synthpatches.framework/Headers/\
	/Local/Library/Frameworks/unitgenerators.framework/Headers/\
	/Local/Library/Frameworks/dsp.framework/Headers/\

\fs16 	\

\f2\b\fs28 Import:	
\f0\b0 MusicKit/MusicKit.h.  \
	Also, optionally, synthpatches/synthpatches.h and unitgenerators/unitgenerators.h\

\fs16 \
\pard\li100\ql\qnatural

\f2\b \cf0 \
\
\
\
\

\fs52 Introduction\

\fs16 \
\
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 The Music Kit defines a set of Objective C classes and informal protocols, C functions, and assorted constants and data types that are useful for creating music, sound, DSP and MIDI applications under NeXTSTEP. \

\fs16 \
\pard\tx2480\tx2860\tx3240\li2480\fi-380\ql\qnatural

\fs28 \cf0 ∑	The Music Kit provides a set of  music representation classes–most notably 
\b MKNote
\b0 , 
\b MKPart
\b0  and 
\b MKScore
\b0 , as well as 
\b MKEnvelope
\b0 , 
\b MKWaveTable
\b0 , 
\b MKTimbre
\b0 , and 
\b MKPartials
\b0 –that provide a flexible high-level structure for musical data.  The Music Kit also provides a number of file formats for storing these structures.  
\i ScoreFile
\i0  is a simple text-based scripting language that allows musical data to be represented in a convenient, human-readable form and supports simple programming structures.  Alternatively, the Music Kit supports reading and writing musical data as Standard MIDI files, binary scorefiles (called 'playscore files' for historical reasons) and NeXTSTEP archived objects.   The Music Kit's representation system includes a number of enormously valuable features.  The noteTag construct supports representation of phrase structure and makes it easy to  create effects such as legato, which require continuity from one note to the next.  The noteUpdate construct allows any aspect of a sounding note to be changed at any time.  \

\fs16 \

\fs28 ∑	The Music Kit makes scheduling and sequencing extremely simple.  A Music Kit "performance" consists of sending scheduled Objective-C messages and handling asynchronous events such as incoming MIDI and NeXTSTEP events.  The 
\b MKConductor
\b0  class is in charge of dispatching all messages and managing the notion of time.  A Conductor may have a tempo, a time map, or may be set to synchronize to MIDI time code.  Since all time control is managed in the Conductor itself, the difference between these time representations is completely transparent.  \
		Another aspect of the Music Kit performance is a dynamically patchable Note-handling network consisting of three classes, 
\b MKPerformers
\b0 , 
\b MKNoteFilters
\b0  and 
\b MKInstruments
\b0 .  
\b MKPerformer
\b0  subclasses are Note-generators, that sequence over Lists of 
\b MKNotes
\b0  or create 
\b MKNotes
\b0  on the fly.  They contain outputs that may be connected to 
\b MKNoteFilters
\b0  or Instruments.  Instrument subclasses realize Notes in some manner, for example by playing them on the DSP or via MIDI, and contain inputs that may be connected to 
\b MKNoteFilters
\b0  or 
\b MKPerformers
\b0 .   
\b MKNoteFilters
\b0  are intermediate processors that contain both inputs and outputs.  This scheme makes it easy to create a performance scheme for nearly any application.   The inputs and outputs are represented as 
\b MKNoteSenders 
\b0 and 
\b MKNoteReceivers
\b0 ,
\b  
\b0 respectively.\
		The Music Kit's performance apparatus is based on the notion that messages execute quickly.   Thus, time stays constant during the execution of a scheduled or event-triggered message.  This has the advantage of allowing a large number of DSP updates to happen at the exact same time.  The DSP and MIDI driver support time-ordered queues of events, thus allowing the application some latitude in computing these updates, while still providing an instantaneous execution of the updates themselves.\
\
∑	The Music Kit has extensive support for sound processing and synthesis on multiple DSP chips.  Instances of the 
\b MKOrchestra
\b0  class correspond to DSP chips and manage dynamic memory and processing time allocation.  Full dynamic loading during a performance is supported.  Synthesis insruments are represented as 
\b MKSynthPatch
\b0  subclasses.  The Music Kit SynthPatch library is an auxiliary library that consists solely of 
\b MKSynthPatch
\b0  subclasses, each of which implements a generic synthesis technique.   For developers or composers who want to create their own synthesis or processing configuration, the 
\b MKUnitGenerator
\b0  class is provided.  Each 
\b MKUnitGenerator
\b0  subclass corresponds to  a DSP module such as a filter, oscillator, or delay unit.  By interconnecting these 
\b UnitGenerators
\b0  using "patchpoints", a huge variety of synthesis and processing techniques may be implemented.  The Music Kit UnitGenerator library is an auxilliary library that consists solely of 
\b MKUnitGenerator
\b0  subclasses.  Finally, adventurous developers may write their own DSP unit generators in DSP56001 assembly language (using an extensive set of macros to simplify the process) and use the tool 
\b dspwrap
\b0  to automatically generate Objeictive-C UnitGenerator  subclasses.\
		Currently, only the DSP56001 is supported.  The 
\b ArielQP 
\b0 and 
\b ArielQPSat
\b0  classes support the Ariel QuintProcessor hardware, available for the NeXTcube.\
\pard\li2100\ql\qnatural

\f2\b\fs48 \cf0 \
Music Kit Classes\

\fs16 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 The following sections briefly describe the topics that the Kit addresses through its classes and protocols.  Within the descriptions, class and protocol names are highlighted as they're introduced for easy identification.\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\
\

\f2\b\fs36 Encapsulating Musical Data\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 Music is represented in a three-level hierarchy of 
\b MKScore
\b0 , 
\b MKPart
\b0 , and 
\b MKNote
\b0  objects.  
\b MKScores
\b0  and 
\b MKParts
\b0  are analogous to orchestral scores and the instrumental parts that they contain:  a 
\b MKScore
\b0  represents a musical composition while each 
\b MKPart
\b0  corresponds to a particular means of realization.  
\b MKParts
\b0  consists of a time-sorted collection of 
\b MKNotes
\b0 , each of which contains data that describes a musical event.  \
\
The information in a 
\b MKNote
\b0  object falls into four categories:\
\
∑	 A list of attribute-value pairs called 
\b parameters
\b0  that describe the characteristics of a musical event\
∑	 A noteType that determines the general character of the Note\
∑	 An identifying integer called a noteTag, used to associate different Notes with each other\
∑	 A timeTag, or the onset time of the Note\
\
A parameter supplies a value for a particular attribute of a musical sound, its frequency or amplitude, for example.  A parameter's value can be simple–an integer, floating point number, or character string–or it can be another object.  The Note object provides special methods for setting the value of a parameter as an 
\b MKEnvelope
\b0  object or a 
\b MKWaveTable
\b0  object.  With the 
\b MKEnvelope
\b0  object you can create a value that varies over time.  The 
\b MKWaveTable
\b0  object contains sound or spectrum data that's used in various types of synthesis, such as wavetable synthesis.\
\
The manner in which a parameter is interpreted depends on the object that realizes the 
\b MKNote
\b0 .  For example, one object could interpret a heightened brightness parameter by increasing the amplitude of the sound, while another, given the same 
\b Note
\b0 , might increase the sound's spectral content.  In this way, parameters are similar to Objective-C messages:  The precise meaning of either depends on how they are implemented by the object that receives them.\
\
A Note's noteType and noteTag are used together to help interpret a 
\b MKNote
\b0 's parameters.  There are five noteTypes:\
\
∑	 noteDur represents an entire musical note (a note with a duration) \
∑	 noteOn establishes the beginning of a note \
∑	 noteOff establishes the end of a note \
∑	 noteUpdate represents the middle of a note \
∑	 mute represents a Note not directly associated with sound-production\
\
noteDurs and noteOns both establish the beginning of a musical note.  The difference between them is that the noteDur also has information that tells when the note should end.  A note created by a noteOn simply keeps sounding until a noteOff comes along to stop it.  In either case, a noteUpdate can change the attributes of a musical note while it's sounding.  The mute noteType is used to represent any additional information, such as barlines or rehearsal numbers.\
\
A noteTag is an arbitrary integer that's used to identify different Notes as part of the same musical note or phrase.  For example, a noteOff is paired with a noteOn by matching noteTag values.  You can create a legato passage with a series of noteOns, all with the same noteTag, concluded by a single noteOff.\
\
The Music Kit's noteTag system solves many of the problems inherent in MIDI, which uses a combination of key number and channel to identify events that are part of the same musical phrase.  For example, the Music Kit can create and manage an unlimited number of simultaneous legato phrases while MIDI can only manage 16 (in MIDI mono mode).  Also, with MIDI's tagging system, mixing streams of notes is difficult–notes can easily get clobbered or linger on beyond their appointed end.  The Music Kit avoids this problem by reassigning unique noteTag values when streams of Notes are mixed together.\
\
A 
\b MKNote's
\b0  timeTag is relevant only when the 
\b MKNote
\b0  is in a 
\b MKPart
\b0 –it specifies the time of the Note relative to the start of its 
\b MKPart
\b0 .  timeTag values are measured in beats, where the value of a beat can be set by the user.  If the 
\b MKNote
\b0  is a noteDur, its duration is also computed in beats.\
\
An entire 
\b MKScore
\b0  can be stored in a scorefile.  The scorefile format is designed to represent any information that can be put in a Note object, including the Part to which the Note belongs.  Scorefiles are in ASCII format and can easily be created and modified with a text editor.  In addition, the Music Kit provides a language called 
\i ScoreFile
\i0  that lets you add simple programming constructs such as variables, assignments, and arithmethic expressions to your scorefile.\
\pard\li2100\ql\qnatural
\cf0 \
\pard\li2100\ql\qnatural

\f2\b\fs16 \cf0 \
\pard\li2100\ql\qnatural

\fs36 \cf0 Note and Event Scheduling, Sequencing and Processing\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 During a Music Kit performance, 
\b MKNote
\b0  objects are dispatched, in time order, to objects that realize them in some manner–usually by making a sound on the DSP or on an external MIDI synthesizer.  This process involves, primarily, instances of 
\b MKPerformer
\b0 , 
\b MKInstrument
\b0 , and 
\b MKConductor
\b0 :\
\
∑	 A 
\b MKPerformer
\b0  acquires 
\b MKNotes
\b0 , either by opening a file, looking in a 
\b MKPart
\b0  or 
\b MKScore
\b0 , or generating them itself, and sends them to one or more 
\b MKInstruments
\b0 .  Pseudo-performers such as 
\b MKMidi
\b0  or the application itself may act as 
\b MKPerformers
\b0 , supplying 
\b MKNotes
\b0  in response to asynchronous events.\
\
∑	 An 
\b MKInstrument
\b0  receives 
\b MKNotes
\b0  sent to it by one or more 
\b MKPerformers
\b0  and realizes them in some distinct manner.\
\
∑	 The 
\b MKConductor
\b0  acts as a scheduler, ensuring that 
\b MKNotes
\b0  are transmitted from 
\b MKPerformers
\b0  to 
\b MKInstruments
\b0  in order and at the right time.\
\
This system is useful for designing a wide variety of applications that process 
\b MKNotes
\b0  sequentially.  For example, a Music Kit performance can be configured to perform MIDI or DSP sequencing, graphic animation, MIDI real-time processing (such as echo, channel mapping, or doubling), sequential editing on a file, mixing and filtering of 
\b MKNote
\b0  streams under interactive control, and so on.\
\
Both 
\b MKPerformer
\b0  and 
\b MKInstrument
\b0  are abstract classes.  This means that you never create and use instances of these classes directly in an application.  Rather, they define common protocol (for sending and receiving 
\b MKNotes
\b0 ) that's used by their subclasses.  The subclasses build on this protocol to generate or realize 
\b Notes
\b0  in some application-specific manner.\
\
The Music Kit provides a number of 
\b MKPerformer
\b0  and 
\b MKInstrument
\b0  subclasses.  The principle 
\b MKPerformer
\b0  subclasses are:\
\
∑	 
\b MKScorePerformer
\b0  and 
\b MKPartPerformer
\b0 .  These read Notes from a designated
\b  MKScore
\b0  and 
\b MKPart
\b0 , respectively.  
\b MKScorePerformer
\b0  is actually a collection of 
\b MKPartPerformers
\b0 , one for each 
\b MKPart
\b0  in the 
\b MKScore
\b0 .\
\
∑	 
\b MKScorefilePerformer
\b0  reads a scorefiles, forming 
\b MKNote
\b0  objects from the contents of the file.  It's only advantage over 
\b MKScorePerformer
\b0  is that there is no memory-resident representation of the 
\b MKScore 
\b0 is used.  Thus, it can instantaneously perform huge 
\b MKScores 
\b0 that would require some time to read into a 
\b MKScore
\b0 .\
\
∑	 
\b MKMidi
\b0  (a pseudo-Performer) creates 
\b MKNote
\b0  objects from the byte stream generated by an external MIDI synthesizer attached to a serial port.\
\
The 
\b MKInstrument
\b0  subclasses provided by the Music Kit are:\
\
∑	 
\b MKSynthInstrument
\b0  objects realize Notes by synthesizing them on the DSP.\
\
∑	 
\b MKMidi
\b0  (a pseudo-Instrument) turns 
\b MKNote
\b0  objects into MIDI commands and sends the resulting byte stream back out to an external MIDI synthesizer connected to a serial port.\
\
∑	 
\b MKScoreRecorder
\b0  and 
\b MKPartRecorder
\b0  receive Notes, copy them, and add them to a 
\b MKScore
\b0  and 
\b MKPart
\b0 , respectively.\
\
∑	 
\b MKScorefileWriter
\b0  writes scorefiles on the fly during a performance.  It is analagous to 
\b MKScorefilePerformer
\b0 .\
\
∑	 
\b MKNoteFilter
\b0  is a subclass of Instrument that also implements 
\b MKPerformer
\b0 's 
\b MKNote
\b0 -sending protocol, thus it can both receive and send 
\b MKNotes
\b0 . Any number of 
\b MKNoteFilter
\b0  objects can be interposed between a 
\b MKPerformer
\b0  and an 
\b MKInstrument
\b0 .  
\b MKNoteFilter
\b0  is, itself, abstract. The action a 
\b MKNoteFilter
\b0  object takes in response to receiving a 
\b MKNote
\b0  is defined by the subclass.  For example, you can create a 
\b MKNoteFilter
\b0  subclass that creates and activates a new 
\b MKPerformer
\b0  for every 
\b MKNote
\b0  it receives.\
\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 DSP Synthesis\
\
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\fs28 \cf0 MKOrchestra 
\b0 handles all allocation and DSP time management.  
\b MKSynthInstrument 
\b0 is a voice allocator and manages instances of 
\b MKSynthPatch
\b0 , each of which representes a single sound-producing/processing voice on the DSP.   
\b MKSynthPatches 
\b0 are comprised of 
\b MKUnitGenerators
\b0 , basic building blocks of DSP synthesis, as well as 
\b MKSynthData
\b0 , DSP memory objects.   The Music Kit provides an extensive set of 
\b MKSynthPatch 
\b0 and 
\b MKUnitGenerator 
\b0 subclasses, in the 
\b MKSynthPatch 
\b0 and 
\b MKUnitGenerator 
\b0 libraries, respectively.\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 \
\pard\li2100\ql\qnatural

\fs16 \cf0 \

\fs48 Music Kit Functions\

\fs16 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 The ™Functions∫ section, later in this chapter, describes the functions (and function-like macros) that are provided by the Music Kit.  Many of the functions are auxiliary to the Kit's classes in that they augment or are superceded by one or more classes.  Of the rest, some functions provide information or functionality that can't be gotten elsewhere, while some others are convenient but not necessarily the only way to address a particular topic.  \

\fs16 \

\fs28 The following sections don't attempt to describe what individual functions do–the names of the functions are fairly descriptive in themselves–they merely list the functions as they fall into broad categories.\

\fs16 \
\pard\li2100\ql\qnatural

\f2\b \cf0 \
\
\pard\li2100\ql\qnatural

\fs36 \cf0 Amplitude Scaling\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 These functions convert between MIDI and Note amplitude representations:\

\fs16 \

\fs28 MKAmpToMidi(), MKAmpAttenuationToMidi(), MKMidiToAmp(), MKMidiToAmpAttenuation(), MKMidiToAmpWithSensitivity(), MKMidiToAmpAttenuationWithSensitivity(), MKdB()\
\pard\tx2480\tx2860\tx3240\li2480\fi-380\ql\qnatural
\cf0 \
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 Frequency Scaling\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 These functions convert between MIDI and Note frequency representations:\

\fs16 \

\fs28 MKKeyNumToFreq(), MKFreqToKeyNum(), MKTranspose(), MKAdjustFreqWithPitchBend()\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 Error Handling and Trace Debugging\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKError(), MKSetErrorProc(), MKSetErrorStream(), MKErrorStream(), MKSetTrace(), MKClearTrace(), MKIsTraced()\
\pard\li2100\ql\qnatural

\f2\b\fs16 \cf0 \
\pard\li2100\ql\qnatural

\fs36 \cf0 Time Manipulation\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKGetTime(), MKGetDeltaT(), MKSetDeltaT(), MKGetDeltaTTime(), MKFinishPerformance(), MKSetTime(), MKSetLowDeltaTThreshold(), MKSetHighDeltaTThreshold(), MKSetDeltaTMode(), MKGetDeltaTMode\

\fs16 \
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 No-Value Return from Floating Point Functions
\fs16 \
\
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKIsNoDVal(), MKGetNoDVal()\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 Note Parameter Access\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKIsNoteParPresent(), MKInitParameterIteration(),  MKNextParameter(), MKHighestPar()\
\pard\li2100\ql\qnatural
\cf0 MKSetNoteParToDouble(), MKSetNoteParToInt(), MKSetNoteParToString(),  MKSetNoteParToEnvelope(), MKSetNoteParToWaveTable(), MKSetNoteParToObject(), MKGetNoteParAsDouble(),  MKGetNoteParAsInt(), MKGetNoteParAsString(),  MKGetNoteParAsStringNoCopy(), MKGetNoteParAsEnvelope(), MKGetNoteParAsWaveTable(), MKGetNoteParAsObject()\
\

\f2\b\fs36 Named Objects\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 These functions differ from the NeXTSTEP versions in being stored in a separate symbol table.\
\
 MKNameObject(),MKGetObjectName(), MKRemoveObjectName(), MKGetNamedObject()\
\pard\li2100\ql\qnatural

\f2\b\fs16 \cf0 \
\pard\li2100\ql\qnatural

\fs36 \cf0 Message Scheduling\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKNewMsgRequest(), MKScheduleMsgRequest(), MKRepositionMsgRequest(), MKCancelMsgRequest(), MKRescheduleMsgRequest()\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 NoteTag Allocation
\fs16 \
\
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKNoteTag(), MKNoteTags()\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 Posing As–Class Substitution\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKSetNoteClass(), MKSetPartClass(), MKSetEnvelopeClass(), MKSetPartialsClass(), MKSetSamplesClass(), MKGetNoteClass(), MKGetPartClass(), MKGetEnvelopeClass(), MKGetPartialsClass(), MKGetSamplesClass()\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 Note Preemption\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKSetPreemptDuration(), MKGetPreemptDuration()\
\
\pard\li2100\ql\qnatural

\f2\b\fs36 \cf0 Scorefile Parsing and Writing\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKSetScorefileParseErrorAbort(), MKWritePitchNames() \
\pard\li2100\ql\qnatural

\f2\b\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\fs36 \cf0 UnitGenerator Implementation\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKSetUGAddressArg(),  MKSetUGAddressArgToInt(), MKSetUGDatumArg, MKSetUGDatumArgLong()\
\pard\li2100\ql\qnatural

\f2\b\fs16 \cf0 \
\pard\li2100\ql\qnatural

\fs36 \cf0 Envelope Handling\
\pard\li2100\ql\qnatural

\fs16 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 MKUpdateAsymp()\

\fs16 \
\pard\li2100\ql\qnatural

\f2\b\fs48 \cf0 \
\pard\tx2480\tx2860\tx3240\li2100\ql\qnatural

\f0\b0\fs28 \cf0 \
\pard\li2100\ql\qnatural

\f2\b\fs16 \cf0 \
\
}
