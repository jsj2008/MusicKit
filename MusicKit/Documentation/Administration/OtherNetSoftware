An updated version of this document is available via the World Wide Web at:

<http://www.eecs.umich.edu/~mrozek/nextmusic/NxtSndMusProgs.html>

------------------------------------------------------
The following is a rather old version:

The descriptions listed below are culled from the README files,
"help" or "info" statements, etc., of their respective programs.
I've gathered these programs over the past 6 months, so they
may have been updated, or added new features, etc.,  since I
collected them.

NxtSndMusProgs_Drft0.1
NextSound&Music Programs
Draft 0.1  (Last Updated 7-15-92)

Please send suggested revisions, corrections, suggested inclusions, notice of
omissions, etc. to sullivan@msu.edu (.rtf and .wp versions are available
on request)

Table of Contents

AudioChallenger
Bessie
Chaos
Cmix
CommonLispMusic
CommonMusic
Csound
EdSndP
Ein
EnvelopeEd
Fugue
Just
LPC
MediaStation
MixView
Music 4C
Patchmix
Resample
ResoLab
RT
RTLisp
ScorePlayer
SE
Snd
SoundWorks
Sonogram
Spasm
Spectro
StochGran
SynthBuilder
SuperPlay
Tuner




AudioChallenger

Audio Challenger randomly generates ascending and descending melodic
musical intervals which can be used in assisting music students in
trying to improve their ability to aurally identify (single isolated)
musical intervals.   Audio Challenger features real-time synthesis
on the DSP (digital signal processing) chip of the NeXT computer
which gives it the advantage of a more natural and "lively" musical
timbre than ear-training programs that currently exist on other
platforms.

Audio Challenger is released as FREEware to the internet archives
by the researchers and students of DREAMS:  Digital Research (in)
Electro-AcousticMusic (at) Skidmore College.

AudioChallenger is available free, via anonymous ftp
(pub/music/AudioChallenger.tar.Z at princeton.edu).




Bessie

Bessie is a real-time interactive tutorial for learning about
Frequency Modulation Synthesis.  All of the sliders in the application
are connected to the Digital Signal Processing chip (DSP) in the
NeXT computer.  Changing a slider changes the corresponding parameter
of the Frequency Modulation instrument and the results can be heard
immediately.  Tutorial sessions and a glossary of terms are included.

Bessie is available free, via anonymous ftp
(pub/music/Bessie.tar.Z at princeton.edu).



Chaos

This program allows simple experimentation with three nonlinear
dynamical systems as generators of raw musical materials.  Sound
production is either by the DSP Pluck instrument or via MIDI.
Tuning may be constrained to the twelve-tone equal-tempered system,
or unconstrained across the full frequency spectrum.  The Henon,
Lorenz, and Standard System are the three choices available.
Formulas are supplied.

Chaos is available free, via anonymous ftp
(/pub/next/2.0-release/source/chaos.tar.Z at nova.cc.purdue.edu)


Cmix

A sound synthesis, mixing,and analysis program developed by Paul
Lansky.  Though he has stated he never intended for it (the full,
command-line version) to be used on the NeXT, after finding out
various people were using it on that platform, he prepared a
distribution that can be reliably compiled and run on a NeXT.

The contents of the directories in the cmix distribution are as follows:

    Minc  -- c-like front end data specification language for
        Cmix.  there is a man page on it

    cmd -- a few utility routines, and a mixing program
        fancier.instruments  -- some fairly complex instrument
        examples There are some good examples of Minc scripts in
        this directory.

    filters -- Parks/McClellen and and Elliptical filter program

    head -- routines to create and tune headers

    lib -- library of unit generators

    lpc -- complete lpc system, with instructions

    macros -- some unit generators in macro form

    man -- a bunch of man pages.  read cmix usersub and Minc
        first There are a few things described in the man pages
        which are not included in this distribution.  Write to me
        if you want them.

    model.instruments -- a few simple cmix instrument examples

    objc -- a few unit generators coded in objective c

    sys -- the heart of cmix.  builds the cmix kernel, cmix.o
        and a generic program useful for testing Minc scripts,
        called ctest

    tape.backup -- a nice system for storing soundfiles on
        tape.  Right now it is coded for the exabyte scsi driver.

Cmix is available free, via anonymous ftp
(pub/music/Cmix.NeXT.tar.Z at princeton.edu).


CommonLispMusic

Common Lisp Music (CLM, for lack of a catchier name) is a music
synthesis and signal processing package written primarily in Common
Lisp.  It is aimed at composers who are not interested in
computer-related performance issues or computer assisted improvisation
P there is no support for "real time" interactions.

The CLM instrument design language is a subset of Common Lisp (its
numerical functions, and nearly all its control functions), extended
with a large number of "unit generators": Oscil, Env, Table-Lookup,
and so on.  The instruments can run as straight Common Lisp software,
or be compiled into DSP code and run on the NeXT's built-in 56000.
Since CLM instruments are lisp functions, a CLM note list is just
lisp code that happens to call those functions.  The notes need
not even be in any order.  The actual computation is done one note
at a time, and the results are overlaid, building up the sound note
by note.

CommonLispMusic is available free, via anonymous ftp
(pub/clm.tar.Z at ccrma-ftp.stanford.edu).


CommonMusic

Common Music is a score generating language. Its output is a
scorefile containing the description of all the notes that comprise
all or part of a music composition. A separate sound synthesis
program is used to translate the scorefile to sound. Common Music
is written in Common Lisp and the Common Lisp Object System (CLOS),
and is a music composition oriented extension to the Common Lisp
environment.

Common Music is available free, via anonymous ftp
(pub/cm.tarfile.Z at ccrma-ftp.stanford.edu).


Csound

The programs making up the Csound system have a long history of
development, beginning  with  the Music 4 program written at Bell
Telephone Laboratories in the early 1960's by  Max  Mathews. That
initiated the stored table concept and much of the terminology that
has since enabled computer music researchers to communicate.   With
Music 11 (1973) I took a different tack: the two distinct  networks
of  control  and audio  signal processing stemmed from my intensive
involvement in the preceding years in hardware synthesizer concepts
and design.  This division has been retained in Csound.

Because it is  written  entirely  in  C,  Csound  is  easily
installed  on any  machine running Unix or C.

Realizing music by digital  computer  involves  synthesizing audio
signals with discrete points or samples that are representative of
continuous waveforms.  There are several ways of  doing this,  each
affording a different manner of control.  Direct synthesis  generates
waveforms  by  sampling  a   stored   function representing  a
single cycle;  additive synthesis generates the many partials of
a complex tone,  each  with  its  own  loudness envelope;  subtractive
synthesis begins with a complex tone and filters it.  Non-linear
synthesis uses frequency  modulation  and wave  shaping  to  give
simple  signals complex characteristics, while sampling and storage
of natural sound allows it to be  used at will.

Since comprehensive moment-by-moment specification of  sound can
be  tedious,  control  is  gained  in  two ways: 1) from the
instruments in an orchestra, and 2)  from  the  events  within  a
score.   An  orchestra is really a computer program that can produce
sound, while a score is a body of data  which  that  program can
react to.  Whether a rise-time characteristic is a fixed constant
in an instrument, or a variable of each note in the  score, depends
on how the user wants to control it.

The instruments in a Csound orchestra are defined in a  simple
syntax that  invokes  complex audio processing routines.  A score
passed to this orchestra contains numerically  coded  pitch and
control  information,  in standard  numeric  score  format. Although
many users are content with this  format,  higher  level score
processing  languages  are  often convenient.   The  Scot language
uses simple alphanumeric encoding of pitch and time,  in a fashion
that parallels traditional music notation; its translator produces
a standard numeric score.  The  Cscore  program can expand  an
existing  numeric  score,  according to user-supplied algorithms
written in the C language.  One powerful  score  strategy, then,
is to define a kernel score in Scot, translate it to numeric form,
then expand and modify the data using Cscore before sending it to
a Csound orchestra for performance.

Csound is available free, via anonymous ftp
(pub/NeXTCsound.tar.Z or pub/NeXTCsound.newer.tar.Z at princeton.edu).


EdSndP

EdsndP allows you to view and play soundfiles, as well as perform
some (hopefully) useful editing operations on them.  Its long and
winding history began with SoundEditor by Lee Boynton, which is
included in /NextDeveloper/Examples.  James Pritchett took this
code and added features of his own, resulting in edsnd.  edsnd also
included code by Steven M. Boker for displaying the data as a
spectrogram.  Stephen Master (me) took edsnd and incorporated the
sound objects (DataController and DataView) from Metaresearch, Inc.
In addition, I added a parallel magnified view window, looping
(with dynamic loop adjustment), some sound effects functions
(filtering, echo, reverb, etc.) based on the Metaresearch SNDEffects
object, enveloped cut/copy/paste, etc.  This latest version is what
you now have--edsndP.

EdSndP is available free, via anonymous ftp
(pub/music/NeXTedsndP.tar.Z at princeton.edu).


Ein

ein is a simple interface that makes it easy to implement digital
filters and play input files through them. The results are converted
to sound, and analyzed using the discrete Fourier transform.  The
interface was developed by Paul Lansky, using the  filter  compiler
described by Ken Steiglitz (see his Ein Kleiner Filter Compiler,'' Tech.
Report CS-TR-279-90, Dept. of Computer Science, Princeton Univ., Aug. 1990)

The syntax of ein scripts is basically a description of digital
filter flow diagrams.

The user describes a filter in the  text  window  using  the syntax
of C for everything except the statements defining delay lines (tap
statements).  (An existing script can be read using the Window/Open
menu item, and a new script can be created using the Window/New
menu item.)

ein  is not meant to be anything more than a scratchpad for tinkering
with filter design.  Creating real music with it is going to be
more trouble than it's worth.

Ein is available free, via anonymous ftp
(pub/music/NeXTein.tar.Z at princeton.edu).



EnvelopeEd

This program allows you to graphically edit envelopes or more
general x-y functions. The original purpose of the program was to
edit envelopes in text oriented computer music languages like Common
Music, CLM, cmusic, csound, etc. The problem of interfacing between
text and graphics was solved using the pasteboard of the NeXT
computer. When copy is selected in the graphics envelope view, a
text representation of the envelope is placed in the pasteboard.
When paste is selected, the program parses the text found in the
pasteboard and draws the envelope.

EnvelopeEd is available free, via anonymous ftp
(pub/EnvelopeEd.tar.Z at ccrma-ftp.stanford.edu).



Fugue

Fugue is a language for composition and sound synthesis.  Considerations
and features of Fugue include:  a fully interactive environment
based on Lisp; a language which does not force a high-level
distinction between the "score" and the "orchestra"; support for
behavioral abstraction; the ability to work both in terms of actual
and perceptual start and stop times; and a time and memory efficient
implementation.

Fugue is embedded in a Lisp environment, which provides an interactive
interface, flexibility in manipulating sounds, and a base for
performing other related symbolic processing.  Sounds are first-class
types in Fugue, hence they can be assigned to variables, passed as
parameters, and stored in data structures.  This allows "instruments"
to be implemented as ordinary Lisp functions and eliminates the
orchestra/score dichotomy.

Fugue semantics include behavioral abstraction, motivated by the
idea that one should be able to describe "behaviors" that respond
appropriately to their environment.  For example, stretching a
sound may mean one thing in the context of granular synthesis and
another in the context of sampling.  Fugue allows the programmer
to describe abstract behaviors that "know" how to stretch, transpose,
change loudness, and shift in time.  Transformation operators are
provided on these abstractions.

Composition requires that sounds be placed in time together, in
sequence, and at arbitrary offsets.  Because musical sounds often
have attack and release portions, we make a distinction between
the absolute first and last samples of a sound and the perceptual
start and end to which other sounds should be aligned.

Fugue is implemented in a combination of C and XLisp, extending
XLisp with a new "sound" type.  The use of two languages reflects
our goal to provide an interactive and efficient environment.
Other steps are taken to increase time and memory efficiency,
including multiple sample- rates and lazy evaluation.  Sounds in
Fugue are immutable values, implying that every operation on a
sound must allocate memory for a new sound instead of destructively
altering the old sound.  We avoid this inefficiency though lazy
evaluation; describing the result without actually computing any
samples.  This technique avoids many redundant copy operations but
is completely hidden from the user.

Fugue is a new language that provides high-level operations on
sounds.  Fugue is unique in that is spans a range of computational
tasks from score manipulation to synthesis within a single integrated
language.  Fugue already has an efficient implementation on Unix
workstations.  We intend to improve this further by taking advantage
of virtual copy and mapped file capabilities of the Mach operating
system and the DSP chip on the NeXT computer.  We also plan to
extend Fugue with more sound functions based on NeXT's Sound Kit
and Lansky's Cmix.

Fugue is available free, via anonymous ftp
(pub/music/fugue.tar.Z at princeton.edu;
manual - pub/music/fugueman.ps.Z at princeton.edu).



SynthBuilder

A graphical synth patch editor.  Obtain from ccrma-ftp.stanford.edu
in pub/NeXT/SynthesisTools/.


Just

This application provides a means of exploring  arbitrary tuning
systems using standard representations (pitch, musical interval,
cents, frequency, and ratio), as well as exploiting theoretical
systems such as Just Intonation and N-tone equal temperament.  The
application organizes these features into two main window styles
and a few auxiliary panels. The two window styles:  Keyboard and
Matrix, contain Keys that may be tuned and played with the mouse
or MIDI keyboard.  A Tuning Panel provides controls that are used
to tune, play, compare, or change the representation of selected
keys.

The user may also play standard NeXT and MIDI score files.  These
scores may be retuned from tuning information in Keyboard or Matrix
Windows.

Keyboard windows contain an arbitrary number of marimba style keys.
Keys are sounded by clicking with the mouse.  Multiple keys may be
selected at one time.  This is useful for listening to chords, or
examining relationships within a subset of a tuning.

Keys are moved within or between Keyboards with the standard cut,
copy, and paste mechanisms. Each Key may be tuned and presented in
a variety of representation styles:

    Pitch
    Cents Relative to a Reference Key
    Cents Relative to the Previous Key
    Hertz
    Ratio Relative to a Reference Key
    Ratio Relative to the Previous Key
    Interval from Reference Key
    Interval from Previous Key
    MIDI Key Number
    User Label (arbitrary names, i.e Do, Re, Mi)

There are two types of Matrices available: Transpositional and
Extended Just. Each presents a palette of ratios to be used in the
formation of new Keyboards, although representation is not restricted
to ratios. Any of the above tuning representations may be used.

A Transposition matrix is formed by selecting two keyboards as
axes, and creating a matrix consisting of each keyboard transposed
by each step of the other.

An Extended Just Matrix also provides a system of ratios. Each axis
represents powers of a specified ratio, reduced and brought to
within an octave of the origin (1/1),  which is centered in the
matrix.

The Tuning Panel is the mechanism used to tune a key or change its
representation.  Controls in the Tuning Panel are applied to the
last key played. The desired representation or tuning style for
individual Keys or an entire Keyboard/Matrix are chosen with the
Tuning Panel.

Once a tuning is described, it may be used to affect the performance
of a score.  Re-tuning a score is accomplished by installing a
Keyboard's tuning as the default tuning system for Musickit
performance. A score may be heard with a variety of tunings by
installing those from different Keyboards.

Just is available free, via anonymous ftp
(pub/music/NeXT.Just.tar.Z at princeton.edu).



LPCView

An interactive environment for editing and viewing LPC and pitch
analysis files

LPCView is available free, via anonymous ftp
(pub/music/LPCView.tar.Z at princeton.edu).



MediaStation

The application combines the power of a traditional database with
advanced multimedia technology.  It can be used to add pictures to
personnel records, or music to a teaching file, or maps and animations
to an interactive training system.  In other words, it lets you
capture, search, and organize data from multiple media, and then
generate reports and presentations  --  all in one coherent
application.

MediaStation supports high-resolution image scanning, CD-quality
sound recording and editing, frame-by-frame animation, and DSP
audio devices.  Plus it can function as a multimedia file server
over a high-speed Ethernet network, complete with password protection.

MediaStation is a commercial product produced by Imagine Multimedia,
Inc. and available from sources like NeXTConnection.



MixView

Mixview is an interactive, graphics-based soundfile editing program.
It will eventually incorporate all cmix sound-processing routines.
It is built on the X Window System library and the lxt toolkit,
designed by Roger Davis.  Mixview is mapped to the screen as two
windows-a waveform display window and a control panel window. The
display window shows the soundfile at the current vertical and
horizontal resolution, and above this is a menu bar with seven
pulldown menus.  An additional menu is popped up using the right
mouse button in the display window.  The control panel window is
divided into two subpanels, the first with scrolling/paging controls
and displays, and the second with display resolution controls and
additional function buttons.

After the windows are both located on the screen, the display window
may be resized at will, using whatever resizing technique your
window manager uses. You must also then use the resize button to
update the display (see below).

Mixview expects to find an environmental variable called SFDIR,
which is set to the directory in which you keep your soundfiles.
SFDIR can be the top of a tree containing several soundfile subdirs
if so desired.  If no SFDIR variable is found, the current working
dir is searched for soundfiles.

Mixview requires three mouse buttons to function.  If you are
working with a machine and server that provide no button 3 action,
contact me at the following email address, and I will probably
arrange a workaround in mixview. I have tested mixview under both
twm and uwm window managers.  The version of twm in X11R3 is flawed
and will not work with mixview.  X11R4 is fine.

Mixview is designed to read 16-bit short integer and 32-bit floating
point soundfiles with either the BSD soundfile header (as used and
generated by csound and cmix) or, if you are working on a NeXT,
the NeXT soundfile header.  On NeXT workstations and SPARC workstations
with audio capability, 8-bit mulaw encoded (CODEC) soundfiles may
also be read in, where they are CONVERTED AUTOMATICALLY to 16-bit
files.  These may also be played back on these machines.

Mixview is available free, via anonymous ftp
foxtrot.ccmrc.ucsb.edu (128.111.92.30).



Music 4C

Music 4C (M4C) was written in 1985 by Scot Aurenz at the University
of Illinois at Urbana-Champaign and is closely related to Music
4BF, a music program  written in the late 1960's by Godfrey Winham
and Hubert Howe at Princeton University. Whereas 4BF was written
entirely in Fortran and employs instrument  definitions written in
Fortran, M4C is written in C for a Unix environment and  employs
instrument definitions written directly in C.

Instrument definitions correspond to separate C modules which are
called 'instrument files'.  A separate 'orchestra file' in C is
used initialize their use in event-list score files. Then the
orchestra file, instrument files, and the M4C library are linked
together to form an executable called m4c.xxx (.i.e., xxx is up to
the user). An M4C job is run as follows:

    m4c.xxx [-NH] soundfile.snd scorefile.sc >& listing.list

where -NH puts a NeXT header on the soundfile.  Instead of typing
this line in, a user can use the interactive script program 'gom4c'
(monaural job) or'gom4c2'.  A scorefile generally looks like this:

    I(Voice<start-time><duration>){<oct.pitch><ampl.>[<otherparameters>]}
    ......
    ......
    End

The Music 4C package comes with several subdirectories.  The src
directory contains the M4C source programs.  When compiled, the
corresponding object files appear in subdir 'obj'.  A startup
orchestra called 'm4c.class' is compiled in subdir 'classorch'.
It is suggested that the beginning user experiment with this first.
Complete instructions for using the class orchestra are given in
'M4C_intro.txt' under subdir 'doc'.  The doc subdir also contains
documentation on the M4C unit generator family and other programs
used with M4C.  The 'util' subdirectory contains commands which
facilitate the use of M4C, and this directory should be in the
user's path.  The 'instru' subdirectory gives examples of instrument
design.

Two utilities which facilitate use of Music 4C are 'insdes' and
'notepro'.  insdes, written in yak, makes it easier to code
instruments in C, since it allows the structures necessary for the
full C version to omitted.  The resulting code in a .t (or template)
file is very easy to write and read.  The M4C_intro.txt file contains
a tutorial on instrument design, and insdes.txt is a manual for
the use of insdes.

notepro is a preprocessor coding scheme which makes it easy to
enter transcriptions of written music.  Here is an example of
notepro code:

    'Pluck-voice' T120 pp < A. B/ Co D// E// ff F

Explanation:  Instrument 'Pluck-voice' at tempo 120 starting at
pianissimo beginsa crescendo over a dotted quarter note A, followed
by an eighth note B, followed by a half-note C, two sixteenths (D
and E), arriving at a fortissimo quarter note F.  notepro allows
complex rhythmic structures, crossrhythms, gradual tempo changes,
microtonality, and many other features.

At UIUC Music 4C is currently running on the following computers:
NeXT,  Silicon Graphics Iris, IBM RS-6000, IBM PC RT, Convex, and
Cray Y-MP.

For information on acquiring Music 4C contact Jim Beauchamp at
j-beauchamp@uiuc.edu.



PatchMix

Patchmix  is a graphical interface to the Cmix Programming Language.
Within it, you can create and test Cmix instruments.  Since the
code for the instrument is written out to a specified directory,
you can then work with this code later and modify it as you wish.
Patchmix can be helpful either to someone learning Cmix or to
quickly put together instruments, which could then be alter as you
see fit.  To run it, you need Cmix installed in the directory
specified in your file information window. Send any bugs, suggestions
or comments to ta-mmh@cunixb.cc.columbia.edu.

Patchmix is available free, via anonymous ftp
(pub/music/Patchmix1.1.tar.Z at princeton.edu).



Resample

Programs pertaining to sampling-rate conversion on the 68030/40.
They use 32-bit fixed-point arithmetic: 16-bits data and 16-bits
coefficients.

contents:

    resample        Sampling-rate conversion program

    resample.1      Manual page for resample.
                    Try "nroff -man resample.1 openfile"

    testscript      Shell script for testing the resample program

    windowfilter    Program for designing FIR digital filters
                    used by resample

    windowfilter.1  Manual page for windowfilter

    testFilter      Shell script for testing a filter written
                    by windowfilter

    i.snd           Sound file containing an "impulse" used to
                    test filters

    testFilter.ma   Mathematica file for displaying filter test results

    HQFilter.ma     Test results for the "resample -aaa" default filter

    LQFilter.ma     Test results for the default filter without
                    the -aaa option

    sndstrip        Utility for stripping leading and trailing
                    zeros in a .snd file

    toascii         Utility for converting a sound file to an
                    ascii file (for MMA)

    tosnd           Utility for converting an ascii data file
                    to a sound file

    tomono          Utility for converting a stereo sound file
                    to a mono sound file

Resample is available free, via anonymous ftp
(pub/resample.tar.Z at ccrma-ftp.stanford.edu).



ResoLab

A real-time interactive DSP source and filter controller.  The
application allows the user to experiment with the parameters of
a three-resonance (6 pole) filter.  The source and filter model is
commonly used to simulate the human vocal tract mechanism.

ResoLab is available free, via anonymous ftp
(pub/ResoLab2.1.tar.Z at ccrma-ftp.stanford.edu).



RT

rt is a program which allows the user to play arbitrary parts of
many soundfiles in arbitrary order, and at the same time, i.e. mix
them.  Up to 256 different soundfiles can be accessed and up to 8
can be played simultaneously.  Note, however, that due to disk and
processor limitations that the maximum aggregate throughput is
about 400k bytes a second, which means that the user is limited to
8 22k mono files, or 4 22k stereo files, or 2 44k stereo files,
etc.,  or any combination of these which lie within the throughput
limits (e.g. 2 22k stereo files and one 44k stereo file simultaneously).
Undoubtedly these conditions will improve in the future.   (Under
certain conditions disk caching may make it possible to exceed
these limitations, but it is not good to count on this.)

The interface uses the SubProcess object in the NeXTDeveloper
example.  The rt.driver program, operating as a subprocess,  runs
under control of the interface and must be included in the rt.app
directory.

The data is organized in terms of  sounds  and tracks.  A track
can only play one sound at a time (in two channels).  A sound is
an arbitrary part of any soundfile in any format except mu-law.
(22khz and 44khz, mono and stereo).  A segment of a sound played
on a given track at a given time will be referred to as a note.

With this program you can

    1) Mix soundfiles of different sampling rates and of
        different formats (mono and stereo)

    2) Put envelopes on sound segments.

    3) Control gains of left and right channels independently.

    4) Control gains of tracks independently, and alter gains
        over periods of time.

    5) Shift the pitch of a note up or down, continuously or
         instantaneously.

    6) Selectively listen to given tracks.

    7) Save and restore the state of a given mix in an ascii
        data file

    8) Write a mix to disk, or to the DACs, or to the DSP and
        external devices.

With this program you cannot  (yet):

    1) Change the attributes of a mix while it is playing.

    2) Have a gain factor greater than 4.

    3) Play sounds backwards.

    4) Edit soundfiles.

RT is available free, via anonymous ftp
(pub/music/NeXTrt.tar.Z at princeton.edu).



RTLisp

RTLisp runs on David Betz's XLisp and is comprised of a set of
object class and function definitions which provide a Lisp interface
to Paul Lansky's NeXT-based, real-time audio mixing software,
rt'. The rt user arranges audio material temporally, dynamically and
spatially by means of a relatively simple score grammar which is
parsed and executed by rt's audio driver program. RT is wonderful
in that it allows the composer to process, shuffle and mix concrete
sounds interactively and often in real-time. However, the  simplicity
of rt's grammar can make it tedious to use directly, especially
for the realization of complex scores. Also, there is no  provision
for the programmatic generation of audio events, so every event
must be specified in detail by hand.

RTLisp was designed to facilitate the process of rt score creation.
It equips the composer with a powerful, interactive, high-level
programming environment (Lisp), and lends some intelligence to
tasks such as temporal placement and grouping of audio events,
control of dynamics and rt
track' assignment. RTLisp can be thought of as an rt score compiler. It can
run stand-alone in a shell window, controlling the rt audio driver directly,
or it can run in conjunction with rt.app, Mr. Lansky's NextStep interface to
the driver.

RTLisp is available free, via anonymous ftp
(pub/music/rtlisp.tar.Z at princeton.edu).



ScorePlayer

ScorePlayer synthesizes music in real time on the DSP using the
NeXT Music Kit.  ScorePlayer reads documents called "scorefiles".
A number of example scorefiles are provided on /NextLibrary/Music/Scores.
This directory contains both short sound examples (recognized by
the "Examp" filename prefix) and longer musical excerpts.

When you specify a scorefile, ScorePlayer reads it into a Music
Kit Score object.  Then, when you click "Play", ScorePlayer
synthesizes the music on the DSP, using the instruments (Music Kit
objects called Synthpatches) specified in the scorefile. ScorePlayer
also allows you to set the tempo, in beats-per-minute, of the
scorefile before it is played.  The tempo field is initialized to
the tempo value found in the file.  The default tempo (if none is
supplied in the file) is 60 beats-per-minute, i.e. 1 beat-per-second.

The application is included in the Extended System Distribution in
/NextDeveloper/Examples.



SE

The IRCAM Signal Editor (SE) is a general-purpose digital sound
editor that runs on NeXT computers. SE is particularly optimized
for rapid display and editing of large sound files, which SE calls
signal documents. Unlike other sound editors, opening and editing
large documents takes no more time than small documents.  Signal
document navigation is flexible in SE. The program supports an
unusually wide range of scrolling and zooming behaviors, including
continuous scrolling and continuous zooming, as well as precise
and repeatable incremental scrolling and zooming.

Another unique feature of SE is its capacity for "unlimited undo."
SE keeps a history of all editing operations so you can go back to
an earlier point in the editing at any time during a session, and
even across sessions.

SE is supplied with a Scheme interpreter called Elk as its extension
language (Laumann 1990). This is to allows developers and users to
extend the functionality of the editor, particularly with respect
to signal processing operations and the undo facility.

SE is distributed with the IRCAM Musical Workstation (IMW) software
package. However, it is not necessary to have the IMW hardware in
order to run SE, since Release 0.9 SE runs on the NeXT's 680X0
microprocessor with no assistance from the Ariel IMW signal processor
board.

SE is available free, via anonymous ftp
(pub/ircam/.tar.Z at ccrma-ftp.stanford.edu).



Snd

A NeXT interface to Barry Vercoe's 'csound' software synthesis
system.  A release formerly known as CSound-NeXT.  A working
knowledge of csound is assumed in the operation of Snd.

The NextStep version, Snd, is available free, via anonymous ftp
(/pub/next/Apps/Snd/Snd1.2.tar.Z at uvaarpa.acc.virginia.edu).



SoundWorks

SoundWorks is a general sound processing program that allows NeXT
users to record, play, edit, and mix CD-quality sounds.  Any sound
supported by the NeXT soundkit can be created, modified, and archived
to disk.

Of central importance is the Recorder window, which contains the
standard tape player buttons for recording, playing and storing
sounds that have been created.  When many sounds are open simultaneously
the name of each sound is placed in the scrolling SoundList for
quick reference.  Each entry in the list acts like a separate file.
Users may manipulate several files at once simply by selecting them
from the list and applying a command.  This scheme allows users to
quickly change sound formats, open, close, save, and play groups
of files.  It also keeps the sounds organized and at a user's
fingertips.

Each sound may also display an Editor window where sound data may
be edited using the standard cut, copy, and paste paradigm.  Several
digital effects, including envelope and pitch adjustment, reverb,
echo and delay, may also be applied to the sound.

Once several sounds have been recorded, edited, and polished, users
can link sounds together to create CD-quality master recordings.
When sounds are linked, they may be mixed into each other or attached
with a specified gap between the sounds.  Any number of tracks may
be combined together in this fashion, allowing users to create and
save multi-track sounds.

SoundWorks is a commercial product produced by MetaResearch and
available from sources like NeXTConnection.



Sonogram: An Acoustic Signal Analyzer / Editor

This program allows you to analyze time-frequency characteristics
of non-stationary signals. It displays "sonogram" 1 two dimensional
density plot of sound energy distribution. X-axis shows time running
from left to right, and Y-axis shows frequency (upper in the graph,
higher the sound ).  It allows you to "see" how a signal sounds
like.

Sonogram allows you to analyze time-varying audio signals such as
a birdsong visually. It uses either FFT ( Fast Fourier Transform
) or Wigner-Ville transform to calculate instantaneous power spectrum
and displays the results as a sonogram - a two- dimentional ( time
and frequency ) density plot of sound energy.  Also, you can do
time and frequency measurements by clicking  and dragging the mouse
inside the sonogram window, and display  the power spectrum curve
at the cursor point in real time. This  program is, in part, based
on EdSnd1.4 by James Pritchett and  Steven Boker and inherits some
signal editing capabilities of EdSnd.

The application is included in the Extended System Distribution in
/NextDeveloper/Examples.



Spasm

Spasm is an application designed to allow experimentation with the
synthesis of singing.  The system uses a physically parameterized
reflection line model to simulate the vocal and nasal tracts.  In
the simulator windows, parameters can be adjusted using sliders,
edited by typing in the text fields, and saved to disk in files.
Various time and frequency domain descriptions and characteristics
of the system are displayed.  Editable features:  Glottis:  Time
Domain Waveform and Spectral Content; Vocal Tract Shape:  Radius
of each Tract Section; Nasal Cavity:  Velum Opening Size; Tract
Turbulence:  Noise Spectrum and Location; Performance Features:
Random and Deterministic Pitch; Diphone Synthesis:  Transition Time
and Curve; Radiation Controls:  Mixture of Throat, Lip, and Nose

Spasm is available free, via anonymous ftp
(pub/SPASM.tar at ccrma-ftp.stanford.edu).



Spectro

Spectro is a spectrum analysis application for the NeXT.   The
program performs frequency transforms on sound data and displays
the resultant spectrum.  This is similar to passing light through
a prism, which splits it into its component colors.  To really use
and understand all of the features of this program, you should take
Julius Smith's sequence in digital signal processing for music
offered at CCRMA.  Optionally, you might read Xavier Serra's PhD.
dissertation available from CCRMA.

Direct bugs/suggestions in large groups (save up a few before you
mail) to Perry R. Cook prc@ccrma.stanford.edu.

Spectro is available free, via anonymous ftp
(pub/Spectro.Z at ccrma-ftp.stanford.edu).



StochGran

StochGran is an interface to "sgran", a Cmix stochastic granular
synthesis instrument.  sgran generates events made of many grains
of sound.  The parameters grain rate, duration, location and
frequency can be given beginning, ending and variability values,
so the grains will change over the course of the event. The values
are generated by a probability function which allows one to "randomly"
output values between a low and high limits, and which hug a middle
value by a specified amount of tightness.

At this point the additive synthesis version of sgran is implemented.
Versions synthesizing frequency modulated grains and sampled grains
with in-phase correlation are in progress.

The source for both sgran and StochGran can be obtained by anonymous
ftp from princeton.edu (cd /pub/music).  Cmix, Paul Lansky's music
programming language, may be obtained from princeton.edu by anonymous
ftp.  To compile "sgran", you must have cmix installed.

After "sgran" is compiled, link it and cmix commands "sfcreate",
"rescale" and "play" installed or linked into the directory you
will designate in the interface as the cmix directory.  Compile
StochGran, and run it.

Check the man page for sgran if needed to find out how to set
parameters. When you have set the parameters on the main StochGran
window, write out  functions and then write score with the menu
items.  Then run the job.   When you see in the output window it
has finished (it says how many  grains were written), you can
rescale the float sound file.  After it says "done", the sound file
can be played.

Send any questions, bugs or suggestions to mara@woof.columbia.edu,
or ta-mmh@cunixb.cc.columbia.edu.

StochGran is available free, via anonymous ftp
(pub/music/StochGran.tar.Z at princeton.edu).



SuperPlay

A program to play short-integer, mulaw and floating-point soundfiles:

usage: superplay [-s skip time][-d dur][-p peak amp][-f factor][-P output
peak]
        soundfile

Optional arguments
    s = time to skip before beginning to play
    d = amount of time to play
    p = peak amplitude for floating point files
    f = rescaling factor for floating point files
    P = desired peak amplitude for floating point files
           the p,f and P arguments are only applicable
           to floating point files,and the P argument
           requires a peak amplitude in the header or
           a peak specified with -p

SuperPlay is available free, via anonymous ftp
(pub/music/NeXTsuperplay.tar.Z at princeton.edu).



Tuner

Tuner is a software chromatic tuner for determining the musical
pitch of a sound as well as how close that pitch is to the established
value for the note.  Tuner listens on the NeXT's CODEC microphone
input and computes a frequency for the sound it samples.  It maps
this frequency onto a musical note and displays the value.  Then
it looks up the standard value for the note to display the difference
between the standard value and the computed frequency.

The tuner can compute pitch using two different algorithms, by
counting zero transitions and by doing a fast Fourier transformation
(FFT) using the DSP array routines.  You need a relatively simple
waveform for the zero transitions algorithm to work -- some
instruments and voices work better than others.  When it works, it
has a potential accuracy of about +/- 1/4 Hz.   The FFT algorithm
is able to handle more complex waveforms but currently only has a
potential accuracy of about +/- 2 Hz.  (The zero transitions
algorithm works well with recorders and the FFT algorithm works
better with bassoons.)  The potential range of both algorithms is
C00 to B7 and both are further constrained by the limits of the
microphone.

Tuner is ShareWare, if you use it please chip in $7.50 (1/10 the
cost of a real chromatic tuner :-).  Please include an EMail address
with your payment if you're interested in update notices.  There
is no warranty provided with this software -- full sources are
provided and bug reports are welcome:  lane@sumex-aim.stanford.edu

Tuner is available free, via anonymous ftp
(pub/Tuner.tar.Z at ccrma-ftp.stanford.edu).




Known Omissions of Music Software from this Draft Version:

Commercially available applications:

    Presto               MIDI-sequencing and DSP-synthesis software
                         Pinnacle Research  602-529-1135

Applications available via ftp:

ccrma-ftp.stanford.edu:

    edsnd.tar.Z               the princeton sound editor
    GuitarSynthPatch.tar.Z    source for feedback guitar synthpatch
    LispListener.tar.Z        Lisp Interpreter interface window
    Nu.README
    Nu.tar.Z                  music notation application
    VoiceClass.tar.Z          Biblio and C Sources from PRC's Voice Seminar
    ZorroDemo.Z               code from C. Chafe's El Zorro composition.
    cmn.tar.Z                 music notation package based on CLOS and the
                              Sonata font
    pcl.tar.Z                 CLOS (PCL Mayday release)
    fixedpolicy.tar.Z         programming help for real-time perf
    music-kit-class.tar.Z     class notes  on MusicKit programming
    WinFlt.ma.Z
    Kaiser.ma.Z               mathematica notebook on Kaiser windows
    GenHamming.ma.Z           mathematica notebook on Hamming windows
    JeanLaroche.tar.Z         dsp & low-level snd prog examples & doc
    dsp_dma_stream.tar.Z      fast dsp dma prg examples & doc
    ircasm/Animal-3.06.tar.Z  ircam workstation software
    ircasm/cpos-2.1.tar.Z     ircam workstation software
    ircasm/fts-0.17.README    ircam workstation software
    ircasm/fts-0.17.tar.Z     ircam workstation software
    ircasm/xgcc-1.40.tar.Z    ircam workstation software


princeton.edu:

    Iff2ulaw.tar
    MusicKitPianoRoll.tar.Z
    NextEdSnd.Z
    NextEdsnd2.tar.Z
    Nextedsnd14.tar.Z
    NextMouseOrch.tar.Z
    NextOcean.tar.Z
    Ulaw2Iff.tar
    midi-alpha-1.tar.Z
    music-kit-notesplitter-1.2.tar.Z
    strum.tar.Z

uvaarpa.acc.virginia.edu

    LPC.tar.Z
    Mixer.Z
    SoundEditor.Z

nova.cc.purdue.edu

    /pub/next/2.0-release/binaries/MediaView.tar.Z
