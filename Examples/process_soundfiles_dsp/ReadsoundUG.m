/* Copyright CCRMA, 1992.  All rights reserved. */

/* This is a programming example of a UnitGenerator that sends
   a mono soundfile to the DSP, presumably for subsequent processing, in 
   non-real-time. (This example does not use DSP DMA, and thus cannot run 
   in real time.)

   This file was originally generated by dspwrap and then edited.
   dspwrap does not overwrite existing files, so it's safe to run it on this 
   directory.
   */

#import <musickit/musickit.h>
#import <string.h>
#import <appkit/nextstd.h>
#import <soundkit/soundkit.h>
#import "ReadsoundUG.h"

@implementation ReadsoundUG:UnitGenerator
{
    id aSound;               /* The sound we're playing */
    int currentSample;       /* First sample in current buffer */
    int sampleCount;         /* Samples in sound. */
    MKMsgStruct *_msgPtr;    /* Private struct used for rescheduling */
    double _bufferDuration;  /* Duration of buffer in seconds. */
    id _synthData;           /* Privately-allocated data buffer */
    short *_data;            /* Pointer to Sound data. */
}

/* The following two lines are generated by dspwrap */
enum args { aout, pbuf, abuf, ebuf};
#import "readsoundUGInclude.m" 

#define BUFFSIZE 128 /* Size of sound buffer on DSP. Must be a multiple of 16. */

static id clockConductor = nil; /* Cache this */

-_setBuffer:(BOOL)yesOrNo
  /* Private method that allocates or deallocates private SynthData object.
     We allocate and deallocate each time we receive -run. That way, memory
     is not needlessly tied up. When no SynthData is allocated, we patch
     the unit generator to read the "zero" location. */
{
    DSPMemorySpace space = [[self class] argSpace:abuf];
    MKOrchMemSegment segment;
    if (yesOrNo) {
	segment = (space == DSP_MS_X) ? MK_xData : MK_yData;
	_synthData = [orchestra allocSynthData:segment length:BUFFSIZE];
	if (!_synthData) /* Couldn't allocate data buffer */
	  return nil;
	[self setAddressArg:abuf to:_synthData]; /* Start of buffer */
	[self setAddressArg:ebuf toInt:BUFFSIZE + [_synthData address]]; /* End */
	[self setAddressArg:pbuf toInt:[_synthData address]]; /* Reset pointer */
    } else {
	id zero;
	segment = (space == DSP_MS_X) ? MK_xPatch : MK_yPatch;
	zero = [[self orchestra] segmentZero:segment];
	_synthData = [_synthData dealloc];
	[self setAddressArg:abuf to:zero]; 
	[self setAddressArg:ebuf toInt:[zero length] + [zero address]];
	[self setAddressArg:pbuf toInt:[zero address]]; /* Reset pointer */
    }
}

-_nextBuffer
  /* Private method which writes down the next buffer of Sound. */
{
#   define NEXTTIME _msgPtr->_timeOfMsg
    int len;
    if (currentSample >= sampleCount) { /* At the end of the sound? */
	[self _setBuffer:NO];
	return self;
    }
    len = sampleCount - currentSample;  /* Number of samples to send */
    len = MIN(len,BUFFSIZE);            /* Clip to buffer size. */
    [_synthData setShortData:&_data[currentSample] length:len offset:0];
    currentSample += len;
    NEXTTIME = MKGetTime() + _bufferDuration;      /* Reschedule */
    MKScheduleMsgRequest(_msgPtr,clockConductor);  
    return self;
}

-init
  /* Sent by the superclass when the UnitGenerator is created. */
{
    if (![super init])
      return nil;
    clockConductor = [Conductor clockConductor]; /* Cache this */
    _bufferDuration = BUFFSIZE/[orchestra samplingRate];
    return self;
}

-setSound:sound
  /* Sets sound, which is NOT copied. Returns nil if sound is nil or if there's
     a problem, else self. Note that you must send -run after -setSound: to 
     begin reading the new sound. You can abort a sound by sending 
     setSound:nil */
{
    _msgPtr = MKCancelMsgRequest(_msgPtr);/* Cancel old message, if any */ 
    if (!sound ||
	[sound dataFormat] != SND_FORMAT_LINEAR_16 ||
	[sound samplingRate] != [orchestra samplingRate] ||
	[sound channelCount] != 1) {
	if (sound) {
	    char *errMsg = alloca(128);
	    sprintf(errMsg,"Sound must be mono, 16 bit format," 
		    "and with a sampling rate of %f.\n",
		    [orchestra samplingRate]);
	    MKError(errMsg);
	}
	aSound = nil;
	[self _setBuffer:NO];
	return nil;
    }
    aSound = sound;
    sampleCount = [sound dataSize]/sizeof(short);
    _data = (short *)[(Sound *)sound data];            /* Init pointer to sound data */
    return self;
}

-setSoundfile:(char *)file
  /* Same as setSound: but uses a Soundfile. */
{
    id sound;
    if (!file || !strlen(file))  /* Parameter not present? */
      return nil;
    sound = [[Sound alloc] initFromSoundfile:file]; 
    if (!sound) {
	char *errMsg = alloca(128);
	sprintf(errMsg,"Can't open file %s",file);
	MKError(errMsg);
	return nil;
    }
    return [self setSound:sound];
}

-setSamples:aSamples
  /* Same as setSound: but uses a Samples object. */
{
    return [self setSound:[aSamples sound]];
}

-setOutput:aPatchPoint
  /* Set output to the specified patch point. */
{
    return [super setAddressArg:aout to:aPatchPoint];
}

-runSelf
  /* Invoked by -run. Starts the sound on its way. If you send run 
     twice, the sound is retriggered. Note that the message idle
     causes the sound to be 'forgotten'. */
{
    if (!aSound || ![self _setBuffer:YES])
      return nil;
    currentSample = 0;
    _msgPtr = MKCancelMsgRequest(_msgPtr);    /* Cancel old message, if any */ 
    _msgPtr = MKNewMsgRequest(0.0,@selector(_nextBuffer),self,0); /* new msg */
    [self _nextBuffer];                      /* Do first buffer immediately */ 
    return self;
}

-idleSelf
  /* Idling a ReadSound patches its output to Sink (nowhere) and resets
     its sound to nil. */
{
    [self setAddressArgToSink:aout]; /* Patch output to sink. */
    [self _setBuffer:NO];
    aSound = nil;                      /* Forget sound */
    _msgPtr = MKCancelMsgRequest(_msgPtr); /* Cancel old message, if any */
    currentSample = sampleCount = 0;
    return self;
}

-freeSelf
  /* Invoked before the object is freed. Make sure we've cleaned up. */
{
    [self _setBuffer:NO];
    _msgPtr = MKCancelMsgRequest(_msgPtr); /* Cancel old message, if any */
    return self;
}

@end

