
/* Generated by Interface Builder */

#import "SpectrumView.h"
#import <appkit/appkit.h>
#import <math.h>

#define SRATE 22050.0
#define PI 3.141592654782
#define SQRT_TWO 1.414213562
#define TWO_PI 6.283185309564

float back_ground = 0.0/3.0, draw_gray = 3.0/3.0, marker_gray = 1.0/3.0;
float cosines[16384],sines[16384];
int last_length = 0;

@implementation SpectrumView

- setFreqFields:anObject
{
    freqFields = anObject;
    return self;
}

- setLogFreq:anObject
{
    logFreq = anObject;
    return self;
}

- setBackGround: (float) gray
{
    back_ground = gray;
    return self;
}

- setDraw: (float) gray
{
    draw_gray = gray;
    return self;
}

- getPeaks: (int) size array: (float *) array 
		numPeaks: (int) numPeaks locs: (float *) locs gains: (float *) gains
{
    int i,j = 0;
    float last=-12.0,a=0.0,b=0.0,c=0.0,p=0.0;
    boolean_t goin_up=TRUE;
    
    for (i=0;i<numPeaks;i++)	{
	locs[i] = 0.0;
	gains[j] = 0.0;
    }
    for (i=0;(i<size && j<numPeaks);i++)  {
	if (goin_up && (last >= array[i]))	{
	    if (i==1)	{
	        locs[j] = 0.0;
		gains[j] = array[0];
	    }
	    else 	{
	        a = array[i-2];
	        b = array[i-1];
	        c = array[i];
	        p = a - (2 * b) + c;
	        if (p!=0.0)
	            p = (a - c) / p / 2.0;
	        else
	            p = 0.0;
	        locs[j] = (i - 1 + p);
	        gains[j] = b - ((a - c) * p / 4.0);
	    }
	    goin_up = FALSE;
	    j++;
	}
	if (last<array[i])
	    goin_up = TRUE;
	last = array[i];	
    }
    return self;
}

- logLinear
{
    int i;
    if (![logFreq state])
        for (i=0;i<4;i++) [[freqFields cellAt: 0 : i] setIntValue: SRATE * i / 8];
    else	{
        [[freqFields cellAt: 0 : 0] setIntValue: 60];
        [[freqFields cellAt: 0 : 1] setIntValue: 240];
        [[freqFields cellAt: 0 : 2] setIntValue: 960];
        [[freqFields cellAt: 0 : 3] setIntValue: 3840];
    }
    return self;
}

- (int) logFreq: (int) length array: (float *) f;	// Set for 1/10 octaves right now
{		// Starts at 80Hz, Specific to 22050 Hz Sampling Rate and 256 Xform length
    int i,j = 1,k = 0,l = 0;
    float temp,width = 1.0,pos=1.07666,temp_array[256];
//    fprintf(stdout,"%i\n",length);
    while (k<length)	{
//        fprintf(stdout,"%i  ",k);
	temp = 0.0;
	for (i=k;i<k+j;i++) temp += f[i];
	temp_array[l] = temp / j;
	l += 1;
	width = pos * 0.071773463;
	pos *= 1.071773463;
	j = (int) (width + 1.0);		//  minimum 1 for histogram bin width
	k = (int) pos;
    }
    for (i=0;i<l-1;i++) f[i] = temp_array[i];
//    fprintf(stdout,"\n");
    return l-1;
}

- displayData: (int) powerOfFour array: (float *) f     // Compute the spectrum from data, and 
{							// display it
    int temp;
    temp = pow(4.0,(double) powerOfFour);
    [self fhtRX4: powerOfFour array: f];
    [self logMag: temp array: f floor: -60];
    [self clear];
    [self drawSpectrum: temp / 2 array: f];
    return self;
}

- drawSpectrum: (int) length array: (float *) f			//  default draw not erasing
{
    int temp;
    [self drawSpectrum: length array: f erase: FALSE];
    return self;
}

- drawSpectrum: (int) length array: (float *) f erase: (BOOL) erase	// Draw one
{								//  Option to draw over spectrum
    int i,incr,temp;					//  in background color to erase
    double xstep,ymax,max=0.0;
    temp = length;
    [self logLinear];
    if ([logFreq state]) temp = [self logFreq: length array: f];
    xstep = frame.size.width / temp;
    ymax = frame.size.height;
    incr = temp / frame.size.width;
    [self lockFocus];
    [self setOpaque: TRUE];
    PSsetlinewidth(0.1);
    if (erase)
        PSsetgray(back_ground);
    else
        PSsetgray(draw_gray);
    PSmoveto(0.0,f[0] * ymax);
    for (i=1;i<temp;i++) {
	if (f[i]>max) max = f[i];				//  This takes max
	if (incr==0)	{					//  sample in a region
	    PSlineto((double) i * xstep,max * ymax);
	    max = 0.0;	
	}
	else if ((i%incr)==0)	{
	    PSlineto((double) i * xstep,max * ymax);
	    max = 0.0;
	}
    }
    PSstroke();
    PSflushgraphics();
    for (i=1;i<4;i++)	{
        [self placeMarkerAt: (float) (0.25 * i) height: 1.0 erase: FALSE];
	[self placeHorizontal: (float) (0.33 * i)];
    }
    [self unlockFocus];
    return self;
}

- placeMarkerAt: (float) pos height: (float) height erase: (BOOL) erase;	// Vert. Markers
{
    double xpos,ypos;
    xpos = frame.size.width * pos;
    ypos = frame.size.height * height;
    [self lockFocus];
    [self setOpaque: TRUE];
    PSsetlinewidth(0.1);
    if (erase)
        PSsetgray(back_ground);
    else
        PSsetgray(marker_gray);
    if (xpos==frame.size.width) xpos -= 1.0;
    PSmoveto(xpos,0.0);
    PSlineto(xpos,ypos);
    PSstroke();
    PSflushgraphics();
    [self unlockFocus];
    return self;
}

- placeHorizontal: (float) height;				// Hor. Markers
{
    double xpos,ypos;
    xpos = frame.size.width;
    ypos = frame.size.height * height;
    [self lockFocus];
    [self setOpaque: TRUE];
    if (ypos<1.0) ypos = 1.0;
    PSsetlinewidth(0.1);
    PSsetgray(marker_gray);
    PSmoveto(0.0,ypos);
    PSlineto(xpos,ypos);
    PSstroke();
    PSflushgraphics();
    [self unlockFocus];
    return self;

}
    
- clear
{
    [self lockFocus];
    [self setOpaque: TRUE];
    PSsetgray(back_ground);
    PSrectfill(0.,0.,bounds.size.width,bounds.size.height);
    PSstroke();
    PSflushgraphics();
    [self unlockFocus];
    return self;
}

- drawSelf: (NXRect *) r : (int) n 
{
    [self clear];
    return self;
}

- logMag: (int) size array: (float *) f floor: (float) fl

/* calculates the log magnitude of the data, using the Hartley
	identity |X(f)| = sqrt(X(f)^2 + X(N-f)^2) * scale factor.
	I ignore the scale factor because the data gets normalized anyway.	*/

{
    int i;
    float t1=0.0,t=0.0,t2=-12;
    t2 = fl / 5.0;
    f[0] *= 2*f[0];
    if (f[0] > t1)
        t1 = f[0];
    for (i=1;i<size/2;i++)	{
    	t = f[i]*f[i] + f[size-i]*f[size-i];
	f[i] = t;
	if (t>t1)
	   t1 = t;
    }
    for (i=0;i<size/2;i++)	{
    	t = log(f[i]/t1);
	if (t<t2)
	   t = t2;
	f[i] = 1 - t/t2;
    }
    return self;
}

make_sines(int length)
{
    int i;
    float freq,temp;
    freq = 2.0 * PI / length;
    for (i=0;i<length;i++) {
        temp = freq * i;
	sines[i] = sin(temp);
	cosines[i] = cos(temp);
    }
    return;
}

- fhtRX4: (int) powerOfFour array: (float *) array
{
    /* In place FHT of floating point data in array.
    	Size of data array must be power of four.
	Lots of sets of four inline code statements,
	so it is verbose and repetitive but pretty fast.        */
	
    register int j=0,i=0,k=0,L=0;
    int n=0,n4=0,nr=0,d1=0,d2=0,d3=0,d4=0,d5=1,d6=0,d7=0,d8=0,d9=0;
    int L1=0,L2=0,L3=0,L4=0,L5=0,L6=0,L7=0,L8=0;
    int n_over_d3;
    float r=0.0;
    int a1=0,a2=0,a3=0;
    float t=0.0,t1=0.0,t2 =0.0,t3=0.0,t4=0.0,t5=0.0,t6=0.0,t7=0.0,t8=0.0;
    float t9=0.0,t0=0.0;
    n = pow(4.0 , (double) powerOfFour);
    if (n!=last_length)	{
        make_sines(n);
	last_length = n;
    }
    n4 = n / 4;
    r = SQRT_TWO;
    j = 1;
    i = 0;
    while (i<n-1)	{
    	i++;
	if (i<j)	{
    		t = array[j-1];
		array[j-1] = array[i-1];
		array[i-1] = t;
    	}
    	k = n4;
    	while ((3*k)<j)	{
    		j -= 3 * k;
		k /= 4;
    	}
    	j += k;
    }
    for (i=0;i<n;i += 4) {
    	t5 = array[i];
	t6 = array[i+1];
    	t7 = array[i+2];
	t8 = array[i+3];
	t1 = t5 + t6;
    	t2 = t5 - t6;
    	t3 = t7 + t8;
    	t4 = t7 - t8;
	array[i] = t1 + t3;
	array[i+1] = t1 - t3;
	array[i+2] = t2 + t4;
	array[i+3] = t2 - t4;
    }
    for (L=2;L<=powerOfFour;L++)  {
	d1 = pow(2.0 , L+L-3.0);
	d2=d1+d1;
	d3=d2+d2;
	n_over_d3 = n / 2 / d3;
	d4=d2+d3;
	d5=d3+d3;
	for (j=0;j<n;j += d5)	  {
	     t5 = array[j];
	     t6 = array[j+d2];
	     t7 = array[j+d3];
	     t8 = array[j+d4];
	     t1 = t5+t6;
	     t2 = t5-t6;
	     t3 = t7+t8;
	     t4 = t7-t8;
	     array[j] = t1 + t3;
	     array[j+d2] = t1 - t3;
	     array[j+d3] = t2 + t4;
	     array[j+d4] = t2 - t4;
	     d6 = j+d1;
	     d7 = j+d1+d2;
	     d8 = j+d1+d3;
	     d9 = j+d1+d4;
	     t1 = array[d6];
	     t2 = array[d7] * r;
	     t3 = array[d8];
	     t4 = array[d9] * r;
	     array[d6] = t1 + t2 + t3;
	     array[d7] = t1 - t3 + t4;
	     array[d8] = t1 - t2 + t3;
	     array[d9] = t1 - t3 - t4;
	     for (k=1;k<d1;k++)	{
		  L1 = j + k;
		  L2 = L1 + d2;
		  L3 = L1 + d3;
		  L4 = L1 + d4;
		  L5 = j + d2 - k;
		  L6 = L5 + d2;
		  L7 = L5 + d3;
		  L8 = L5 + d4;
		  a1 = (int) (k * n_over_d3) % n;
		  a2 = (a1 + a1) % n;
		  a3 = (a1 + a2) % n;
		  t5 = array[L2] * cosines[a1] + array[L6] * sines[a1];
		  t6 = array[L3] * cosines[a2] + array[L7] * sines[a2];
		  t7 = array[L4] * cosines[a3] + array[L8] * sines[a3];
		  t8 = array[L6] * cosines[a1] - array[L2] * sines[a1];
		  t9 = array[L7] * cosines[a2] - array[L3] * sines[a2];
		  t0 = array[L8] * cosines[a3] - array[L4] * sines[a3];
		  t1 = array[L5] - t9;
		  t2 = array[L5] + t9;
		  t3 = - t8 - t0;
		  t4 = t5 - t7;
		  array[L5] = t1 + t4;
		  array[L6] = t2 + t3;
		  array[L7] = t1 - t4;
		  array[L8] = t2 - t3;
		  t1 = array[L1] + t6;
		  t2 = array[L1] - t6;
		  t3 = t8 - t0;
		  t4 = t5 + t7;
		  array[L1] = t1 + t4;
		  array[L2] = t2 + t3;
		  array[L3] = t1 - t4;
		  array[L4] = t2 - t3;
	     }
	}
    }		  
    return self;
}

@end
