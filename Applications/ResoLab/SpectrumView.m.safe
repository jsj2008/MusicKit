
/* Generated by Interface Builder */

#import "SpectrumView.h"
#import <appkit/appkit.h>
#import <math.h>

#define SRATE 22050.0

float back_ground = 0.0/3.0, draw_gray = 3.0/3.0, marker_gray = 1.0/3.0;

@implementation SpectrumView

- setFreqFields:anObject
{
    freqFields = anObject;
    return self;
}

- setLogFreq:anObject
{
    logFreq = anObject;
    return self;
}

- setBackGround: (float) gray
{
    back_ground = gray;
    return self;
}

- setDraw: (float) gray
{
    draw_gray = gray;
    return self;
}

- getPeaks: (int) size array: (float *) array 
		numPeaks: (int) numPeaks locs: (float *) locs gains: (float *) gains
{
    int i,j = 0;
    float last=-12.0,a=0.0,b=0.0,c=0.0,p=0.0;
    boolean_t goin_up=TRUE;
    
    for (i=0;i<numPeaks;i++)	{
	locs[i] = 0.0;
	gains[j] = 0.0;
    }
    for (i=0;(i<size && j<numPeaks);i++)  {
	if (goin_up && (last >= array[i]))	{
	    if (i==1)	{
	        locs[j] = 0.0;
		gains[j] = array[0];
	    }
	    else 	{
	        a = array[i-2];
	        b = array[i-1];
	        c = array[i];
	        p = a - (2 * b) + c;
	        if (p!=0.0)
	            p = (a - c) / p / 2.0;
	        else
	            p = 0.0;
	        locs[j] = (i - 1 + p);
	        gains[j] = b - ((a - c) * p / 4.0);
	    }
	    goin_up = FALSE;
	    j++;
	}
	if (last<array[i])
	    goin_up = TRUE;
	last = array[i];	
    }
    return self;
}

- logLinear
{
    int i;
    if (![logFreq state])
        for (i=0;i<4;i++) [[freqFields cellAt: 0 : i] setIntValue: SRATE * i / 8];
    else	{
        [[freqFields cellAt: 0 : 0] setIntValue: 60];
        [[freqFields cellAt: 0 : 1] setIntValue: 240];
        [[freqFields cellAt: 0 : 2] setIntValue: 960];
        [[freqFields cellAt: 0 : 3] setIntValue: 3840];
    }
    return self;
}

- (int) logFreq: (int) length array: (float *) f;	// Set for 1/10 octaves right now
{		// Starts at 80Hz, Specific to 22050 Hz Sampling Rate and 256 Xform length
    int i,j = 1,k = 0,l = 0;
    float temp,width = 1.0,pos=1.07666,temp_array[256];
//    fprintf(stdout,"%i\n",length);
    while (k<length)	{
//        fprintf(stdout,"%i  ",k);
	temp = 0.0;
	for (i=k;i<k+j;i++) temp += f[i];
	temp_array[l] = temp / j;
	l += 1;
	width = pos * 0.071773463;
	pos *= 1.071773463;
	j = (int) (width + 1.0);		//  minimum 1 for histogram bin width
	k = (int) pos;
    }
    for (i=0;i<l-1;i++) f[i] = temp_array[i];
//    fprintf(stdout,"\n");
    return l-1;
}

- displayData: (int) powerOfFour array: (float *) f     // Compute the spectrum from data, and 
{							// display it
    int temp;
    temp = pow(4.0,(double) powerOfFour);
    [self fhtRX4: powerOfFour array: f];
    [self logMag: temp array: f floor: -60];
    [self clear];
    [self drawSpectrum: temp / 2 array: f];
    return self;
}

- drawSpectrum: (int) length array: (float *) f			//  default draw not erasing
{
    int temp;
    [self drawSpectrum: length array: f erase: FALSE];
    return self;
}

- drawSpectrum: (int) length array: (float *) f erase: (boolean_t) erase	// Draw one
{								//  Option to draw over spectrum
    int i,incr,temp;					//  in background color to erase
    double xstep,ymax,max=0.0;
    temp = length;
    [self logLinear];
    if ([logFreq state]) temp = [self logFreq: length array: f];
    xstep = frame.size.width / temp;
    ymax = frame.size.height;
    incr = temp / frame.size.width;
    [self lockFocus];
    [self setOpaque: TRUE];
    PSsetlinewidth(0.1);
    if (erase)
        PSsetgray(back_ground);
    else
        PSsetgray(draw_gray);
    PSmoveto(0.0,f[0] * ymax);
    for (i=1;i<temp;i++) {
	if (f[i]>max) max = f[i];				//  This takes max
	if (incr==0)	{					//  sample in a region
	    PSlineto((double) i * xstep,max * ymax);
	    max = 0.0;	
	}
	else if ((i%incr)==0)	{
	    PSlineto((double) i * xstep,max * ymax);
	    max = 0.0;
	}
    }
    PSstroke();
    PSflushgraphics();
    for (i=1;i<4;i++)	{
        [self placeMarkerAt: (float) (0.25 * i) height: 1.0 erase: FALSE];
	[self placeHorizontal: (float) (0.33 * i)];
    }
    [self unlockFocus];
    return self;
}

- placeMarkerAt: (float) pos height: (float) height erase: (BOOL) erase;	// Vert. Markers
{
    double xpos,ypos;
    xpos = frame.size.width * pos;
    ypos = frame.size.height * height;
    [self lockFocus];
    [self setOpaque: TRUE];
    PSsetlinewidth(0.1);
    if (erase)
        PSsetgray(back_ground);
    else
        PSsetgray(marker_gray);
    if (xpos==frame.size.width) xpos -= 1.0;
    PSmoveto(xpos,0.0);
    PSlineto(xpos,ypos);
    PSstroke();
    PSflushgraphics();
    [self unlockFocus];
    return self;
}

- placeHorizontal: (float) height;				// Hor. Markers
{
    double xpos,ypos;
    xpos = frame.size.width;
    ypos = frame.size.height * height;
    [self lockFocus];
    [self setOpaque: TRUE];
    if (ypos<1.0) ypos = 1.0;
    PSsetlinewidth(0.1);
    PSsetgray(marker_gray);
    PSmoveto(0.0,ypos);
    PSlineto(xpos,ypos);
    PSstroke();
    PSflushgraphics();
    [self unlockFocus];
    return self;

}
    
- clear
{
    [self lockFocus];
    [self setOpaque: TRUE];
    PSsetgray(back_ground);
    PSrectfill(0.,0.,bounds.size.width,bounds.size.height);
    PSstroke();
    PSflushgraphics();
    [self unlockFocus];
    return self;
}

- drawSelf: (NXRect *) r : (int) n 
{
    [self clear];
    return self;
}

- logMag: (int) size array: (float *) f floor: (float) fl

/* calculates the log magnitude of the data, using the Hartley
	identity |X(f)| = sqrt(X(f)^2 + X(N-f)^2) * scale factor.
	I ignore the scale factor because the data gets normalized anyway.	*/

{
    int i;
    float t1=0.0,t=0.0,t2=-12;
    t2 = fl / 5.0;
    f[0] *= 2*f[0];
    if (f[0] > t1)
        t1 = f[0];
    for (i=1;i<size/2;i++)	{
    	t = f[i]*f[i] + f[size-i]*f[size-i];
	f[i] = t;
	if (t>t1)
	   t1 = t;
    }
    for (i=0;i<size/2;i++)	{
    	t = log(f[i]/t1);
	if (t<t2)
	   t = t2;
	f[i] = 1 - t/t2;
    }
    return self;
}

- fhtRX4: (int) powerOfFour array: (float *) array
{
    /* In place Fast Hartley Transform of floating point data in array.
    	Size of data array must be power of four. Lots of sets of four 
	inline code statements, so it is verbose and repetative but fast. 
	The Fast Hartley Transform algorithm is patented, and is documented
	in "The Hartley Transform", by Ronald N. Bracewell.
	This routine was converted to C from a BASIC routine in the above book,
	that code Copyright 1985, The Board of Trustees of Stanford University */
	
    #define PI 3.141592654782
    #define SQRT_TWO 1.414213562
    #define TWO_PI 6.283185309564

    int n=0,n4=0,nr=0,j=0,i=0,k=0,L=0,d1=0,d2=0,d3=0,d4=0,d5=1;
    int L1=0,L2=0,L3=0,L4=0,L5=0,L6=0,L7=0,L8=0;
    float r=0.0,a1=0.0,a2=0.0,a3=0.0,c1=0.0,c2=0.0,c3=0.0;
    float s1=0.0,s2=0.0,s3=0.0;
    float t=0.0,t1=0.0,t2 =0.0,t3=0.0,t4=0.0,t5=0.0,t6=0.0,t7=0.0,t8=0.0;
    float t9=0.0,t0=0.0;
    n = pow(4 , powerOfFour);
    n4 = n/4;
    r = SQRT_TWO;
    j = 1;
    i = 0;
    while (i<n-1)	{
    	i++;
	if (i<j)	{
    		t = array[j-1];
		array[j-1] = array[i-1];
		array[i-1] = t;
    	}
    	k = n4;
    	while ((3*k)<j)	{
    		j -= 3*k;
		k /= 4;
    	}
    	j += k;
    }
    for (i=0;i<n;i += 4) {
    	t1 = array[i] + array[i+1];
    	t2 = array[i] - array[i+1];
    	t3 = array[i+2] + array[i+3];
    	t4 = array[i+2] - array[i+3];
	array[i] = t1 + t3;
	array[i+1] = t1 - t3;
	array[i+2] = t2 + t4;
	array[i+3] = t2 - t4;
    }
    for (L=2;L<=powerOfFour;L++)  {
	d1 = pow(2.0 , L+L-3.0);
	d2=d1+d1;
	d3=d2+d2;
	d4=d2+d3;
	d5=d3+d3;
	for (j=0;j<n;j += d5)	  {
	     t1 = array[j]+array[j+d2];
	     t2 = array[j]-array[j+d2];
	     t3 = array[j+d3]+array[j+d4];
	     t4 = array[j+d3]-array[j+d4];
	     array[j] = t1 + t3;
	     array[j+d2] = t1 - t3;
	     array[j+d3] = t2 + t4;
	     array[j+d4] = t2 - t4;
	     t1 = array[j+d1];
	     t2 = array[j+d1+d2]*r;
	     t3 = array[j+d1+d3];
	     t4 = array[j+d1+d4]*r;
	     array[j+d1] = t1 + t2 + t3;
	     array[j+d1+d2] = t1 - t3 + t4;
	     array[j+d1+d3] = t1 - t2 + t3;
	     array[j+d1+d4] = t1 - t3 - t4;
	     for (k=1;k<d1;k++)	{
	     	  L1 = j + k;
		  L2 = L1 + d2;
		  L3 = L1 + d3;
		  L4 = L1 + d4;
		  L5 = j + d2 - k;
		  L6 = L5 + d2;
		  L7 = L5 + d3;
		  L8 = L5 + d4;
		  a1 = PI * k / ((float) d3);
		  a2 = a1 + a1;
		  a3 = a1 + a2;
		  c1 = cos(a1);
		  c2 = cos(a2);
		  c3 = cos(a3);
		  s1 = sin(a1);
		  s2 = sin(a2);
		  s3 = sin(a3);
		  t5 = array[L2]*c1 + array[L6]*s1;
		  t6 = array[L3]*c2 + array[L7]*s2;
		  t7 = array[L4]*c3 + array[L8]*s3;
		  t8 = array[L6]*c1 - array[L2]*s1;
		  t9 = array[L7]*c2 - array[L3]*s2;
		  t0 = array[L8]*c3 - array[L4]*s3;
		  t1 = array[L5] - t9;
		  t2 = array[L5] + t9;
		  t3 = -t8 - t0;
		  t4 = t5 - t7;
		  array[L5] = t1 + t4;
		  array[L6] = t2 + t3;
		  array[L7] = t1 - t4;
		  array[L8] = t2 - t3;
		  t1 = array[L1] + t6;
		  t2 = array[L1] - t6;
		  t3 = t8 - t0;
		  t4 = t5 + t7;
		  array[L1] = t1 + t4;
		  array[L2] = t2 + t3;
		  array[L3] = t1 - t4;
		  array[L4] = t2 - t3;
	     }
	}
    }		  
    return self;
}

@end
