/* dspdriver_server.c by David A. Jaffe */

/* Set to IOLog to see error messages */

/* Some debugging configuration variables */
#define TIME_STAMPS 0

#if TIME_STAMPS
#define MAX_TIME_STAMP 1024
static ns_time_t timeStamps[MAX_TIME_STAMP];
static int timeStampTags[MAX_TIME_STAMP];
static int timeStampCtr = 0;
static void TIME_STAMP_IT(int tag)
{
  if (++timeStampCtr == MAX_TIME_STAMP)
    timeStampCtr = 0;
  IOGetTimestamp(&(timeStamps[timeStampCtr]));
  timeStampTags[timeStampCtr] = tag;
}

static void PRINT_TIME_STAMPS(void)
{
  int i,j;
  long long ll;
  long l;
  j = timeStampCtr+1;
  IOLog("Time stamps...\n");
  for (i=0; i<MAX_TIME_STAMP; i++) {
    if (timeStampTags[j]) {
      /* ns = 0.000000001
	 us = 0.000001 
	 ms = 0.001
       */
      ll = timeStamps[j]/1000;
      l = ll;
      IOLog("(%d) %d\n",timeStampTags[j],l);
    }
    if (++j == MAX_TIME_STAMP) 
      j = 0;
  }
  IOLog("...end of time stamps.\n");
}
#else

#define TIME_STAMP(_x) // 
#define PRINT_TIME_STAMPS() //

#endif

#import "dspdriver.h"  /* Generated by MIG */

static int debugFlags = 0;

/* Forward references */
extern boolean_t _dsp_portDeath(port_name_t port);
static void sendMessage(int messageType, port_t port, int regionTag,
			void *data, int nbytes, int chan, int pageIndex,
			BOOL fromIOThread, int unit);

static port_t devPort = PORT_NULL;

kern_server_t instance;        /* Needed? */

/* ------------------------------------------------------------------- 
 * Interface functions, exported to the user via MIG. 
 * ------------------------------------------------------------------- 
 */
#define EXPORTED 

#define CHECK_OWNER  
/* Undefine this if you want to allow multiple apps to access at once (probably
   a bad idea, but may be useful for debugging 
   */

#ifdef CHECK_OWNER
#define ownerCheck() \
  if ((!classVars.driverObjects[unit]) || (owner_port != classVars.driverObjects[unit]->owner)) return DSPDRIVER_ERROR_NOT_OWNER
#else
#define ownerCheck()
#endif

#define unitCheck() if (unit>=MAX_UNITS || unit<0) return DSPDRIVER_ERROR_BAD_UNIT_OR_DRIVER


/******* Functions required by kern_loader *********************/
EXPORTED void _dsp_init(void) {
    /* Load handler. This gets called before initFromDeviceDescription: */
    // Need this if ever make it a user level driver:   IOInitGeneralFuncs();  
}

EXPORTED void _dsp_signoff(void) {
    /* Unload handler.  Actually, since Driver Kit drivers can't be unloaded,
     * we never do this.
     */
    int i;
    for (i=0; i<MAX_UNITS; i++)
      if (classVars.driverObjects[i])
	classVars.driverObjects[i]->owner = PORT_NULL;
}

EXPORTED boolean_t _dsp_portDeath(port_name_t port) {
  /* This is invoked when the user's owner port dies (e.g. app exited)
   */
    int i;
    for (i=0; i<MAX_UNITS; i++) {
	if (classVars.driverObjects[i]->owner == port) { /* Find it */
	    [classVars.driverObjects[i] resetAllDSPs];
	    classVars.driverObjects[i]->owner = PORT_NULL;
	    return TRUE;
	}
    }
    return FALSE;
}

/******* Managing ownership of the driver ********/
EXPORTED kern_return_t 
  dsp_become_owner(port_t device_port, port_t owner_port, int unit) {
    /* Becoming owner of the driver */
    if (!classVars.driverObjects[unit]) {
	IOLog("dsp_become_owner failed: device is nonexistant.\n");
	return DSPDRIVER_ERROR_BAD_UNIT_OR_DRIVER;
    }
    if (classVars.driverObjects[unit]->owner) {
	IOLog("dsp_become_owner failed: device is busy.\n");
	return DSPDRIVER_ERROR_BUSY;
    }
    if (devPort == PORT_NULL) 
      devPort = device_port;
    else if (device_port != devPort) {
	IOLog("DSP driver error: bad device port??\n");
	return DSPDRIVER_ERROR_UNKNOWN_ERROR;
    }
    classVars.driverObjects[unit]->owner = owner_port;
    [classVars.driverObjects[unit] resetHardware];
    return KERN_SUCCESS;
}

EXPORTED kern_return_t 
  dsp_release_ownership(port_t dspdriver_port,port_t owner_port, int unit) {
    /* Releasing ownership of driver. */
    unitCheck(); ownerCheck();
    PRINT_TIME_STAMPS();
    [classVars.driverObjects[unit] setMessagingOn:0];
    [classVars.driverObjects[unit] resetOutputQueue];
    [classVars.driverObjects[unit] reinitAvailPagePool];
    [classVars.driverObjects[unit] resetHardware]; /* For Frank */
    classVars.driverObjects[unit]->owner = PORT_NULL;
    return KERN_SUCCESS;
}

/******* Functions for setting subunit ********/

EXPORTED kern_return_t
  dsp_set_sub_unit(port_t dspdriver_port,port_t owner_port,int sub_unit,int unit)
/* Set current sub_unit. sub_unit is zero-based.
 * If this protocol proves problematic, we can encode the sub_unit in the unit
 * and pass it to all the other functions.
 */
{
    unitCheck(); ownerCheck();
    [classVars.driverObjects[unit] setVirtualSubUnit:sub_unit];
    return KERN_SUCCESS;
}

/******* Functions for getting/setting raw data ********/

EXPORTED kern_return_t
  dsp_get_icr(port_t dspdriver_port,port_t owner_port,char *icr, int unit)
{
    unitCheck(); ownerCheck();
    *icr = inb(DSPDRIVER_ICR(unit));
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_cvr(port_t dspdriver_port,port_t owner_port,char *cvr, int unit)
{
    unitCheck(); ownerCheck();
    *cvr = inb(DSPDRIVER_CVR(unit));
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_isr(port_t dspdriver_port,port_t owner_port,char *isr, int unit)
{
    unitCheck(); ownerCheck();
    *isr = inb(DSPDRIVER_ISR(unit));
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_get_ivr(port_t dspdriver_port,port_t owner_port,char *ivr, int unit)
{
    unitCheck(); ownerCheck();
    *ivr = inb(DSPDRIVER_IVR(unit));
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_put_icr(port_t dspdriver_port,port_t owner_port,char icr, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_ICR(unit),icr);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_cvr(port_t dspdriver_port,port_t owner_port,char cvr, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_CVR(unit),cvr);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_ivr(port_t dspdriver_port,port_t owner_port,char ivr, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_IVR(unit),ivr);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_hi(port_t dspdriver_port,port_t owner_port, int *hiRegs, int unit)
{
    unsigned int v;
    unsigned char icr,ivr,cvr,isr;
    unitCheck(); ownerCheck();
    icr = inb(DSPDRIVER_ICR(unit));
    cvr = inb(DSPDRIVER_CVR(unit));
    isr = inb(DSPDRIVER_ISR(unit));
    ivr = inb(DSPDRIVER_IVR(unit));
    v = icr;
    v = (v << 8) | cvr;
    v = (v << 8) | isr;
    v = (v << 8) | ivr;
    *(unsigned int *)hiRegs = v;
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_raw(port_t dspdriver_port,port_t owner_port,char high,
	     char med, char low, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_DATA_HIGH(unit),high);
    outb(DSPDRIVER_DATA_MED(unit),med);
    outb(DSPDRIVER_DATA_LOW(unit),low);
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_get_data_raw(port_t dspdriver_port,port_t owner_port,char *high,
	     char *med, char *low, int unit)
{
    unitCheck(); ownerCheck();
    *high = inb(DSPDRIVER_DATA_HIGH(unit));
    *med = inb(DSPDRIVER_DATA_MED(unit));
    *low = inb(DSPDRIVER_DATA_LOW(unit));
    return KERN_SUCCESS;
}
/******* Functions for higher level interaction ***********/

#define SLEEP_TIME 1 /* ms */
#define TIMEOUT 20 /* ms */

static int spinISRMaskAndValue(unsigned char mask,unsigned char value, 
			       int unit)
     /* Like awaitISRMaskAndValue but never sleeps */
{
    char isr;
    isr = inb(DSPDRIVER_ISR(unit));
    if ((isr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
    if ((isr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
    if ((isr & mask) == value) 
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
    if ((isr & mask) == value) 
      return KERN_SUCCESS;
    TPRINTF("dsp: spinISRMaskAndValue timeout isr&0x%x=0x%x. isr=%x!\n",(int)mask,(int)value,(int)isr);
    return DSPDRIVER_ERROR_TIMEOUT;
}

static inline int spinISRMask(unsigned char mask, int unit)
{
    return spinISRMaskAndValue(mask,mask,unit);
}

static int awaitISRMaskAndValue(unsigned char mask,unsigned char value, 
				int unit)
{
    if (spinISRMaskAndValue(mask,value,unit) == KERN_SUCCESS)
       return KERN_SUCCESS;
    {
      char isr;
      int timeSlept = 0;
      do {
        timeSlept += SLEEP_TIME;
        if (timeSlept > TIMEOUT) {
          UPRINTF("dsp: Timed out waiting for isr&0x%x=0x%x!\n",(int)mask,(int)value);
          return DSPDRIVER_ERROR_TIMEOUT;
        }
	DPRINTF("dsp: Sleeping waiting for isr&0x%x=0x%x!\n",(int)mask,(int)value);
	IOSleep(SLEEP_TIME);      
	isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
      } while ((isr & mask) != value);
    }
    return KERN_SUCCESS;
}

static inline int awaitISRMask(unsigned char mask, int unit)
{
    return awaitISRMaskAndValue(mask,mask,unit);
}

static int spinCVRMaskAndValue(unsigned char mask,unsigned char value, 
				int unit)
{
    unsigned char cvr;
    cvr = inb(DSPDRIVER_CVR(unit));
    if ((cvr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    cvr = inb(DSPDRIVER_CVR(unit)); /* Try again */
    if ((cvr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    cvr = inb(DSPDRIVER_CVR(unit)); /* Try again */
    if ((cvr & mask) == value) 
      return KERN_SUCCESS;
    return DSPDRIVER_ERROR_TIMEOUT;
}

#if 0
static int awaitCVRMaskAndValue(unsigned char mask,unsigned char value, 
				int unit)
{
    if (spinCVRMaskAndValue(mask,value,unit) == KERN_SUCCESS)
       return KERN_SUCCESS;
    {
        unsigned char cvr;
	int timeSlept = 0;
	do {
	    timeSlept += SLEEP_TIME;
	    if (timeSlept > TIMEOUT) {
		UPRINTF("dsp: Timed out waiting for cvr&0x%x=0x%x!\n",(int)mask,(int)value);
		return DSPDRIVER_ERROR_TIMEOUT;
	    }
	    DPRINTF("dsp: Sleeping waiting for cvr&0x%x=0x%x!\n",(int)mask,(int)value);
	    IOSleep(SLEEP_TIME);      
	    cvr = inb(DSPDRIVER_CVR(unit)); /* Try again */
	} while ((cvr & mask) != value);
    }
    return KERN_SUCCESS;
}
#endif

#define HF3  ((unsigned char) 0x10)
#define HF2  ((unsigned char) 8)
#define TRDY ((unsigned char) 4)  /* In ISR */
#define TXDE ((unsigned char) 2)  /* In ISR */
#define RXDF ((unsigned char) 1)  /* In ISR */

static inline int writeInt(int i, int unit)
{
    unsigned char low = i & 0xff;
    unsigned char med = (i >> 8) & 0xff;
    unsigned char high = (i >> 16);
    if (awaitISRMask(TXDE,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    outb(DSPDRIVER_DATA_HIGH(unit),high);
    outb(DSPDRIVER_DATA_MED(unit),med);
    outb(DSPDRIVER_DATA_LOW(unit),low);
//    VPRINTF("Wrote 0x%x\n",i);
}

EXPORTED kern_return_t 
  dsp_put_data(port_t dspdriver_port,port_t owner_port,char high,
	       char med, char low, int unit)
  /* Like dsp_put_data_raw but waits for TXDE to be set. */
{
    unitCheck(); ownerCheck();
    if (awaitISRMask(TXDE,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    outb(DSPDRIVER_DATA_HIGH(unit),high);
    outb(DSPDRIVER_DATA_MED(unit),med);
    outb(DSPDRIVER_DATA_LOW(unit),low);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_data(port_t dspdriver_port,port_t owner_port,char *high,
	       char *med, char *low, int unit)
{
    unitCheck(); ownerCheck();
    if (awaitISRMask(RXDF,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    *high = inb(DSPDRIVER_DATA_HIGH(unit));
    *med = inb(DSPDRIVER_DATA_MED(unit));
    *low = inb(DSPDRIVER_DATA_LOW(unit));
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_put_data_array(port_t dspdriver_port, port_t owner_port, 
		     int *data, unsigned int count, int unit)
{
    int v;
    unitCheck(); ownerCheck();
    while (count--) {
	v = *data++;
	writeInt(v,unit);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_data_array(port_t dspdriver_port, port_t owner_port, int count,
		     int *data, unsigned int *dataCount, int unit)
/* count is what is passed by the user.  
   *dataCount is what we set to say how much we read. 
   Currently, we just always set *dataCount = count;
   */
{
    unsigned char low,med,high;
    int v;
    unitCheck(); ownerCheck();
    *dataCount = count;
    while (count--) {
	if (awaitISRMask(RXDF,unit))
	  return DSPDRIVER_ERROR_TIMEOUT;
	high = inb(DSPDRIVER_DATA_HIGH(unit));
	med = inb(DSPDRIVER_DATA_MED(unit));
	low = inb(DSPDRIVER_DATA_LOW(unit));
	v = high;
	v = (v << 8) | med;
	v = (v << 8) | low;
	*data++ = v;
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_byte_array(port_t dspdriver_port, port_t owner_port, 
			  char *data, unsigned int count, int unit)
{
    char low,signExt;
    unitCheck(); ownerCheck();
    while (count--) {
	low = *data++;
	signExt = (low & 0x80) ? 0xFF : 0;
	if (awaitISRMask(TXDE,unit))
	  return DSPDRIVER_ERROR_TIMEOUT;
	outb(DSPDRIVER_DATA_HIGH(unit),signExt);
	outb(DSPDRIVER_DATA_MED(unit),signExt);
	outb(DSPDRIVER_DATA_LOW(unit),low);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_short_array(port_t dspdriver_port, port_t owner_port, 
			   short *data, unsigned int count, int unit)
{
    char low,med,signExt;
    short v;
    unitCheck(); ownerCheck();
    while (count--) {
      v = *data++;
      low = v & 0xff;
      med = v >> 8;
      signExt = (med & 0x80) ? 0xff : 0;
      if (awaitISRMask(TXDE,unit))
	return DSPDRIVER_ERROR_TIMEOUT;
      outb(DSPDRIVER_DATA_HIGH(unit),signExt);
      outb(DSPDRIVER_DATA_MED(unit),med);
      outb(DSPDRIVER_DATA_LOW(unit),low);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_packed_array(port_t dspdriver_port, port_t owner_port, 
			    char *data, unsigned int count, int unit) 
{
    char low,med,high;
    unitCheck(); ownerCheck();
    count /= 3;        /* Count is in bytes */
    while (count--) {
	low = *data++;
	med = *data++;
	high = *data++;
	if (awaitISRMask(TXDE,unit))
	  return DSPDRIVER_ERROR_TIMEOUT;
	outb(DSPDRIVER_DATA_HIGH(unit),high);
	outb(DSPDRIVER_DATA_MED(unit),med);
	outb(DSPDRIVER_DATA_LOW(unit),low);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_left_array(port_t dspdriver_port, port_t owner_port, 
			  int *data, unsigned int count, int unit) 
{
    int v;
    unitCheck(); ownerCheck();
    while (count--) {
	v = *data++;
	v >>= 8;      /* Right justify it */
	writeInt(v,unit);
    }
    return KERN_SUCCESS;
}

/************ Special Music Kit Functions ***********/

#define UNTIMED_MESSAGE (-1)

// #import <dsp/dsp.h>
/* Must agree with dsp/dsp.h */
#define DSP_HC_XHM ((0x26>>1))
#define HC ((unsigned char)0x80)

static inline int xhm(int unit)
{
  int timeSlept = 0;
  while ((spinCVRMaskAndValue(HC,0,unit) != KERN_SUCCESS) ||
	 (spinISRMaskAndValue(TRDY|HF2|HF3,TRDY,unit) != KERN_SUCCESS)) {
    /* Note that these 2 must be kept atomic, with no intervening sleep */
    timeSlept += SLEEP_TIME;
    if (timeSlept > TIMEOUT) {
      UPRINTF("dsp: Timed out waiting to xhm\n");
      return DSPDRIVER_ERROR_TIMEOUT;
    }
    DPRINTF("dsp: Sleeping waiting to xhm\n");
    IOSleep(SLEEP_TIME);      
  } 
  outb(DSPDRIVER_CVR(unit),HC|DSP_HC_XHM);
  return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_mk_timed_message(port_t dspdriver_port,port_t owner_port,
			   int highWord,int lowWord,int opCode, int unit)
{
    unitCheck(); ownerCheck();
    if (highWord != UNTIMED_MESSAGE) {
      writeInt(highWord,unit);
      writeInt(lowWord,unit);
    }
    writeInt(opCode,unit);
    return xhm(unit);
}

/* The following function is obsolete */
EXPORTED kern_return_t
  dsp_exec_mk_host_message(port_t dspdriver_port,port_t owner_port, int unit)
{
    unitCheck(); ownerCheck();
    return xhm(unit);
}

EXPORTED kern_return_t
  dsp_put_and_exec_mk_host_message(port_t dspdriver_port, port_t owner_port, 
				   int *data, unsigned int count, int unit)
{
    int v;
    unitCheck(); ownerCheck();
    TPRINTF("Writing %d words, subUnit %d\n",count,classVars.driverObjects[unit]->subUnit);
    while (count--) {
	v = *data++;
	writeInt(v,unit);
    }
    return xhm(unit);
}
/************ Other settings ************************/

EXPORTED kern_return_t
  dsp_reset_chip(port_t dspdriver_port,port_t owner_port,char resetOn, 
	 	 int unit)
{
    unitCheck(); ownerCheck();
    [classVars.driverObjects[unit] resetDSP:resetOn];
    return KERN_SUCCESS;
}


/************ DSP-initiated transfers *****************************/


/******************************************************************************
*
*	function:	dsp_put_page
*
*	purpose:	Writes a page of data (2048 DSPFix24s) to the DSP.
*                       A reply message is sent to the reply port, if the
*			started or completed flag is set.  Works like other
*                       "put" driver functions (i.e. doesn't use interrupts).
*
*       arguments:      dspdriver_port
*                       owner_port
*                       pageAddress - vm page address of data
*                       regionTag - tag for the region of data
*                       msgStarted - set on for started message to reply port
*                       msgCompleted - set on for completed message to reply
*                                      port
*                       reply_port - port where reply messages are sent
*                       unit - device unit number
*
*	internal
*	functions:	unitCheck, ownerCheck, sendMessage, writeInt
*
*	library
*	functions:	kern_serv_kernel_task_port, vm_allocate, vm_write,
*                       vm_deallocate
*
******************************************************************************/

EXPORTED kern_return_t
  dsp_put_page(port_t dspdriver_port, port_t owner_port,
	       DSPPagePtr pageAddress, int regionTag, boolean_t msgStarted,
	       boolean_t msgCompleted, port_t reply_port, int unit)
{
    int count = (MSG_SIZE_MAX/sizeof(int));
    kern_return_t r;
    DSPPagePtr data = NULL, local_data;
    port_t kernel_task;
    /*  DO UNIT AND OWNER CHECK  */
    unitCheck(); ownerCheck();
    /*  GET THE TASK ID FOR THE CURRENT KERNEL TASK  */
    kernel_task = kern_serv_kernel_task_port();
    /*  ALLOCATE VIRTUAL MEMORY FOR THE PAGE OF DATA  */
    r = vm_allocate((vm_task_t)kernel_task, (vm_address_t *)&local_data,
		    8192, TRUE);
    if (r != KERN_SUCCESS)
      return KERN_FAILURE;
    /*  INITIALIZE POINTER TO ALLOCATED PAGE  */
    data = local_data;
    /*  MAP THE USER MEMORY TO THE ALLOCATED PAGE  */
    r = vm_write((vm_task_t)kernel_task, (vm_address_t)local_data, 
		 (pointer_t)pageAddress, 8192);
    /*  SEND STARTED MESSAGE TO REPLY PORT, IF REQUESTED  */
    if (msgStarted)
        sendMessage(DSPDRIVER_MSG_WRITE_STARTED,reply_port,regionTag,NULL,0,0,0,FALSE,unit);
    /*  WRITE THE PAGE TO THE DSP  */
    while (count--)
	writeInt(*data++,unit);
    /*  SEND COMPLETED MESSAGE TO REPLY PORT, IF REQUESTED  */
    if (msgCompleted)
        sendMessage(DSPDRIVER_MSG_WRITE_COMPLETED,reply_port,regionTag,NULL,0,0,0,FALSE,unit);
    /*  DEALLOCATE THE VIRTUAL MEMORY  */
    vm_deallocate((vm_task_t)kernel_task, (vm_address_t)local_data, 8192);
    return KERN_SUCCESS;
}



/******************************************************************************
*
*	function:	dsp_set_messaging
*
*	purpose:	Turns on or off the driver messaging mode.  Messaging
*                       should be turned on after the DSP is booted and loaded.
*			Once messaging is on, pages of data can be queued in
*                       the driver for transfer to the DSP, and data will be
*                       returned to user code using mach messages to the
*                       reply port.
*
*       arguments:      dspdriver_port
*                       owner_port
*                       flag - set on to turn on messaging
*                       unit - device unit number
*
*	internal
*	functions:	unitCheck, ownerCheck, setMessagingOn:
*
*	library
*	functions:	none
*
******************************************************************************/

EXPORTED kern_return_t
  dsp_set_messaging(port_t dspdriver_port, port_t owner_port,
		    boolean_t flag, int unit)
{
    /*  DO UNIT AND OWNER CHECK  */
    unitCheck(); ownerCheck();
    /*  SET THE MESSAGINGON DRIVER INSTANCE VARIABLE  */
    [classVars.driverObjects[unit] setMessagingOn:flag];
    return KERN_SUCCESS;
}



/******************************************************************************
*
*	function:	dsp_queue_page
*
*	purpose:	Queues a page of data (2048 DSPFix24s) for transfer
*                       to the DSP.  A reply message is sent to the reply
*			port if the started or completed flags are set.
*                       Data is transferred by the "DSP-initiated DMA"
*                       protocol (using interrupts).
*
*       arguments:      dspdriver_port
*                       owner_port
*                       pageAddress - vm page address of data
*                       regionTag - tag for the region of data
*                       msgStarted - set on for started message to reply port
*                       msgCompleted - set on for completed message to reply
*                                      port
*                       reply_port - port where reply messages are sent
*                       unit - device unit number
*
*	internal
*	functions:	unitCheck, ownerCheck, pushOutputQueue:::::
*
*	library
*	functions:	none
*
******************************************************************************/

EXPORTED kern_return_t
  dsp_queue_page(port_t dspdriver_port, port_t owner_port,
		 DSPPagePtr pageAddress, int regionTag, boolean_t msgStarted,
		 boolean_t msgCompleted, port_t reply_port, int unit)
{
    /*  DO UNIT AND OWNER CHECK  */
    unitCheck(); ownerCheck();
    /*  PUSH THE PAGE ONTO THE QUEUE  */
    [classVars.driverObjects[unit] pushOutputQueue:pageAddress:regionTag
     :msgStarted:msgCompleted:reply_port];
    return KERN_SUCCESS;
}


/******************************************************************************
*
*	function:	dsp_set_short_swapped_return
*
*	purpose:	Sets up the driver so that data from the DSP is sent
*                       to the reply port in an out-of-line message.  The
*			data is returned in a region of vm (page-aligned)
*                       and consists of swapped short ints (i.e. 16 bit
*                       big-endian sound samples).  Data is transferred by
*                       the "DSP-initiated DMA" protocol (using interrupts).
*
*       arguments:      dspdriver_port
*                       owner_port
*                       regionTag - tag for the region of data
*                       wordCount - transfer buffer size (must agree with DSP)
*                       reply_port - port where reply messages are sent
*                       unit - device unit number
*
*	internal
*	functions:	unitCheck, ownerCheck,
*                       setDMARegionTag:wordCount:replyPort
*	library
*	functions:	none
*
******************************************************************************/

#define checkChanAndWordCount(_type) \
  if (chan >= DSPDRIVER_MAX_TRANSFER_CHAN) return DSPDRIVER_ERROR_BAD_TRANSFER_CHAN; \
  else if (wordCount > MSG_SIZE_MAX/sizeof(_type)) \
  return DSPDRIVER_ERROR_BAD_TRANSFER_REQUEST 

EXPORTED kern_return_t
  dsp_set_short_big_endian_return(port_t dspdriver_port, port_t owner_port,
			          int regionTag, int wordCount,
			          port_t reply_port, int chan, int unit)
{
    unitCheck(); ownerCheck(); 
    checkChanAndWordCount(short);
    /*  SET DMA OUT VARIABLES  */
    [classVars.driverObjects[unit] setDSPReadRegionTag:regionTag
     wordCount:wordCount replyPort:reply_port chan:chan 
     readType:READ_TYPE_SHORT_BIG_ENDIAN];
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_set_short_return(port_t dspdriver_port, port_t owner_port,
		       int regionTag, int wordCount,
		       port_t reply_port, int chan, int unit)
/* Like dsp_set_short_big_endian_return, but returns little-endian */
{
    unitCheck(); ownerCheck(); checkChanAndWordCount(short);
    /*  SET DMA OUT VARIABLES  */
    [classVars.driverObjects[unit] setDSPReadRegionTag:regionTag
     wordCount:wordCount replyPort:reply_port chan:chan
     readType:READ_TYPE_SHORT];
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_set_long_return(port_t dspdriver_port, port_t owner_port,
			       int regionTag, int wordCount,
			       port_t reply_port, int chan, int unit)
/* Returns 24 bits, right justified in 32 bits */
{
    unitCheck(); ownerCheck(); checkChanAndWordCount(int);
    /*  SET DMA OUT VARIABLES  */
    [classVars.driverObjects[unit] setDSPReadRegionTag:regionTag
     wordCount:wordCount replyPort:reply_port chan:chan
     readType:READ_TYPE_LONG];
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_set_error_port(port_t dspdriver_port, port_t owner_port,port_t reply_port,
		     int unit)
{
    unitCheck(); ownerCheck(); 
    [classVars.driverObjects[unit] setErrorPort:reply_port];
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_set_msg_port(port_t dspdriver_port, port_t owner_port,port_t reply_port,
		   int unit)
{
    unitCheck(); ownerCheck(); 
    [classVars.driverObjects[unit] setMsgPort:reply_port];
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_set_debug(port_t dspdriver_port, int debug_flags)
{
    /* No ownerCheck here so we can call it from other processes */
    debugFlags = debug_flags;
    IOLog("dsp debugging flags set to 0x%x\n",debug_flags);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_free_page(port_t dspdriver_port, port_t owner_port,int pageIndex, int unit)
{
    /* No ownerCheck here so we can call it from other processes */
    unitCheck(); ownerCheck();
    [classVars.driverObjects[unit] deallocPage:pageIndex];
    return KERN_SUCCESS;
}


#import "dspdriver_dspInitiatedTransfer.m"

