<!-- $Id$ -->
  <chapter id="MusicSynthAndProc">
    <title>Music Synthesis and Processing</title>

    <sect1 id="MusicSynthesisAndProcessing">
      <title>Music Synthesis and Processing</title>

      <para>In this document &ldquo;synthesis&rdquo; refers to
creating sound from scratch, while &ldquo;processing&rdquo; refers to
modifying sound from elsewhere.  However, the
<productname>MusicKit</productname> provides a unified model of
synthesis and processing.  Thus, nearly all operations that apply to
synthesis can also be used in sound processing.</para>

      <para>There are four levels of
<productname>MusicKit</productname> classes involved in synthesizing
and processing music on the <acronym>DSP</acronym>:</para>

      <itemizedlist>
	<listitem>
	  <para>At the top level is the
<classname>MKSynthInstrument</classname> class; an inheritor from
<classname>MKInstrument</classname>, it provides an interface between
the <productname>MusicKit</productname> performance mechanism and
<acronym>DSP</acronym> synthesis/processing.  A
<classname>MKSynthInstrument</classname> distributes
<classname>MKNote</classname>s that it receives during a performance
to individual <classname>MKSynthPatch</classname> objects that control
the actual synthesis/processing.
	  </para>
	</listitem>

	<listitem>
	  <para><classname>MKSynthPatch</classname>, an abstract
class, embodies the principles of music synthesis.  Each subclass of
<classname>MKSynthPatch</classname> represents a particular
synthesis/processing strategy; each
<classname>MKSynthPatch</classname> object synthesizes one
<classname>MKNote</classname> at a time, using the strategy defined by
its class.
	  </para>
	</listitem>

	<listitem>
	  <para>The <classname>MKUnitGenerator</classname> class is
also abstract; each of its subclasses represents a signal processing
function that runs on the <acronym>DSP</acronym>.  These are the basic building blocks of
music synthesis/processing that a <classname>MKSynthPatch</classname>
subclass configures to define its synthesis/processing strategy.  At
the same level as <classname>MKUnitGenerator</classname> is the
<classname>MKSynthData</classname> class.  Instances of
<classname>MKSynthData</classname> represent portions of <acronym>DSP</acronym> memory
that hold synthesis/processing data such as wavetables and delay
memory.  In addition, <classname>MKSynthData</classname> objects are
used to transmit data between <classname>MKUnitGenerator</classname>
objects.
	  </para>
	</listitem>

	<listitem>
	  <para>The <classname>MKOrchestra</classname> represents the
<acronym>DSP</acronym> itself.  It manages the allocation of <acronym>DSP</acronym> resources and controls
communication between the <acronym>DSP</acronym> and the host.  Requests for use of the
<acronym>DSP</acronym> are always made through messages to the
<classname>MKOrchestra</classname>; this includes requests made by a
<classname>MKSynthInstrument</classname> for more
<classname>MKSynthPatch</classname>es, and those of a
<classname>MKSynthPatch</classname> for
<classname>MKUnitGenerator</classname>s and
<classname>MKSynthData</classname> objects.
	  </para>
	</listitem>
      </itemizedlist>

      <figure id="synthesis">
	<title>Synthesis classes</title>
	<mediaobject>
	  <imageobject><imagedata fileref="Images/MusicSynthesis.eps"></imageobject>
	  <imageobject><imagedata fileref="Images/MusicSynthesis.gif"></imageobject>
	  <textobject><phrase>MusicKit Image</phrase></textobject>
	</mediaobject>
      </figure>

      <para>The <classname>MKSynthInstrument</classname> class is described in <xref
	  linkend="MusicPerformance">. The rest of this chapter is devoted to
	the other classes listed above.</para>
    </sect1>
    <sect1 id="TheMKOrchestraClass">
      <title>The <classname>MKOrchestra</classname> Class</title>

      <para>The <classname>MKOrchestra</classname> class manages <acronym>DSP</acronym>
	resources used in music synthesis/processing.  Each instance of
	<classname>MKOrchestra</classname> represents a single <acronym>DSP</acronym>; in the
	basic NeXT configuration, there's only one <acronym>DSP</acronym> so you create only one
	<classname>MKOrchestra</classname> object.
      </para>

      <para>The methods defined by the <classname>MKOrchestra</classname>
class let you manage a <acronym>DSP</acronym> by allocating portions of its memory for
specific synthesis/processing modules and by setting its processing
characteristics.</para>

      <para>You can allocate entire <classname>MKSynthPatch</classname>es or
individual <classname>MKUnitGenerator</classname> and
<classname>MKSynthData</classname> objects through
<classname>MKOrchestra</classname> methods.  Primary among these
are:</para>

      <itemizedlist>
	<listitem><para><emphasis role="bold">allocSynthPatch:</emphasis>
allocates an instance of the given <classname>MKSynthPatch</classname>
subclass.</para></listitem>

	<listitem><para><emphasis role="bold">allocUnitGenerator:</emphasis>
	    does the same for a <classname>MKUnitGenerator</classname>
	    subclass.</para></listitem>

	<listitem><para><emphasis
	      role="bold">allocSynthData:length:</emphasis> allocates a portion of
	    <acronym>DSP</acronym> memory of a given length.</para></listitem>
      </itemizedlist>

<para>Keep in mind, however, that similar methods defined in other
classes&horbar;specifically, the <classname>MKSynthPatch</classname>
allocation methods defined in
<classname>MKSynthInstrument</classname>, and the
<classname>MKUnitGenerator</classname> and
<classname>MKSynthData</classname> allocation methods defined in
<classname>MKSynthPatch</classname>&horbar;are built upon and designed
to usurp the allocation methods defined by
<classname>MKOrchestra</classname>.  You only to need to allocate
synthesis/processing objects directly if you want to assemble
sound-making modules at a low level.</para>

      <sect2 id="InteractivityVersusDependability">
	<title>Interactivity versus Dependability</title>

<para>Different applications have different needs. When playing a
sequence or scorefile, it is essential that the timing of the notes be
precise and a bit of latency is tolerable. On the other hand, when
playing the <acronym>DSP</acronym> from a <acronym>MIDI</acronym>
keyboard, the critical element is to keep response time to a
minimum. In the first case, you should set the
<classname>MKOrchestra</classname> to &ldquo;timed mode&rdquo; by
sending <emphasis role="bold">[orchestra setTimed:YES]</emphasis>,
while in the second case, you should set the
<classname>MKOrchestra</classname> to &ldquo;untimed mode&rdquo; by
sending <emphasis role="bold">[orchestra setTimed:NO]</emphasis>.  In
addition, when performing from a keyboard, you should call
<function>MKSetRealTimeEnvelopes(YES)</function> before allocating
your <classname>MKSynthPatch</classname>es.  This has the effect of
setting the <productname>MusicKit</productname>
<classname>MKSynthPatch</classname>es to use a version of the envelope
handler that is best-suited to the interactive situation. Actually,
<function>MKSetRealTimeEnvelopes(YES)</function> may be used for
either case; its only drawback is that it does not allow for
arbitrarily long envelopes. In timed mode, the fixed latency is set by
the function <function>MKSetDeltaT()</function>.  For example,
<function>MKSetDeltaT(.1)</function> sets a fixed latency
of a tenth of a second.</para>
</sect2>
<sect2 id="SharingAllocations">
<title>Sharing Allocations</title>

<para>To avoid creating duplicate synthesis/processing modules on the
<acronym>DSP</acronym>, each instance of
<classname>MKOrchestra</classname> maintains a shared object table.
Objects on the table are <classname>MKSynthPatch</classname>es,
<classname>MKSynthData</classname>s, and
<classname>MKUnitGenerator</classname>s; each is indexed by some other
object that represents the shared object.  For example, the
<classname>OscgafUG</classname> <classname>MKUnitGenerator</classname>
(a family of oscillators) lets you specify its waveform-generating
wave table as a <classname>MKPartials</classname> object (you can also
set it as a <classname>MKSamples</classname> object; for the purposes
of this example we only consider the <classname>MKPartials</classname>
case).  When its wave table is set through the <emphasis
role="bold">setTable:length:</emphasis> method, the oscillator
allocates a <classname>MKSynthData</classname> object from the
<classname>MKOrchestra</classname> to represent the
<acronym>DSP</acronym> memory that will hold the waveform data
computed from the <classname>MKPartials</classname>.  It also places
the <classname>MKSynthData</classname> on the shared object table
using the <classname>MKPartials</classname> as an index by sending the
message</para>

<programlisting>
[MKOrchestra installSharedSynthData: theSynthData for: thePartials];
</programlisting>

<para>If another oscillator's wave table is set as the same
<classname>MKPartials</classname> object, the already allocated
<classname>MKSynthData</classname> can be returned by sending the
message:</para>

<programlisting>
id aSynthData = [MKOrchestra sharedObjectFor: thePartials];
</programlisting>

<para>The method <emphasis
role="bold">installSharedObject:for:</emphasis> is provided for
installing <classname>MKSynthPatch</classname>es and
<classname>MKUnitGenerator</classname>s.</para>
</sect2>
<sect2 id="OrchestrasDeviceStatus">
<title><classname>MKOrchestra</classname>'s Device Status</title>

<para>Before you can do anything with an
<classname>MKOrchestra</classname>&horbar;particularly, before you can
allocate synthesis/processing objects&horbar;you must create and open
it.  As usual, creation is done through the <emphasis
role="bold">alloc</emphasis> and <emphasis role="bold">init</emphasis>
methods; to open an <classname>MKOrchestra</classname>, you send it
the <emphasis role="bold">open</emphasis> message.  This provides a
channel of communication with the <acronym>DSP</acronym> that the
<classname>MKOrchestra</classname> represents.  The <acronym>DSP</acronym> can be opened
by only one application at a time, so you should always check the
value returned by open; the method returns <emphasis
role="bold">nil</emphasis> if the <acronym>DSP</acronym> couldn't be opened.</para>

<para>Once you've allocated the objects that you want, either through
the methods described above or through those defined by
<classname>MKSynthInstrument</classname> and
<classname>MKSynthPatch</classname>, you can start the
synthesis/processing by sending the <emphasis
role="bold">run</emphasis> message to the
<classname>MKOrchestra</classname>.  The <emphasis
role="bold">stop</emphasis> method halts synthesis/processing and
<emphasis role="bold">close</emphasis> breaks communication with the
<acronym>DSP</acronym>.  These methods change the <classname>MKOrchestra</classname>'s
status, which is always one of the following MKDeviceStatus
values:</para>

      <table frame=all><title><classname>MKOrchestra status</classname></title>
	<tgroup cols=2 colsep=1 rowsep=1>
	  <colspec colnum=1 align=left>
	  <colspec colnum=2 align=left>
	  <thead>
	    <row>
	      <entry>Status</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
<entry><constant>MK_devOpen</constant></entry>
<entry>The <classname>MKOrchestra</classname> is open but not running.</entry>
	    </row>
	    <row>
<entry><constant>MK_devRunning</constant></entry>
<entry>The <classname>MKOrchestra</classname> is open and running.</entry>
	    </row>
	    <row>
<entry><constant>MK_devStopped</constant></entry>
<entry>The <classname>MKOrchestra</classname> has been running but is now stopped.</entry>
	    </row>
	    <row>
<entry><constant>MK_devClosed</constant></entry>
<entry>The <classname>MKOrchestra</classname> is closed.</entry>
	    </row>
	</tbody>
      </tgroup>
    </table>


<para>You can query an <classname>MKOrchestra</classname>'s status
through the <emphasis role="bold">deviceStatus</emphasis>
method.</para>
</sect2>
<sect2 id="MKOrchestraOutput">
<title><classname>MKOrchestra</classname> Output</title>

<para>When the <classname>MKOrchestra</classname> is running it
produces a stream of samples that, by default, are sent to the stereo
digital to analog converter (<acronym>DAC</acronym>), which converts
the samples into an audio signal.  But there are two other
options:</para>

		<orderedlist>
<listitem><para>You can tell the <classname>MKOrchestra</classname> to
write the samples to a soundfile by invoking the method <emphasis
role="bold">setOutputSoundfile:</emphasis> (you must set the soundfile
before sending <emphasis role="bold">run</emphasis> to the
<classname>MKOrchestra</classname>).</para>
		  </listitem>
<listitem><para>You can tell the <classname>MKOrchestra</classname> to
write the samples to the <acronym>DSP</acronym> serial port by invoking the method
<emphasis role="bold">setSerialSoundOut:</emphasis> (you must set this
before sending <emphasis role="bold">run</emphasis> to the
<classname>MKOrchestra</classname>).  For more information, see <xref
linkend="UsingTheDSPSerialPort"> below.</para>
		  </listitem>
		</orderedlist>

<para>Note that you may not combine these output routes&horbar;the
sound can only go to one destination at a time.</para>

</sect2>
<sect2 id="UsingTheDSPSerialPort">
<title>Using the <acronym>DSP</acronym> Serial Port</title>

<para>One of the most powerful aspects of the <productname>MusicKit</productname> is its seamless
integration with the NeXT <acronym>DSP</acronym> serial port.  There are three main uses
for the serial port:</para>

<orderedlist>
<listitem>
<para>Direct to <acronym>DAT</acronym> transfers of sound in or out of the <productname>MusicKit</productname></para>
</listitem>

<listitem>
<para>For very high quality digital-to-analog conversion.</para>
</listitem>

<listitem>
<para>For high quality analog-to-digital conversion.</para>
</listitem>
</orderedlist>

<para>The standard NeXT configuration (at the time of this writing)
does not include a high-quality sound input.  Therefore, in order to
do real-time high-quality sound processing, you need to obtain a
device that plugs into the <acronym>DSP</acronym> serial port.
Similarly, you may want to use the <acronym>DSP</acronym> serial port
for high-quality sound output to an outboard digital-to-analog
converter or for direct digital transfer to or from a
<acronym>DAT</acronym> machine.</para>

<para>A number of such devices are commercially available.
Metaresearch sells the DigitalEars, an analog-to-digital converter.
Ariel has an analog-to-digital converter called the Digital
Microphone.  Ariel also sells the ProPort analog-to-digital and
digital-to-analog converter, as well as the DatPort DAT interface.
Stealth sells the DAI2400 DAT interface.  Singular Solutions sells the
AD64x, which is a combination analog-to-digital converter and DAT
interface.</para>

<para>To set up the <classname>MKOrchestra</classname> to do sound
input via the <acronym>DSP</acronym> serial port, you send it the message:</para>

<programlisting>
[orchestra setSerialSoundIn:YES];
</programlisting>

<para>To set up the <classname>MKOrchestra</classname> to do sound
output via the <acronym>DSP</acronym> serial port, you send it the message:</para>

<programlisting>
[orchestra setSerialSoundOut:YES];
</programlisting>

<para>You may simultaneously do serial port input and output.
Alternatively, you may combine serial port input with normal NeXT
sound output.</para>

<para>You may additionally provide an object that tells the <productname>MusicKit</productname>
about the kind of device you have connected to the <acronym>DSP</acronym> serial port.
To do this you send the message:</para>

<programlisting>
[orchestra setSerialPortDevice:aSerialPortDevice];
</programlisting>

<para>aSerialPortDevice must be an instance of the <productname>MusicKit</productname> class
DSPSerialPortDevice or one of its subclasses.  The class
DSPSerialPortDevice itself provides a general-purpose interface to a
number of common devices.  It supports
<productname>DigitalEars</productname>, the <productname>Ariel Digital
Microphone</productname>, <productname>DatPort</productname> and
<productname>ProPort</productname>.  However, some devices have
special requirements and features.  The Stealth DAI2400 is supported
by the StealthDAI2400 class, which is a subclass of
DSPSerialPortDevice; similarly, the Singular Solutions AD64x is
supported by the SSAD64x class.  You must use these subclasses when
using these devices.  The devices are not compatible with the generic
interface provided by DSPSerialPortDevice.  For example, to use the
<productname>AD64x</productname>:</para>

<programlisting>
#import &lt;MusicKit/DSPSerialPortDevice.h&gt;
[orchestra setSerialPortDevice:[[SSAD64x alloc] init]];
</programlisting>

<para>For details on implementing your own DSPSerialPortDevice
subclass, see the DSPSerialPortDevice class description in the
file <filename>Classes/DSPSerialPortDevice.rtf</filename>.</para>

</sect2>
</sect1>
<sect1 id="TheMusicKitMKSynthPatchSubclasses">
<title>The <productname>MusicKit</productname> <classname>MKSynthPatch</classname> Subclasses</title>

<para>The <productname>MusicKit</productname> provides a number of
<classname>MKSynthPatch</classname> subclasses, instances of which you
can use in your application.  <classname>MKSynthPatch</classname>
objects are &ldquo;data-driven&rdquo;; during a performance, they're
sent <classname>MKNote</classname> objects (through methods described
in the next section) from which they pluck the parameters of interest.
Thus, in order to use a <classname>MKSynthPatch</classname>, you must
know not only what sort of synthesis/processing it embodies, but which
parameters it expects to see in the <classname>MKNote</classname>s it
receives.  A table of the <productname>MusicKit</productname> parameters organized by
<classname>MKSynthPatch</classname> synthesis/processing technique is
given in <xref linkend="MusicTables">. Below, some of the <productname>MusicKit</productname>
<classname>MKSynthPatch</classname> subclasses are listed and briefly
described. For a complete list, see <filename
class=headerfile>&lt;MusicKit/synthpatches/synthpatches.h&gt;</filename>.</para>

<tip><para>When doing synthesis in a realtime interactive context,
such as when playing it from a <acronym>MIDI</acronym> keyboard, you should invoke
<emphasis role="bold">[orchestra setTimed:NO]</emphasis> and call
<function>MKUseRealTimeEnvelopes(YES)</function> before
allocating the <classname>MKSynthPatch</classname>.</para></tip>

<sect2 id="Pluck">
<title><classname>Pluck</classname></title>

<para><classname>Pluck</classname> employs physical modelling to
synthesize the sound of a plucked string, using a technique developed
by Alex Strong, Kevin Karplus, David Jaffe and Julius Smith.  The
real-world mechanics of a plectrum plucking a string are replaced on
the <acronym>DSP</acronym> by a burst of noise filling a length of
delay memory.  The delay memory is looped and filtered, causing the
initial noise burst to gradually become more harmonic as the spectral
energy subsides towards the fundamental, emulating the strike-and-fade
characteristics of a real plucked string.</para>

</sect2>
<sect2 id="WavetableSynthesis">
<title>Wavetable Synthesis</title>

<para>Wavetable synthesis is a technique in which a length of memory
is filled with one or more periods of a waveform; the memory is then
looped during playback to produce a continuous signal.  While
wavetable synthesis is extremely easy to use&horbar;no messy formulas
are needed to create a musical timbre&horbar;it's somewhat limited to
the extent that you don't have control over the individual elements
that create the timbre (which you do with techniques such as frequency
modulation).</para>

<para>The <productname>MusicKit</productname>'s wavetable synthesis
<classname>MKSynthPatch</classname>es use single-period wavetables;
they are:</para>

      <table frame=all><title><classname>MKSynthPatch</classname> Descriptions</title>
	<tgroup cols=2 colsep=1 rowsep=1>
	  <colspec colnum=1 align=left>
	  <colspec colnum=2 align=left>
	  <thead>
	    <row>
<entry><classname>MKSynthPatch</classname></entry>
<entry>Description</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
<entry><classname>Wave1</classname></entry>
<entry>One wavetable</entry>
</row>
<row>
<entry><classname>Wave1v</classname></entry>
<entry>One wavetable with vibrato</entry>
</row>
<row>
<entry><classname>Wave1i</classname></entry>
<entry>One wavetable with frequency interpolation</entry>
</row>
<row>
<entry><classname>Wave1vi</classname></entry>
<entry>One wavetable with vibrato and interpolation</entry>
</row>
<row>
<entry><classname>DBWave1v</classname></entry>
<entry>One database wavetable with vibrato</entry>
</row>
<row>
<entry><classname>DBWave1vi</classname></entry>
<entry>One database wavetable with vibrato and interpolation</entry>
</row>
<row>
<entry><classname>DBWave2vi</classname></entry>
<entry>Two database wavetables with vibrato and interpolation</entry>
</row>
</tbody>
</tgroup>
</table>

<para>The database wavetable <classname>MKSynthPatch</classname>es
access the <productname>MusicKit</productname>'s <classname>MKWaveTable</classname> Database, a
library of predefined timbres.  These are listed in <xref
linkend="MusicTables">.</para>
</sect2>
<sect2 id="FrequencyModulation">
<title>Frequency Modulation</title>

<para>In frequency modulation (<acronym>FM</acronym>) synthesis, the
output of one oscillator controls the frequency of another oscillator.
If the frequency of the controlling oscillator (or
&ldquo;modulator&rdquo;) is subaudio, the tone produced by the
controlled oscillator (or &ldquo;carrier&rdquo;) will exhibit vibrato.
However, as the modulator's frequency is increased, the carrier's
vibrato also increases until the individual undulation become
indistinguishable and sidebands, or reflections of the modulator's
frequency around the carrier's frequency, appear.  If the oscillators
are producing sine waves with identical or harmonically-related
frequencies, the sidebands produce a harmonic series.  As the
oscillators' waveforms become more complex, the sidebands become more
numerous, but they may still produce a harmonic series.  However, if
the oscillators' frequencies aren't harmonically related, the result
can be a clangorous mess (which is good if you're trying to make bell
sounds, one of the more popular and occasionally unavoidable results
of <acronym>FM</acronym> synthesis).</para>

      <table frame=all><title><acronym>FM</acronym> <classname>MKSynthPatch</classname> Descriptions</title>
	<tgroup cols=2 colsep=1 rowsep=1>
	  <colspec colnum=1 align=left>
	  <colspec colnum=2 align=left>
	  <thead>
	    <row>
<entry><classname>MKSynthPatch</classname></entry>
<entry>Description</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
<entry><classname>Fm1</classname></entry>
<entry>Simple (one-modulator) <acronym>FM</acronym></entry>
</row>
<row>
<entry><classname>Fm1i</classname></entry>
<entry>Simple <acronym>FM</acronym> with frequency interpolation</entry>
</row>
<row>
<entry><classname>Fm1v</classname></entry>
<entry>Simple <acronym>FM</acronym> with vibrato</entry>
</row>
<row>
<entry><classname>Fm1vi</classname></entry>
<entry>Simple <acronym>FM</acronym> with interpolation and vibrato</entry>
</row>
<row>
<entry><classname>Fm2cvi</classname></entry>
<entry>Cascade <acronym>FM</acronym></entry>
</row>
<row>
<entry><classname>Fm2cnvi</classname></entry>
<entry>Cascade <acronym>FM</acronym> with random modulation (noise) on the modulators</entry>
</row>
<row>
<entry><classname>Fm2pvi</classname></entry>
<entry>Parallel <acronym>FM</acronym></entry>
</row>
<row>
<entry><classname>Fm2pnvi</classname></entry>
<entry>Parallel <acronym>FM</acronym> with noise</entry>
</row>
</tbody>
</tgroup>
</table>

</sect2>
<sect2 id="WaveshapingSynthesis">
<title>Waveshaping Synthesis</title>

<para>There are two waveshaping <classname>MKSynthPatch</classname>es,
<classname>Shape</classname> and <classname>Shapev</classname>.  They
differ in that the vibrato parameters are supported only by
<classname>Shapev</classname>.</para>

<para>These <classname>MKSynthPatch</classname>es implement non-linear
distortion synthesis, which means that they produce sound by using an
oscillator to drive a lookup table.  Normally, the oscillator is a
sine wave and the complexity of the resulting waveform is a function
of the lookup table.  However, for added flexibility, you may set the
oscillator waveform to anything you want.</para>
</sect2>
</sect1>
<sect1 id="BuildingAMKSynthPatch">
<title>Building a <classname>MKSynthPatch</classname></title>

<para>The <classname>MKSynthPatch</classname> class is abstract; each
subclass of <classname>MKSynthPatch</classname> describes a unique
strategy for creating a musical sound.  It does this by implementing
methods that provide two things:</para>

<itemizedlist>
<listitem><para>A <emphasis>patch</emphasis> specification.  A patch is a configuration of <acronym>DSP</acronym> synthesis/processing elements.</para></listitem>

<listitem><para>A scheme for playing the patch.  This consists of
defining the conditions in which the patch is turned on and off and
how <classname>MKNote</classname> parameters are used to control it
while it's running.</para></listitem>
</itemizedlist>

<para>Designing a patch is actually quite simple: The
<productname>MusicKit</productname> provides an object-oriented
interface to the <acronym>DSP</acronym>, thus protecting the
<classname>MKSynthPatch</classname> designer from the rigors of
programming directly in <hardware>MC56000</hardware> assembly code.
While concern for efficiency makes some knowledge of
<acronym>DSP</acronym> memory organization necessary,
<classname>MKSynthPatch</classname> design makes greater demands of
your imagination in creating new sound-making schemes than of your
ability to examine and grasp the small print of signal
processing.</para>

<para>The <productname>MusicKit</productname> defines a number of
conventions for controlling a patch.  Most of these conventions are
manifested as methods that are declared as subclass responsibilities
by the <classname>MKSynthPatch</classname> class.  Other conventions
are given as general guidelines that should be followed to maintain
consistency with the <classname>MKSynthPatch</classname> subclasses
provided by the <productname>MusicKit</productname>.</para>

<sect2 id="ASimpleMKSynthPatch">
<title>A Simple <classname>MKSynthPatch</classname></title>

<para>This section describes, by example, the basic steps for creating
a <classname>MKSynthPatch</classname> subclass.  The example
<classname>MKSynthPatch</classname> produces a single sine wave (with
a settable frequency, amplitude, and bearing) for each
<classname>MKNote</classname> it receives.  The design is broken into
two parts: designing the patch specification, and playing the patch.
While the methodology shown for playing the patch introduces a number
of <classname>MKSynthPatch</classname> design conventions, it lacks
some important features that enhance musical flexibility.  These
features are shown in the more complex
<classname>MKSynthPatch</classname> design demonstrated in 
<xref linkend="ABetterMKSynthPatch">, later in this chapter.</para>

<important>
<title><filename>exampleSynthPatch</filename></title> 

<para>Please see the programming example
<filename>./Examples/MusicKit/exampleSynthPatch</filename>.  It
illustrates a variety of <classname>MKSynthPatch</classname>es.  These
range from a sophisticated <acronym>FM</acronym>
<classname>MKSynthPatch</classname> with vibrato and a wide variety of
parameters settable at any time, to a simple
<classname>MKSynthPatch</classname> designed for applications that
assume traditional computer music scorefile semantics (such as are
assumed by <productname>MUSIC-5</productname>,
<productname>CMUSIC</productname>, <productname>CSOUND</productname>,
etc.).  Much of the complexity of <classname>MKSynthPatch</classname>
design is eliminated if the traditional restrictions are
adopted.</para>
</important>

<sect3 id="DesigningThePatchSpecification">
<title>Designing the Patch Specification</title>

<para>Every <classname>MKSynthPatch</classname> contains a recipe for
creating a patch.  The ingredients of the patch are
<classname>MKUnitGenerator</classname> and
<classname>MKSynthData</classname> objects (collectively referred to
as <emphasis>synthElements</emphasis>):</para>

<itemizedlist>
<listitem><para>Each <classname>MKUnitGenerator</classname> subclass
represents a specific signal processing function.  The <productname>MusicKit</productname>
supplies a number of <classname>MKUnitGenerator</classname> subclasses
that perform functions such as creating and combining signals,
filtering, and adding the finished product to the output sample
stream.</para></listitem>

<listitem><para><classname>MKSynthData</classname> objects represent
data.  These objects can be used for downloading information to the
<acronym>DSP</acronym>; for example, a <classname>MKWaveTable</classname> is represented
on the <acronym>DSP</acronym> as a <classname>MKSynthData</classname>.  Another important
use of a <classname>MKSynthData</classname> is to provide a location
through which one <classname>MKUnitGenerator</classname> can send data
to another <classname>MKUnitGenerator</classname>.  This type of
<classname>MKSynthData</classname> object is called a
<emphasis>patchpoint</emphasis>.</para></listitem>
</itemizedlist>

<para>The list of synthElement specifications and instructions for
connecting these elements to each other are encapsulated in a
<classname>MKPatchTemplate</classname> object.  Every <classname>MKSynthPatch</classname>
subclass creates at least one <classname>MKPatchTemplate</classname>&horbar;most create only
one.  A <classname>MKPatchTemplate</classname> is created and returned by the
<classname>MKSynthPatch</classname> class method <emphasis
role="bold">patchTemplateFor:</emphasis>, a subclass responsibility.
In the following example, a single sine wave
<classname>MKSynthPatch</classname> is declared and its <emphasis
role="bold">patchTemplateFor:</emphasis> method is implemented:</para>

<programlisting>
/* The following files must be imported. */
#import &lt;MusicKit/MusicKit.h&gt;
#import &lt;MusicKit/unitgenerators.h&gt;

/* We call our simple SynthPatch 'Simplicity'. */
@implementation Simplicity

/* A static integer is created for each synthElement. */
static int  osc,              /* sine wave UnitGenerator */
            stereoOut,        /* sound output UnitGenerator */
            outPatchpoint;    /* SynthData */

+ patchTemplateFor:aNote
/* The argument is ignored in this implementation. */
{
    /*
     * Step 1:  Create an instance of the PatchTemplate class.  This 
     * method is automatically invoked each time the MKSynthPatch
     * receives a Note.  However, the PatchTemplate should only be 
     * created the first time this method is invoked.  If the object 
     * has already been created, it's immediately returned.
     */
    static id theTemplate = nil;
    if (theTemplate)
        return theTemplate;
    theTemplate = [PatchTemplate new];
    /*
     * Step 2:  Add synthElement specifications to the PatchTemplate.
     * The first two are UnitGenerators; the last is a SynthData 
     * that's used as a patchpoint.
     */
    osc = [theTemplate addUnitGenerator:[OscgUGxy class]];
    stereoOut = [theTemplate addUnitGenerator:[Out2sumUGx class]];
    outPatchpoint = [theTemplate addPatchpoint:MK_xPatch];
    /* 
     * Step 3:  Specify the connections between synthElements. 
     */
    [theTemplate to:osc sel:@selector(setOutput:) arg:outPatchpoint];
    /* Always return the PatchTemplate. */
    return theTemplate;
}
</programlisting>

<para>After creating the <classname>MKPatchTemplate</classname>
instance (step 1 in the example), synthElement specifications are
added to it (step 2) using methods defined by the
<classname>MKPatchTemplate</classname> class.  There are three basic
methods to do this (a fourth method will be discussed later):</para>

<itemizedlist>
<listitem><para>addUnitGenerator:</para></listitem>

<listitem><para>addSynthData:length:</para></listitem>

<listitem><para>addPatchpoint:</para></listitem>
</itemizedlist>

<para>Each of these methods returns an integer value that's used as an
index to the added synthElement.  Subsequent references to the
synthElements are always made through these indices.  Since all
instances of a particular <classname>MKSynthPatch</classname> subclass
use the same set of indices, the variables that store the values
returned by these methods must be declared statically and be made
global to the entire class.</para>

<para>Finally, instructions for connecting the synthElements are
specified by invoking <classname>MKPatchTemplate</classname>'s <emphasis
role="bold">to:sel:arg:</emphasis> method (step 3).  The arguments to
this method are the receiver, selector, and argument, respectively, of
a message that will be sent when a <classname>MKSynthPatch</classname>
instance is created.  Simplicity specifies a single connection:</para>

<programlisting>
[theTemplate to:osc sel:@selector(setOutput:) arg:outPatchpoint]
</programlisting>

<para>When an instance of Simplicity is created and played, the output
of the <classname>MKUnitGenerator</classname> indexed by <emphasis
role="bold">osc</emphasis> will be set to the
<classname>MKSynthData</classname> indexed by <emphasis
role="bold">outPatchpoint</emphasis>.</para>

<sect4 id="SimplicitysSynthElementsExamined">
<title>Simplicity's SynthElements Examined</title>

<para>To understand the synthElements used in the example, you need to
be familiar with a simple detail of <acronym>DSP</acronym> memory organization.  <acronym>DSP</acronym>
memory is divided into three sections, x, y, and p.  x and y memory
are used for data; p memory is used for program code.  Thus,
<classname>MKSynthData</classname> objects represent data in either x
or y memory, while <classname>MKUnitGenerator</classname>s represent
<acronym>DSP</acronym> functions that always reside in p memory.  This is illustrated in
<xref linkend="DSPMemoryDivision">.</para>

<figure id="DSPMemoryDivision">
<title>DSP Memory Division</title>
<mediaobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc0.eps"></imageobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc0.gif"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

<para>The <productname>MusicKit</productname> further divides
<acronym>DSP</acronym> memory into logical segments, represented as
integer constants.  In designing a
<classname>MKSynthPatch</classname>, you only need to be concerned
with four of these segments:</para>

<itemizedlist>
<listitem><para><constant>MK_xPatch</constant> is used for
patchpoints in x memory.</para></listitem>

<listitem><para><constant>MK_yPatch</constant> is for
patchpoints in y memory.</para></listitem>

<listitem><para><constant>MK_xData</constant> is for
non-patchpoint <classname>MKSynthData</classname> objects in x
memory.</para></listitem>

<listitem><para><constant>MK_yData</constant> is for
non-patchpoint <classname>MKSynthData</classname> objects in y
memory.</para></listitem>
</itemizedlist>

<para>A <classname>MKSynthData</classname> object is specified by its
segment.  For example, Simplicity's patch contains a single
<classname>MKSynthData</classname> (a patchpoint) that resides in x
memory, as set in the message</para>

<programlisting>
/* Add an x segment patchpoint. */
[theTemplate addPatchpoint:MK_xPatch]
</programlisting>

<para><classname>MKUnitGenerator</classname>s also refer to x and y
memory in order to properly read and write data.  Recall the first
<classname>MKUnitGenerator</classname> added to Simplicity's
patch:</para>

<programlisting>
[theTemplate addUnitGenerator:[OscgUGxy class]]
</programlisting>

<para>The &ldquo;x&rdquo; and &ldquo;y&rdquo; in the class name
<classname>OscgUGxy</classname> refer to x and y memory spaces,
respectively.  <classname>OscgUGxy</classname> is a simple
<classname>MKUnitGenerator</classname> that has a single input for
reading data and a single output for writing data.  The order of these
data spigots, or <emphasis>memory arguments</emphasis>, is given in
the <classname>MKUnitGenerator</classname> name as output followed by
input.  Thus, <classname>OscgUGxy</classname>'s writes data to x
memory (output) and reads it from y memory (input).  The
<productname>MusicKit</productname> provides a class for each memory
permutation: <classname>OscgUGyy</classname>,
<classname>OscgUGyx</classname>, <classname>OscgUGxy</classname>, and
<classname>OscgUGxx</classname>.  These are called <emphasis>leaf
classes</emphasis> of the <emphasis>master class</emphasis>
<classname>OscgUG</classname>.  Aside from the differing memory references, the
leaf classes are exactly the same.  Every
<classname>MKUnitGenerator</classname> function provided by the
<productname>MusicKit</productname> is similarly organized into a
master class and a complete set of leaf classes.</para>

<tip><para>When describing a
subclass of <classname>MKUnitGenerator</classname>, it's convenient to
refer to the master class rather than a specific leaf class.
Furthermore, the &ldquo;UG&rdquo; (which stands for
&ldquo;<classname>MKUnitGenerator</classname>&rdquo;) is often dropped
from the master class name.</para></tip>

<para>The <classname>Oscg</classname> family of
<classname>MKUnitGenerator</classname>s provides a general oscillator
function (the &ldquo;g&rdquo; in <classname>Oscg</classname> stands
for &ldquo;general&rdquo;).  An oscillator is a module that creates a
signal by cycling over a table of values, called a <emphasis>lookup
table</emphasis>, that represents a single period of a waveform.  In a
general oscillator, the lookup table isn't part of the
<classname>MKUnitGenerator</classname>.  You can supply the oscillator
with a lookup table by using a <classname>MKWaveTable</classname>
object (this will be demonstrated in a subsequent example).
Alternatively, the oscillator can use the built-in sineROM, a
read-only section of y memory that contains a single period of a sine
wave.  Simplicity's <classname>OscgUGxy</classname> does the latter: It reads the
sineRom, therefore its input <emphasis>must</emphasis> read from y
memory.  In the example, the connection between the sineROM and
<classname>OscgUGxy</classname> is made by default&horbar;it needn't be specified
through the <emphasis role="bold">to:sel:arg:</emphasis>
method.</para>

<para>One of the conventions of designing a patch is to balance, as
much as possible, the use of x and y memory.  Since Simplicity's
oscillator must read from y memory in order to read the sineROM, its
output is set to x memory.  So of the four <classname>Oscg</classname>
leaf classes, <classname>OscgUGxy</classname> is chosen.</para>

<para>The other <classname>MKUnitGenerator</classname> in Simplicity's
patch, <classname>Out2sumUGx</classname>, is a special <classname>MKUnitGenerator</classname>
that adds a stream of (two-channel) sample data to the stereo output
sample stream.  The single memory argument (the &ldquo;x&rdquo; in
<classname>Out2sumUGx</classname>) is the <classname>MKUnitGenerator</classname>'s input.
Simplicity uses the <classname>Out2sumUGx</classname> leaf class so the
<classname>MKUnitGenerator</classname> can read the
<constant>MK_xPatch</constant> patchpoint that's written to by
<classname>OscgUGxy</classname>.  <xref linkend="SimplicitysPatch"> shows a diagram of the
complete patch, superimposed on the <acronym>DSP</acronym> memory
layout.</para>

<figure id="SimplicitysPatch">
<title>Simplicity's Patch</title>
<mediaobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc1.eps"></imageobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc1.gif"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

<para>Notice that <xref linkend="SimplicitysPatch"> shows a connection
between the patchpoint and the input of Out2Sum, a connection that
isn't specified in Simplicity's <classname>MKPatchTemplate</classname>.  By convention, the
connection to the output <classname>MKUnitGenerator</classname> is
implemented in a method that's invoked when the
<classname>MKSynthPatch</classname> receives a noteOn.  This method,
called <emphasis role="bold">noteOnSelf:</emphasis>, is examined in
the next section.</para>

<tip><para>The illustration in <xref
linkend="SimplicitysPatch"> introduces schematic conventions that will
be used throughout this section:</para></tip>

<itemizedlist>
<listitem><para><classname>MKUnitGenerator</classname>s are drawn as
half-circles (oscillators) or as inverted triangles (everything
else).</para></listitem>

<listitem><para>A <classname>MKUnitGenerator</classname>'s inputs are
at the top of the icon, its outputs are on the
bottom.</para></listitem>

<listitem><para>Patchpoints are drawn as diamonds.  Other
<classname>MKSynthData</classname> objects, including the predefined
<classname>MKSynthData</classname> that represents the <acronym>DSP</acronym> sineROM,
are rectangles.</para></listitem>

<listitem><para>Data written to a <classname>MKSynthData</classname>
arrives at the left side of the icon.  Data is read from the
right.</para></listitem>
</itemizedlist>

<para>It's often convenient to represent a patch without including the
patchpoints and without superimposing the schematic on the <acronym>DSP</acronym> memory
diagram.  <xref linkend="ConventionalPatchDiagram"> shows Simplicity's
patch in an abbreviated form.  A <classname>MKSynthData</classname>'s
memory space is indicated by an x or y inside the icon.  The spaces
from which and to which a <classname>MKUnitGenerator</classname> reads
and writes data is similarly indicated just to the right of each input
and output.</para>

<figure id="ConventionalPatchDiagram">
<title>Conventional Patch Diagram</title>
<mediaobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc2.eps"></imageobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc2.gif"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

</sect4>
</sect3>
<sect3 id="PlayingThePatch">
<title>Playing the Patch</title>

<para>Keep in mind that a <classname>MKSynthPatch</classname> object
is ordinarily created and controlled by an instance of
<classname>MKSynthInstrument</classname>.  During a <productname>MusicKit</productname>
performance, the <classname>MKSynthInstrument</classname> distributes
the <classname>MKNote</classname>s it receives to the various
<classname>MKSynthPatch</classname> objects that it controls through
the methods <emphasis role="bold">noteOn:</emphasis>, <emphasis
role="bold">noteUpdate:</emphasis>, and <emphasis
role="bold">noteOff:</emphasis> (the
<classname>MKSynthInstrument</classname> treats a noteDur as a noteOn
and manufactures a noteOff to balance it; also, the
<classname>MKSynthInstrument</classname> normally suppresses mutes).
The design of a <classname>MKSynthPatch</classname> subclass must
include a methodology to control the patch in response to these
messages.  This is done by implementing the following methods:</para>

<itemizedlist>
<listitem><para>noteOnSelf:</para></listitem>

<listitem><para>noteUpdateSelf:</para></listitem>

<listitem><para>noteOffSelf:</para></listitem>

<listitem><para>noteEndSelf</para></listitem>
</itemizedlist>

<para>As their names imply, the first three of these methods are
invoked automatically when the <classname>MKSynthPatch</classname>
receives a <emphasis role="bold">noteOn:</emphasis>, <emphasis
role="bold">noteUpdate:</emphasis>, or <emphasis
role="bold">noteOff:</emphasis> message, respectively.  <emphasis
role="bold">noteEndSelf</emphasis> is automatically invoked when the
<classname>MKNote</classname> is completely finished and is provided
to accommodate the release portion of the
<classname>MKSynthPatch</classname>'s
<classname>MKEnvelope</classname>s.</para>

<tip><para>While these four methods
aren't subclass responsibilities, the default implementations provided
by the <classname>MKSynthPatch</classname> class do nothing.  Thus, if
you don't provide an implementation of, for example, <emphasis
role="bold">noteUpdateSelf:</emphasis>, your
<classname>MKSynthPatch</classname> won't respond to
noteUpdates.</para></tip>

<sect4 id="TheNoteOnSelfMethod">
<title>The noteOnSelf: Method</title>

<para>Simplicity, our example <classname>MKSynthPatch</classname>,
implements <emphasis role="bold">noteOnSelf:</emphasis> as
follows:</para>

<programlisting>
- noteOnSelf:aNote
{
    /* Step 1: Read the parameters in the Note and apply them to the patch. */ 
    [self applyParameters:aNote];
    /*
     * Step 2: Turn on the patch by connecting the Out2sumUGx object 
     * to the patchpoint and sending the run message to all the 
     * synthElements.
     */
    [[self synthElementAt: stereoOut]
                 setInput: [self synthElementAt:outPatchpoint]];
    [synthElements makeObjectsPerform:@selector(run)];
    return self;
}
</programlisting>

<para>The first of the two steps, applying the
<classname>MKNote</classname> parameters to the patch, is performed in
the <emphasis role="bold">applyParameters:</emphasis> method.  The
implementation of this method is described in a later section.</para>

<para>The second step, turning on the patch, distinguishes the
<emphasis role="bold">noteOnSelf:</emphasis> method from the others.
The first message in step 2 sets the input of <emphasis
role="bold">stereoOut</emphasis> (the Out2Sum
<classname>MKUnitGenerator</classname>) to the patchpoint <emphasis
role="bold">outPatchpoint</emphasis> (recall that this connection was
purposely left unspecified in the <classname>MKPatchTemplate</classname>).  The final message
sends <emphasis role="bold">run</emphasis> to each of the
<classname>MKSynthPatch</classname>'s synthElements.  This causes the
<classname>MKUnitGenerator</classname>s to begin operating.</para>

<tip><para>While it isn't necessary
to send <emphasis role="bold">run</emphasis> to the patch's
patchpoint, it's convenient to send it to all synthElements as shown
in the example.  <classname>MKSynthData</classname> implements
<emphasis role="bold">run</emphasis> to do nothing, so there's no harm
in sending this message to a patchpoint.</para></tip>

<para>The extremely important step of actually creating and connecting
the objects that make up Simplicity's patch is performed
automatically.  As described in the next chapter, part of a
<classname>MKSynthInstrument</classname>'s duties when it receives a
<classname>MKNote</classname> is to allocate an appropriate
<classname>MKSynthPatch</classname> object to synthesize the
<classname>MKNote</classname>.  It does this by sending <emphasis
role="bold">patchTemplateFor:</emphasis> to its
<classname>MKSynthPatch</classname> subclass with the received
<classname>MKNote</classname> as the argument.  As we have seen, this
method returns a <classname>MKPatchTemplate</classname> object.  It then allocates a
<classname>MKSynthPatch</classname> according to the specifications in
the <classname>MKPatchTemplate</classname> and forwards the <classname>MKNote</classname> to
the <classname>MKSynthPatch</classname> through the <emphasis
role="bold">noteOn:</emphasis> method.  Thus, by the time the
<classname>MKSynthPatch</classname> receives the <emphasis
role="bold">noteOnSelf:</emphasis> message (which is sent by <emphasis
role="bold">noteOn:</emphasis>) the patch has already been
created.</para>

<para>A <classname>MKSynthPatch</classname> contains a
<classname>NSArray</classname> of the objects that make up its patch
in its <emphasis role="bold">synthElements</emphasis> instance
variable.  In the example above, a use of this instance variable is
given as the receiver of the message that causes the
<classname>MKUnitGenerator</classname>s to start running:</para>

<programlisting>
[synthElements makeObjectsPerform: @selector(run)];
</programlisting>

<para>You can retrieve a particular object from the <emphasis
role="bold">synthElements</emphasis> <classname>NSArray</classname> by
invoking the <emphasis role="bold">synthElementAt:</emphasis> method,
passing the index of the synthElement as the argument.  This is
demonstrated in the example above in the line</para>

<programlisting>
[[self synthElementAt:stereoOut] setInput:[self synthElementAt:outPatchpoint]];
</programlisting>

<para><emphasis role="bold">synthElementAt:stereoOut</emphasis>
returns an instance of the object indexed by <emphasis
role="bold">stereoOut</emphasis>.  In other words, it returns an
instance of the <classname>Out2sumUGx</classname> class, as specified in Simplicity's
<emphasis role="bold">patchTemplateFor:</emphasis> method.  Similarly,
<emphasis role="bold">synthElementAt:outPatchpoint</emphasis> returns
Simplicity's patchpoint.</para>

<para>Finally, the return value of <emphasis
role="bold">noteOnSelf:</emphasis> is significant: If the method
returns <emphasis role="bold">nil</emphasis>, the argument
<classname>MKNote</classname> isn't synthesized.  Simplicity's
implementation always returns <emphasis role="bold">self</emphasis> so
all noteOns that it receives are synthesized.</para>
</sect4>
<sect4 id="TheNoteUpdateSelfMethod">
<title>The noteUpdateSelf: Method</title>

<para>Simplicity's implementation of <emphasis
role="bold">noteUpdateSelf:</emphasis> is straightforward; it simply
applies its argument's parameters to the patch:</para>

<programlisting>
- noteUpdateSelf:aNote
{
    [self applyParameters:aNote];
    return self;
}
</programlisting>

<para>The value returned by <emphasis
role="bold">noteUpdateSelf:</emphasis> is ignored.</para>
</sect4>
<sect4 id="TheNoteOffSelfAndNoteEndSelfMethods">
<title>The noteOffSelf: and noteEndSelf Methods</title>

<para>The methods <emphasis role="bold">noteOffSelf:</emphasis> and
<emphasis role="bold">noteEndSelf</emphasis> work together to wind
down and deactivate a <classname>MKSynthPatch</classname>.  As
mentioned earlier, <emphasis role="bold">noteOffSelf:</emphasis> is
automatically sent when a noteOff is forwarded to the
<classname>MKSynthPatch</classname> through the <emphasis
role="bold">noteOff:</emphasis> method.  When a noteOff arrives, the
<classname>MKSynthPatch</classname> doesn't stop; rather, the noteOff
is taken as a signal to begin the release portions of any
<classname>MKEnvelope</classname>s that are part of the patch.  The
value returned by <emphasis role="bold">noteOffSelf:</emphasis> is
taken as the amount of time, in seconds, to wait before invoking
<emphasis role="bold">noteEnd</emphasis>; this value is usually the
release time of the <classname>MKSynthPatch</classname>'s amplitude
envelope.  Since Simplicity doesn't have any
<classname>MKEnvelope</classname>s, its implementation of <emphasis
role="bold">noteOffSelf:</emphasis> always returns 0.0 (an example of
a <classname>MKSynthPatch</classname> that uses
<classname>MKEnvelope</classname>s is given later):</para>

<programlisting>
- (double)noteOffSelf:aNote
{
    [self applyParameters:aNote];
    /* No Envelopes, so no release time is needed. */
    return 0.0;
}
</programlisting>

<para>Even though a noteOff is the beginning of the end of a
<classname>MKSynthPatch</classname>'s activity, the
<classname>MKNote</classname> may contain some parameters; these
parameters are applied just as in the other methods, by invoking
<emphasis role="bold">applyParameters:</emphasis>.</para>

<para>After waiting the prescribed amount of time, the <emphasis
role="bold">noteEnd</emphasis> message is sent.  <emphasis
role="bold">noteEnd</emphasis> invokes <emphasis
role="bold">noteEndSelf</emphasis>, a method that deactivates the
<classname>MKSynthPatch</classname>:</para>

<programlisting>
- noteEndSelf
{
    /* Deactivate the SynthPatch by idling the output. */
    [[self synthElementAt:stereoOut] idle];
    return self;
}
</programlisting>

<para>The <emphasis role="bold">idle</emphasis> method is implemented
by all subclasses of <classname>MKUnitGenerator</classname>.  In its
implementation of <emphasis role="bold">idle</emphasis>, <classname>Out2sum</classname>
connects its input to a predefined patchpoint that always contains
zero data (the data in the patchpoint consists wholly of zeroes).
This effectively turns off the patch.  Notice that the
<classname>MKSynthPatch</classname> isn't freed, nor is its patch (as
specified in the <classname>MKPatchTemplate</classname>) dismantled.  An important convention
of <classname>MKSynthPatch</classname> design is to perform the
minimum amount of work necessary when deactivating the object.  This
makes both the deactivation itself and a subsequent reactivation (when
another noteOn arrives) as efficient as possible.</para>

<para>It should be noted that <emphasis role="bold">noteEnd</emphasis>
(and, thus, <emphasis role="bold">noteEndSelf</emphasis>) is also
invoked when the <classname>MKSynthPatch</classname> is created,
thereby ensuring that the patch is silent until the first
<classname>MKNote</classname> is received.  This also explains why the
final connection to <classname>Out2sum</classname> isn't specified in the
<classname>MKPatchTemplate</classname>&horbar;if it was so specified, the connection would be
made only to be immediately severed upon reception of the <emphasis
role="bold">noteEnd</emphasis> message (the patch is created before
<emphasis role="bold">noteEnd</emphasis> is sent).</para>
</sect4>
<sect4 id="ApplyingParameters">
<title>Applying Parameters</title>

<para>The final step in our <classname>MKSynthPatch</classname> design
is to supply it with parameter values.  As mentioned earlier,
Simplicity has three settable attributes: frequency, amplitude, and
bearing.  Simplicity implements the method <emphasis
role="bold">applyParameters:</emphasis> to read the appropriate
parameters from its argument <classname>MKNote</classname> and apply
their values to the patch:</para>

<programlisting>
- applyParameters:aNote
{
    /* Retrieve and store the parameters. */
    double  myFreq = [aNote freq];
    double  myAmp = [aNote parAsDouble:MK_amp];
    double  myBearing = [aNote parAsDouble:MK_bearing];
    /* Apply frequency if present. */
    if ( !MKIsNoDVal(myFreq) )
        [[self synthElementAt:osc] setFreq:myFreq];
    /* Apply amplitude if present. */
    if ( !MKIsNoDVal(myAmp) )
        [[self synthElementAt:osc] setAmp:myAmp];
    /* Apply bearing if present. */
    if ( !MKIsNoDVal(myBearing) )
        [[self synthElementAt:stereoOut] setBearing:myBearing];
}
</programlisting>

<para>First, the parameters are retrieved from the argument
<classname>MKNote</classname>.  Notice that the <emphasis
role="bold">freq</emphasis> method is used to retrieve frequency;
recall from the description of the <classname>MKNote</classname> class
that this method returns the value of <emphasis
role="bold">MK_freq</emphasis> or, in <emphasis
role="bold">MK_freq</emphasis>'s absence, a value converted from
<emphasis role="bold">MK_keyNum</emphasis>.</para>

<para>To apply a parameter value to the patch, you send a message to
the <classname>MKUnitGenerator</classname> that controls that aspect
of the patch.  The <classname>Oscg</classname> <classname>MKUnitGenerator</classname>
controls frequency and amplitude, so <emphasis
role="bold">setFreq:</emphasis> and <emphasis
role="bold">setAmp:</emphasis> are sent to the patch's <classname>OscgUGxy</classname>
object.  <classname>Out2sum</classname> controls bearing, so it receives <emphasis
role="bold">setBearing:</emphasis>.  These methods are defined in the
<classname>MKUnitGenerator</classname>s' master classes.</para>

<para>The complete source code for Simplicity is provided as an
example <classname>MKSynthPatch</classname> in the files <filename>Simplicity.m</filename> and <filename
class=headerfile>Simplicity.h</filename> in the directory <filename class=directory>./Examples/MusicKit/exampsynthpatch</filename>.</para> 
</sect4>
</sect3>
</sect2>
<sect2 id="ABetterMKSynthPatch">
<title>A Better <classname>MKSynthPatch</classname></title>

<para>Build a better <classname>MKSynthPatch</classname> and the world
will beat a path to your door.  This section improves the
<classname>MKSynthPatch</classname> design shown in the previous
sections.  Of greatest significance is the envelope control that's
added to both frequency and amplitude.  The patch specification is
accordingly more complex than in Simplicity.  In addition, a number of
conventions are introduced in the methods that play the patch, not
only to accommodate envelope control but, more important, to make the
<classname>MKSynthPatch</classname> more efficient and more adaptable
to the caprice of musical performance.</para>

<para>The <classname>MKSynthPatch</classname> designed here is called
Envy.  Like Simplicity, it produces a single sine wave with a settable
frequency, amplitude, and bearing.</para>

<sect3 id="DesigningThePatch">
<title>Designing the Patch</title>

<para>The following example shows the implementation of Envy's
<emphasis role="bold">patchTemplateFor:</emphasis> method:</para>

<programlisting>
/* Statically declare the synthElement indices. */
static int  ampAsymp,      /* amplitude envelope UG */
            freqAsymp,     /* frequency envelope UG */
            osc,           /* oscillator UG */
            stereoOut,     /* output UG */
            ampPp,         /* amplitude patchpoint */
            freqPp,        /* frequency patchpoint */
            outPp;         /* output patchpoint */
+ patchTemplateFor:aNote
{
    /* Step 1: Create (or return) the PatchTemplate. */
    static id theTemplate = nil;
    if (theTemplate)
        return theTemplate;
    theTemplate = [PatchTemplate new];

    /* Step 2:  Add the SynthElement specifications. */
    ampAsymp = [theTemplate addUnitGenerator:[AsympenvUGx class]];
    freqAsymp = [theTemplate addUnitGenerator:[AsympenvUGy class]];
    osc = [theTemplate addUnitGenerator:[OscgafiUGxxyy class]];
    stereoOut = [theTemplate addUnitGenerator:[Out2sumUGx class]];
    ampPp = [theTemplate addPatchpoint:MK_xPatch];
    freqPp = [theTemplate addPatchpoint:MK_yPatch];
    outPp = ampPp;

    /* Step 3:  Specify the connections. */
    [theTemplate to:ampAsymp sel:@selector(setOutput:) arg:ampPp];
    [theTemplate to:freqAsymp sel:@selector(setOutput:) arg:freqPp];
    [theTemplate to:osc sel:@selector(setAmpInput:) arg:ampPp];
    [theTemplate to:osc sel:@selector(setIncInput:) arg:freqPp];
    [theTemplate to:osc sel:@selector(setOutput:) arg:outPp];
    /* Return the <classname>MKPatchTemplate</classname>. */
    return theTemplate;
}
</programlisting>

<para>The three-step design outline is the same as in Simplicity: The
<classname>MKPatchTemplate</classname> is created, the synthElement specifications are added to
the <classname>MKPatchTemplate</classname>, and the connections between SynthElements are
specified.  However, two new <classname>MKUnitGenerator</classname>
families, <classname>Oscgafi</classname> and Asymp, are introduced.  These are examined in
the next sections; briefly, <classname>Oscgafi</classname> is a general oscillator that
allows another <classname>MKUnitGenerator</classname> to its amplitude
and frequency.  Asymp is an envelope handler; it's used to apply
<classname>MKEnvelope</classname> objects to the patch.  Asympenv is a
variant of Asymp that is better-suited to interactive real-time
applications. The patch is illustrated in <xref linkend="EnvysPatch">.</para>

<figure id="EnvysPatch">
<title>Envy's Patch</title>
<mediaobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc3.eps"></imageobject>
<imageobject><imagedata fileref="Images/MusicSynthAndProc3.gif"></imageobject>
<textobject><phrase>MusicKit Image</phrase></textobject>
</mediaobject>
</figure>

<para>Returning to the code example, notice that <emphasis
role="bold">ampPp</emphasis> and <emphasis
role="bold">outPp</emphasis> are given the same value:</para>

<programlisting>
ampPp = [theTemplate addPatchpoint:MK_xPatch];
. . .
outPp = ampPp;
</programlisting>

<para>When the patch is created, these two synthElement indices will
refer to the same object.  In other words, the patchpoint that's used
in the connection between <emphasis role="bold">ampAsymp</emphasis>
and <emphasis role="bold">osc</emphasis> is reused in the connection
between <emphasis role="bold">osc</emphasis> and <emphasis
role="bold">stereoOut</emphasis>.  Reusing patchpoints makes the patch
smaller and more efficient.  However, you can only reuse patchpoints
if the patch's <classname>MKUnitGenerator</classname>s are executed in
a predictable order.  Consider how Envy's
<classname>MKUnitGenerator</classname>s use the shared
patchpoint:</para>

<orderedlist>
<listitem>
<para><emphasis role="bold">ampAsymp</emphasis> writes to <emphasis role="bold">ampPp</emphasis>.</para>  
</listitem>
<listitem>
<para><emphasis role="bold">osc</emphasis> reads from <emphasis role="bold">ampPp</emphasis> and writes to <emphasis role="bold">outPp</emphasis>.</para>  
</listitem>
<listitem>
<para><emphasis role="bold">stereoOut</emphasis> reads from <emphasis role="bold">outPp</emphasis>.</para>
</listitem>
</orderedlist>

<para>For the shared patchpoint scheme to work, the
<classname>MKUnitGenerator</classname>s must be executed in the order
given&horbar;chaos would reign should <emphasis
role="bold">stereoOut</emphasis> read from <emphasis
role="bold">outPp</emphasis> before <emphasis
role="bold">osc</emphasis> writes to it.  The order in which a
<classname>MKSynthPatch</classname>'s
<classname>MKUnitGenerator</classname>s are executed is the order in
which their specifications are added to the
<classname>MKPatchTemplate</classname>.  Thus, Envy's
<classname>MKUnitGenerator</classname>s are executed in the following
order:</para>

<orderedlist>
<listitem><para>ampAsymp</para></listitem>
<listitem><para>freqAsymp</para></listitem>
<listitem><para>osc</para></listitem>
<listitem><para>stereoOut</para></listitem>
</orderedlist>

<para>Since <emphasis role="bold">ampAsymp</emphasis> is executed
before <emphasis role="bold">osc</emphasis>, and <emphasis
role="bold">osc</emphasis> before <emphasis
role="bold">stereoOut</emphasis>, the patchpoint between <emphasis
role="bold">ampAsymp</emphasis> and <emphasis
role="bold">osc</emphasis> can be reused as the patchpoint between
<emphasis role="bold">osc</emphasis> and <emphasis
role="bold">stereoOut</emphasis>.</para>

<tip><para>For some patches, the
order in which the <classname>MKUnitGenerator</classname>s are
executed doesn't matter.  You can add
<classname>MKUnitGenerator</classname>s and declare their execution to
be unordered by using the <emphasis
role="bold">addUnitGenerator:ordered:</emphasis> method, passing NO as
the second argument (the <emphasis
role="bold">addUnitGenerator:</emphasis> is actually a shorthand; it
invokes <emphasis role="bold">addUnitGenerator:ordered:</emphasis>
with YES as the second argument).  While you can't share patchpoints
in a patch that uses unordered
<classname>MKUnitGenerator</classname>s, allocating the patch is
somewhat more efficient.</para></tip>

<sect4 id="Oscgafi">
<title><classname>Oscgafi</classname></title>

<para>The <classname>Oscgafi</classname>
<classname>MKUnitGenerator</classname> is the most flexible oscillator
provided by the <productname>MusicKit</productname>.  In addition to
allowing envelope control of amplitude and frequency, it also performs
an interpolation, minimizing the noise that's sometimes introduced
when reading the lookup table.  The components of the
<classname>MKUnitGenerator</classname>'s name summarize these
features:</para>

      <table frame=all><title>Class naming convention for <classname>Oscgafi</classname></title>
	<tgroup cols=2 colsep=1 rowsep=1>
	  <colspec colnum=1 align=left>
	  <colspec colnum=2 align=left>
	  <thead>
	    <row>
<entry>Component</entry>
<entry>Meaning</entry> 
	    </row>
	  </thead>

	  <tbody>
<row>
<entry>Osc</entry>
<entry>Oscillator</entry>
</row>
<row>
<entry>g</entry>
<entry>General</entry>
</row>
<row>
<entry>a</entry>
<entry>Amplitude control</entry>
</row>
<row>
<entry>f</entry>
<entry>Frequency control</entry> 
</row>
<row>
<entry>i</entry>
<entry>Interpolation</entry>
</row>
</tbody>
</tgroup>
</table>

<para><classname>Oscgafi</classname> has four memory arguments, in this order:</para>

<orderedlist>
<listitem><para>output</para></listitem>
<listitem><para>amplitude control input</para></listitem>
<listitem><para>frequency control input</para></listitem>
<listitem><para>lookup table input</para></listitem>
</orderedlist>

<para>The permutations of a <classname>MKUnitGenerator</classname>
with four memory arguments results in 16 leaf classes.  Envy uses the
xxyy version (<classname>OscgafiUGxxyy</classname>), so the memory arguments correspond to
memory space as follows:</para>

      <table frame=all><title>Memory Space Association to Memory Arguments</title>
	<tgroup cols=2 colsep=1 rowsep=1>
	  <colspec colnum=1 align=left>
	  <colspec colnum=2 align=left>
	  <thead>
<row>
<entry>Argument</entry>
<entry>Space</entry> 
</row>
</thead>
<tbody>
<row>
<entry>output</entry>
<entry>x</entry>
</row>
<row>
<entry>amplitude control</entry>
<entry>x</entry> 
</row>
<row>
<entry>frequency control</entry>
<entry>y</entry> 
</row>
<row>
<entry>lookup table</entry>
<entry>y</entry>
</row>
</tbody>
</tgroup>
</table>

<para>A notable difference between <classname>Oscg</classname> and
<classname>Oscgafi</classname> is that in the latter, frequency and
amplitude aren't set directly through messages to the oscillator.  To
control these attributes, you affect the
<classname>MKUnitGenerator</classname>s that are connected to
<classname>Oscgafi</classname>'s inputs.  The <productname>MusicKit</productname>
provides a C function, called <function>MKUpdateAsymp()</function>
that does this for you.  This function is described later as it's used
to apply parameter values to Envy's patch.</para>

<para>In addition, <classname>Oscgafi</classname>'s frequency input is actually an increment
input&horbar;the oscillator's frequency is defined by the increment,
or step size, that it uses when reading its lookup table.  This
explains why <emphasis role="bold">osc</emphasis> is connected to the
<emphasis role="bold">freqPp</emphasis> patchpoint through the
<emphasis role="bold">setIncInput:</emphasis> method:</para>

<programlisting>
[theTemplate to:osc sel:@selector(setIncInput:) arg:freqPp];
</programlisting>

<para><classname>Oscgafi</classname>'s <emphasis
role="bold">incAtFreq:</emphasis> method is provided to translate
frequencies into increments.  This, too, will be used when applying
parameter values.</para>
</sect4>

<sect4 id="AsympAndAsympenv">
<title>Asymp and Asympenv</title>

<para>The Asymp and Asympenv <classname>MKUnitGenerator</classname>s
are envelope handlers; they translates the data in an
<classname>MKEnvelope</classname> object and load it onto the
<acronym>DSP</acronym>.  An <classname>MKEnvelope</classname> object
is associated with an Asymp or Asympenv through the
<function>MKUpdateAsymp()</function> function. The only difference
between Asymp and Asympenv is that the former allows for arbitrarily
long envelopes and the latter is better-suited to interactive
real-time applications.</para>

<para>Envy uses two Asympenvs, one to control the frequency of
<classname>Oscgafi</classname> and the other to control its amplitude.
The leaf classes are chosen to match the memory arguments in
<classname>Oscgafi</classname>: The Asympenv leaf class that controls amplitude is
AsympenvUGx; for frequency, it's AsympenvUGy.</para>
</sect4>
</sect3>
<sect3 id="PlayingThePatch2">
<title>Playing the Patch</title>

<para>A number of new conventions for playing and controlling a
<classname>MKSynthPatch</classname> are introduced in the following
sections.  In particular, the conventions regarding preemption,
rearticulation, and &ldquo;sticky&rdquo; parameters are
demonstrated.</para>

<sect4 id="DeclaringTheParameters">
<title>Declaring the Parameters</title>

<para>A convention of <classname>MKSynthPatch</classname> design (one
that wasn't followed in the implementation of Simplicity) is to create
an instance variable for each parameter the
<classname>MKSynthPatch</classname> responds to.  The variables are
used to maintain the state of the object's patch.</para>

<para>Because of the introduction of envelope control into the patch,
Envy responds to several more parameters than did Simplicity.  These
are shown as they are declared as instance variables in the
<classname>MKSynthPatch</classname>'s interface file (<filename
class=headerfile>Envy.h</filename>):</para>

<programlisting>
@interface Envy:SynthPatch
{
    /* Amplitude parameters. */
    id      ampEnv;         /* the Envelope object for amplitude */
    double  amp1,           /* amplitude at y=1 */
            amp0,           /* amplitude at y=0 */
            ampAtt,         /* ampEnv attack duration in seconds */
            ampRel;         /* ampEnv release duration in seconds*/
    /* Frequency parameters. */ 
    id      freqEnv;        /* the Envelope object for frequency */
    double  freq1,          /* frequency at y=1 */
            freq0,          /* frequency at y=0 */
            freqAtt,        /* freqEnv attack duration in seconds*/
            freqRel;        /* freqEnv release duration in seconds */
    /* Other parameters. */
    double  portamento;     /* transition time in seconds */ 
    double  bearing;        /* stereo location */
}
</programlisting>

<para>A set of defaults for the parameter instance variables should
also be included in a <classname>MKSynthPatch</classname> design.
Envy implements a method called <emphasis
role="bold">setDefaults</emphasis> to provide this:</para>

<programlisting>
- setDefaults
{
    ampEnv     = nil;
    amp0       = 0.0;
    amp1       = MK_DEFAULTAMP;         /* 0.1 */
    ampAtt     = MK_NODVAL;             /* parameter not present */
    ampRel     = MK_NODVAL;             /* parameter not present */
    freqEnv    = nil;
    freq0      = 0.0;
    freq1      = MK_DEFAULTFREQ;        /* 440.0 */
    freqAtt    = MK_NODVAL;             /* parameter not present */
    freqRel    = MK_NODVAL;             /* parameter not present */
    portamento = MK_DEFAULTPORTAMENTO;  /* 0.1 */
    bearing    = MK_DEFAULTBEARING;     /* 0.0 (center) */
    return self;
}
</programlisting>

<para>By convention, a <classname>MKSynthPatch</classname>'s parameter
instance variables should be set to their default values before the
<classname>MKSynthPatch</classname> begins a new phrase.  This is done
by invoking <emphasis role="bold">setDefaults</emphasis> from the
<emphasis role="bold">noteEndSelf</emphasis> method.  Keep in mind
that <emphasis role="bold">noteEnd</emphasis>, which invokes <emphasis
role="bold">noteEndSelf</emphasis>, is invoked when a new
<classname>MKSynthPatch</classname> is created, so <emphasis
role="bold">setDefaults:</emphasis> will be invoked before the first
<classname>MKNote</classname> arrives as well as after the end of each
phrase.</para>

<para>However, one other condition must be considered&horbar;that of
the preempted <classname>MKSynthPatch</classname>&horbar;which, by
definition, isn't sent the <emphasis role="bold">noteEnd</emphasis>
message.  The <classname>MKSynthPatch</classname> class defines a
method <emphasis role="bold">preemptFor:</emphasis> that you can
redefine in your subclass to reset the parameter instance variables to
their default values and to provide any other special behavior for a
preempted <classname>MKSynthPatch</classname>.  The method is invoked
just before the <classname>MKSynthPatch</classname> receives, in a
<emphasis role="bold">noteOn:</emphasis> message, the
<classname>MKNote</classname> for which it was preempted (the argument
to <emphasis role="bold">preemptFor:</emphasis> is this same
<classname>MKNote</classname>).  Envy implements <emphasis
role="bold">preemptFor:</emphasis> to preempt the amplitude
<classname>MKEnvelope</classname> and invoke <emphasis
role="bold">setDefaults:</emphasis>.  It ignores the argument:</para>

<programlisting>
- preemptFor:aNote
{
    [[self synthElementAt:ampAsymp] preemptEnvelope];
    [self setDefaults];
    return self;
}
</programlisting>
</sect4>
<sect4 id="TheNoteOnSelfAndNoteUpdateSelfMethods">
<title>The noteOnSelf: and noteUpdateSelf: Methods</title>

<para>These two methods follow the same form as those in Simplicity:</para>

<programlisting>
- noteOnSelf:aNote
{
    /* Apply the parameters to the patch. */
    [self applyParameters:aNote];
    /* Make the final connection to the output sample stream.*/
    [[self synthElementAt:stereoOut] setInput:outPp];
    /* Tell the UnitGenerators to begin running. */
    [synthElements makeObjectsPerform:@selector(run)];
    return self;
}

- noteUpdateSelf:aNote
{
    /* Apply the parameters to the patch. */
    [self applyParameters:aNote];
    return self;
}
</programlisting>

<para>Once again, both methods invoke <emphasis
role="bold">applyParameters:</emphasis> to apply the Note's parameters
to the patch.  In addition, <emphasis
role="bold">noteOnSelf:</emphasis> completes the connection between
<classname>Oscgafi</classname> and <classname>Out2sum</classname>, and it tells the
<classname>MKUnitGenerator</classname>s to run by sending <emphasis
role="bold">run</emphasis> to each of the synthElements.</para>
</sect4>
<sect4 id="TheNoteOffSelfAndNoteEndSelfMethods2">
<title>The noteOffSelf: and noteEndSelf Methods</title>

<para>Recall that the value returned by <emphasis
role="bold">noteOffSelf:</emphasis> is taken as the amount of time to
wait (in seconds) before <emphasis role="bold">noteEnd</emphasis> is
invoked.  Typically, this value is the release time of the
<classname>MKSynthPatch</classname>'s amplitude
<classname>MKEnvelope</classname>:</para>

<programlisting>
- (double)noteOffSelf:aNote
{
    /* Apply the parameters. */
    [self applyParameters: aNote];
    /* Signal the release portion of the frequency Envelope. */
    [[self synthElementAt:freqAsymp] finish];
    /* Same for amplitude, but also return the release duration. */
    return [[self synthElementAt:ampAsymp] finish];
}
</programlisting>

<para>An Asympenv responds to the <emphasis
role="bold">finish</emphasis> message by signaling the release portion
of its <classname>MKEnvelope</classname>; the method returns the
duration of the release.</para>

<para>As in Simplicity, <emphasis role="bold">noteEndSelf</emphasis>
sends <emphasis role="bold">idle</emphasis> to the <classname>Out2sum</classname> object to
remove it from the output sample stream.  It also aborts the frequency
<classname>MKEnvelope</classname> (we're assured that the amplitude
<classname>MKEnvelope</classname> has finished since its demise is
what causes this method to be invoked) and then invokes the <emphasis
role="bold">setDefaults</emphasis> method, as dictated in <xref
linkend="DeclaringTheParameters">, above.</para>

<programlisting>
- noteEndSelf
{
     /* Remove the patch's Out2sum from the output sample stream. */
    [[self synthElementAt:stereoOut] idle];
    /* Abort the frequency Envelope. */
    [[self synthElementAt:freqAsymp] abortEnvelope];
    /* Set the instance variables to their default values. */
    [self setDefaults];
    return self;
}
</programlisting>

</sect4>
<sect4 id="PhraseStatus">
<title>Phrase Status</title>

<para>The manner in which a <classname>MKNote</classname>'s parameters
are applied to a patch can depend on the performance context in which
the <classname>MKSynthPatch</classname> receives the
<classname>MKNote</classname>.  This context, called <emphasis>phrase
status</emphasis>, is represented as an MKPhraseStatus constant and is
automatically set when the <classname>MKSynthPatch</classname>
receives a phrase event message (such as <emphasis
role="bold">noteOn:</emphasis> and <emphasis
role="bold">noteUpdate:</emphasis>).  There are seven phrase
states:</para>

<itemizedlist>
<listitem><para><constant>MK_phraseOn</constant> means
that the received <classname>MKNote</classname> is a noteOn and the
<classname>MKSynthPatch</classname> has been freshly allocated to
synthesize the <classname>MKNote</classname>.  This status indicates
the beginning of a new phrase.</para>
</listitem>

<listitem><para><constant>MK_phraseRearticulate</constant>
indicates a noteOn that rearticulates an existing phrase.</para>
</listitem>

<listitem><para><constant>MK_phraseOnPreempt</constant> is also used
for noteOns, but it indicates that the
<classname>MKSynthPatch</classname> has been preempted to synthesize
the <classname>MKNote</classname>.  Like
<constant>MK_phraseOn</constant>, this status means that a new phrase
is beginning.</para>
</listitem>

<listitem><para><constant>MK_phraseUpdate</constant> means
that the <classname>MKNote</classname> is a noteUpdate and the
<classname>MKSynthPatch</classname> is in the attack or stickpoint
portions of its <classname>MKEnvelope</classname>s (the
<classname>MKSynthPatch</classname>'s synthStatus is
<constant>MK_running</constant>).</para>
</listitem>

<listitem><para><constant>MK_phraseOff</constant>
indicates a noteOff.</para>
</listitem>

<listitem><para><constant>MK_phraseOffUpdate</constant> is
for a noteUpdate that arrives during the release portion of the
<classname>MKEnvelope</classname>s (synthStatus is
<constant>MK_finishing</constant>).</para>
</listitem>

<listitem><para><constant>MK_phraseEnd</constant> is used
to indicate the end of a phrase.</para>
</listitem>
</itemizedlist>

<para>A <classname>MKSynthPatch</classname>'s phrase status, which is
retrieved by sending <emphasis role="bold">phraseStatus</emphasis> to
the <classname>MKSynthPatch</classname>, is provided solely as a
convenience to <classname>MKSynthPatch</classname> designers and is
only valid within the implementations of the <emphasis
role="bold">noteOnSelf:</emphasis>, <emphasis
role="bold">noteUpdateSelf:</emphasis>, <emphasis
role="bold">noteOffSelf:</emphasis>, and <emphasis
role="bold">noteEndSelf</emphasis> methods.  Sent to a
<classname>MKSynthPatch</classname> from outside these methods,
<emphasis role="bold">phraseStatus</emphasis> returns <emphasis
role="bold">MK_noPhraseActivity</emphasis>.</para>

<para>You can use phrase status in the design of your
<classname>MKSynthPatch</classname> in a test that leads to
specialized behavior.  For example, you may want to apply certain
noteUpdate parameters differently, depending on whether the phrase
status is <constant>MK_phraseUpdate</constant> or
<constant>MK_phraseOffUpdate</constant>.  Two conventional uses of
phrase status&horbar;as an argument to the
<function>MKUpdateAsymp()</function> function and to determine if a
<classname>MKNote</classname> is the beginning of a new
phrase&horbar;are demonstrated in the next section.</para>
</sect4>
<sect4 id="EnvyApplyingParameters">
<title>Applying Parameters</title>

<para>The way that Envy applies a <classname>MKNote</classname>'s
parameters is more sophisticated than the manner employed by
Simplicity.  A convention ignored in the design of Simplicity holds
that a noteOn that rearticulates a phrase should inherit, if
necessary, the values of the parameters in the phrase so far.  For
example, if a rearticulating noteOn doesn't contain an amplitude
<classname>MKEnvelope</classname>, it uses the one set in the previous
noteOn.  The implementation of Envy accommodates this by storing its
parameter values as instance variables: It can supply a
&ldquo;missing&rdquo; parameter by using the value stored in the
appropriate variable.</para>

<para>Determining the correct value for amplitude and frequency is
more complicated in the implementation of Envy than in that of
Simplicity.  Because of its use of <classname>MKEnvelope</classname>
objects, Envy's amplitude and frequency depend on the values of a
number of related parameters.  The <productname>MusicKit</productname>
provides a C function called <function>MKUpdateAsymp()</function> that
helps to untangle this web.  The function takes, as arguments, all the
objects and parameter values associated with a particular
<classname>MKEnvelope</classname> and applies them in a predictable
manner to the attribute that the <classname>MKEnvelope</classname>
controls.</para>

<para><function>MKUpdateAsymp()</function> takes eight
arguments:</para>

<orderedlist>
<listitem><para>An Asymp or Asympenv object</para></listitem>

<listitem><para>An <classname>MKEnvelope</classname> object</para></listitem>

<listitem><para>The <classname>MKEnvelope</classname>'s value when y =
0.0</para></listitem>

<listitem><para>The <classname>MKEnvelope</classname>'s value when y =
1.0</para></listitem>

<listitem><para>The <classname>MKEnvelope</classname>'s attack
time</para></listitem>

<listitem><para>The <classname>MKEnvelope</classname>'s release
time</para></listitem>

<listitem><para>The portamento value (not currently supported for
Asympenv)</para></listitem>

<listitem><para>The current phrase status</para></listitem>
</orderedlist>

<para>The function's behavior is described in 
<ulink url="&MKFunctionReferences;">
<productname>MusicKit</productname> Function References</ulink>.
Briefly, it applies an <classname>MKEnvelope</classname> (argument 2)
to an Asymp or Asympenv (argument 1) after properly scaling the
<classname>MKEnvelope</classname>'s value range (arguments 3 and 4)
and setting its attack and release times (arguments 5 and 6).
Portamento (argument 7) is used only if the phrase status (argument 8)
is <constant>MK_phraseRearticulate</constant>.</para>

<para>Envy's implementation of the <emphasis
role="bold">applyParameters:</emphasis> method demonstrates the
conventional way to apply parameters to a patch that includes
<classname>MKEnvelope</classname>s:</para>

<programlisting>
- applyParameters:aNote
{
    /* Retrieve and store the parameters. */
    id     myAmpEnv     = [aNote parAsEnvelope:MK_ampEnv];
    double myAmp0       = [aNote parAsDouble:MK_amp0];
    double myAmp1       = [aNote parAsDouble:MK_amp1];
    double myAmpAtt     = [aNote parAsDouble:MK_ampAtt];
    double myAmpRel     = [aNote parAsDouble:MK_ampAtt];
    id     myFreqEnv    = [aNote parAsEnvelope:MK_freqEnv];
    double myFreq0      = [aNote parAsDouble:MK_freq0];
    double myFreq1      = [aNote freq];
    double myFreqAtt    = [aNote parAsDouble:MK_freqAtt];
    double myFreqRel    = [aNote parAsDouble:MK_freqRel];
    double myPortamento = [aNote parAsDouble:MK_portamento];
    double myBearing    = [aNote parAsDouble:MK_bearing];
    /* Store the phrase status. */
    MKPhraseStatus phraseStatus = [self phraseStatus];
    /* Is aNote a noteOn? */
    BOOL isNoteOn = [aNote noteType] == MK_noteOn;
    /* Is aNote the beginning of a new phrase? */
    BOOL isNewPhrase = (phraseStatus == MK_phraseOn) ||
                        (phraseStatus == MK_phraseOnPreempt);
    /* Used in the parameter checks. */
    BOOL shouldApplyAmp = NO;
    BOOL shouldApplyFreq = NO;
    BOOL shouldApplyBearing = NO;
    /* The same portamento is used in both frequency and amplitude. */
    if ( !MKIsNoDVal(myPortamento) ) {
        portamento = myPortamento;
        shouldApplyAmp = YES;
        shouldApplyFreq = YES; }
    /* Check the amplitude parameters and set the instance 
       variables. */
    if (myAmpEnv != nil) {
        ampEnv = myAmpEnv;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmp0)) {
        amp0 = myAmp0;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmp1)) {
        amp1 = myAmp1;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmpAtt)) {
        ampAtt = myAmpAtt;
        shouldApplyAmp = YES; }
    if (!MKIsNoDVal(myAmpRel)) {
        ampRel = myAmpRel;
        shouldApplyAmp = YES; }
    /* Apply the amplitude parameters. */
    if (shouldApplyAmp || isNoteOn)
        MKUpdateAsymp([self synthElementAt:ampAsymp], 
                        ampEnv, amp0, amp1, ampAtt, ampRel,
                        portamento, phraseStatus);
    /* Check the frequency parameters and set the instance 
       variables. */
    if (myFreqEnv != nil) {
        freqEnv = myFreqEnv;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreq0)) {
        freq0 = myFreq0;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreq1)) {
        freq1 = myFreq1;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreqAtt)) {
        freqAtt = myFreqAtt;
        shouldApplyFreq = YES; }
    if (!MKIsNoDVal(myFreqRel)) {
        freqRel = myFreqRel;
        shouldApplyFreq = YES; }
    /* Apply the frequency parameters. */
    if (shouldApplyFreq || isNoteOn)
        MKUpdateAsymp([self synthElementAt:freqAsymp], freqEnv,
                        [[self synthElementAt:osc] incAtFreq:freq0],
                        [[self synthElementAt:osc] incAtFreq:freq1],
                        freqAtt, freqRel, portamento, phraseStatus);
    /* Check and set the bearing. */
    if (!MKIsNoDVal(myBearing)) {
        bearing = myBearing;
        shouldApplyBearing = YES; }
    if (shouldApplyBearing || isNewPhrase)
        [[self synthElementAT:stereoOut] setBearing:bearing];
    return self;
}
</programlisting>

<para>As in Simplicity's implementation of <emphasis
role="bold">applyParameters:</emphasis>, the value of each parameter
is stored and then checked to determine whether the parameter is
actually present in the argument <classname>MKNote</classname>.  In
addition, this implementation updates the values of the instance
variables to those of the parameters that are present.</para>

<para>Each parameter that affects amplitude is checked in its own
conditional statement.  If the parameter is present, the <emphasis
role="bold">shouldApplyAmp</emphasis> variable is set to YES,
indicating that the amplitude <classname>MKEnvelope</classname> needs
to be updated.  Finally, the value of <emphasis
role="bold">shouldApplyAmp</emphasis> is logically or'd with the value
of <emphasis role="bold">isNoteOn</emphasis>, which is YES if
<emphasis role="bold">aNote</emphasis> is a noteOn.  Thus, the
<function>MKUpdateAsymp()</function> call for amplitude is
made if any of the tested parameters are present, and it's always made
if <emphasis role="bold">aNote</emphasis> is a noteOn.</para>

<para>The conditionals for applying the frequency parameters are the
same as those for amplitude.  Notice, however, that the <emphasis
role="bold">freq0</emphasis> and <emphasis
role="bold">freq1</emphasis> values aren't passed directly to
<function>MKUpdateAsymp()</function>.  Instead, they're
used to retrieve increment values from <emphasis
role="bold">osc</emphasis> through its <emphasis
role="bold">incAtFreq:</emphasis> method.  As mentioned earlier,
<classname>Oscgafi</classname>'s frequency value isn't set as a frequency in hertz, but
rather as an increment into its lookup table.</para>

<para>Finally, the bearing parameter is tested, its instance variable
is set, and the parameter is applied to the patch.  Notice that
bearing is automatically applied if <emphasis
role="bold">aNote</emphasis> is the beginning of a new phrase.  Unlike
amplitude and frequency, bearing isn't controlled by an
<classname>MKEnvelope</classname>, so it doesn't need to be
automatically applied if the <classname>MKNote</classname> is simply a
rearticulation of an existing phrase.</para>

</sect4>
</sect3>
</sect2>
<sect2 id="AddingAMKWaveTable">
<title>Adding a <classname>MKWaveTable</classname></title>

<para>Envy, although otherwise entertaining, is of limited timbral
interest&horbar;it can only produce a sine wave.  Replacing Envy's
sine wave with a <classname>MKWaveTable</classname> is quite simple;
its patch isn't affected, nor are the implementations of the <emphasis
role="bold">noteOnSelf:</emphasis> type methods.  The only real change
is in the implementation of <emphasis
role="bold">applyParameters:</emphasis>.</para>

<para>First, however, you must provide an instance variable and
default value for <emphasis
role="bold">MK_waveform</emphasis>&horbar;the parameter that
identifies <classname>MKSynthPatch</classname>'s
<classname>MKWaveTable</classname> object:</para>

<programlisting>
@interface Envy:SynthPatch
{
    id waveform;
    . . .
}

- setDefaults
{
    waveform = nil;
    . . .
}
</programlisting>

<para>The <emphasis role="bold">applyParameters:</emphasis> method is
rewritten to attend to the new parameter:</para>

<programlisting>
- applyParameters:aNote
{
    . . .
    /* Create local variables for the new parameter. */
    id  myWaveform = [aNote parAsWaveTable:MK_waveform];
    BOOL shouldApplyWave = NO;
    /* Test the parameters. */
    if (myWaveform != nil) {
        waveform = myWaveform;
        shouldApplyWave = YES; 
    }
    if (shouldApplyWave || isNewPhrase)
        [[self synthElementAt:osc] setTable: waveform
                                     length: 0
                           defaultToSineROM: isNewPhrase];
    . . .
}
</programlisting>

<para>The <emphasis
role="bold">setTable:length:defaultToSineROM:</emphasis> method sets
the oscillator's lookup table to the specified
<classname>MKWaveTable</classname> object.  Passing 0 as the length of
the table causes the <productname>MusicKit</productname> to compute a default value.  The
argument to <emphasis role="bold">defaultToSineROM:</emphasis> is a
BOOL value that determines whether the sineROM should be used if
memory for the <classname>MKWaveTable</classname> can't be allocated.
In this implementation, the argument is YES only if <emphasis
role="bold">aNote</emphasis> is the beginning of a new phrase.  For
all other phrase states, the previously set
<classname>MKWaveTable</classname> is used if a new one can't be
allocated.</para>

<para>WaveTables are shared among
<classname>MKSynthPatch</classname>es&horbar;if two
<classname>MKSynthPatch</classname>es declare the same
<classname>MKWaveTable</classname> object (with the same length), the
<classname>MKWaveTable</classname> is allocated once and the
<classname>MKSynthPatch</classname>es read from the same memory.  This
feature is provided automatically by all the <classname>Oscg</classname>-type
oscillators.</para>
</sect2>
</sect1>
<sect1 id="DoingReal-timeSoundProcessing">
<title>Doing Real-time Sound Processing</title>

<para>One of the most exciting aspects of the <productname>MusicKit</productname> is the ability
to process sound in real time, under arbitrarily rich control.  To do
this, you follow all the guidelines given above.  There are only three
differences:</para> 

  <orderedlist>

<listitem><para>You must connect hardware that accepts sound input to
the <acronym>DSP</acronym> serial port.</para>
</listitem>

<listitem><para>You must set up the <classname>MKOrchesra</classname> to do sound processing.</para>
    </listitem>

<listitem><para>You must have an In1aUG or In1bUG in your <classname>MKSynthPatch</classname>.</para>
     </listitem>
   </orderedlist>

<para>The standard NeXT configuration (at the time of this writing)
does not include a high-quality sound input.  Therefore, in order to
do real-time high-quality sound processing, you need to obtain a
device that plugs into the <acronym>DSP</acronym> serial port.  See <xref
linkend="UsingTheDSPSerialPort"> above for how to set up the hardware
and how to configure the <classname>MKOrchestra</classname>.</para>

<sect2 id="MakingAMKSynthPatchToDoSoundProcessing">
<title>Making a <classname>MKSynthPatch</classname> to do Sound
Processing</title>

<para>Making a <classname>MKSynthPatch</classname> that does sound
processing is simple.  You just include an instance of In1aUG to get
the left sound input channel or In1bUG to get the right sound input
channel.  These <classname>MKUnitGenerator</classname>s write their
input to an output patchpoint.  They also optionally provide a scale
factor.  Thus, you can convert the <classname>MKWaveTable</classname>
synthesis <classname>MKSynthPatch</classname> described above to a
sound processing synthpatch by merely replacing the oscillator with an
In1aUG.</para>
</sect2>
</sect1>

<sect1 id="CreatingAMKUnitGeneratorSubclass">
<title>Creating a <classname>MKUnitGenerator</classname> Subclass</title>

<para>Each <classname>MKUnitGenerator</classname> subclass is an
object-oriented interface to a <acronym>DSP</acronym> macro, called a
<emphasis>unit generator</emphasis>, that's written in
<hardware>MC56001</hardware> assembly language.  The Objective-C code
in the subclass is generated automatically from a
<acronym>DSP</acronym> macro by the <command>dspwrap</command>
program.  To build your own <classname>MKUnitGenerator</classname>
subclass that you can use in <classname>MKSynthPatch</classname>
design, you run <command>dspwrap</command> on a
<hardware>MC56001</hardware> assembly language macro that you've
created.  In addition, you can modify and wrap the
<acronym>DSP</acronym> macros that NeXT provides as source code in the
directory <filename
class=directory>/usr/local/lib/dsp/ugsrc</filename>.</para>

<para>The design of <acronym>DSP</acronym> assembly language macros is outside the scope
of the present discussion.  The following sections show how to use
<command>dspwrap</command> and how to further modify the
<classname>MKUnitGenerator</classname>s that it creates.</para>

<sect2 id="Usingdspwrap">
<title>Using <command>dspwrap</command></title>

<para>The <command>dspwrap</command> program is used to
create array processing C functions as well as
<classname>MKUnitGenerator</classname> subclasses.  To indicate that
you want to create the latter, you call the program with the <emphasis
role="bold">-ug</emphasis> switch followed by the name of the file
that contains the assembly code macro (you must include the
&ldquo;.asm&rdquo; extension when specifying the file).  For example,
the invocation</para>

<programlisting>
dspwrap -ug unoisehp.asm
</programlisting>

<para>creates a master <classname>MKUnitGenerator</classname> class
called UnoisehpUG as well as the appropriate leaf classes.  These are
embodied in the following files, which are automatically generated by
<command>dspwrap</command>:</para>

<itemizedlist>
<listitem><para><filename>UnoisehpUG.m</filename> is the
implementation file of the master class.</para>
</listitem>

<listitem><para><filename class=headerfile>UnoisehpUG.h</filename> is the master class interface file.</para>
</listitem>

<listitem><para><filename>UnoisehpUGx.m</filename> and
<filename>UnoisehpUGy.m</filename> are leaf class implementations.</para>
</listitem>

<listitem><para><filename class=headerfile>UnoisehpUGx.h</filename>
and <filename class=headerfile>UnoisehpUGy.h</filename> are the leaf
interface files.</para>
</listitem>

<listitem><para><filename>unoisehpUGInclude.m</filename> is imported
by the master class.</para>
</listitem>
</itemizedlist>

<para>The number of leaf classes that are created depends on the
number of address-valued memory arguments, described below, in the
macro: A different leaf class is created for each combination of x and
y <acronym>DSP</acronym> memory spaces.  The <emphasis role="bold">unoisehp</emphasis>
macro, which implements a high-pass random number generator, has only
one such argument&horbar;its output&horbar;so two leaf classes are
generated, one for either memory space.</para>

<para>Some other files, such as documentation and <acronym>DSP</acronym> assembler and
linker files, are also created.  These can be moved, deleted, or
disregarded as you see fit.  For the present purposes, only the files
listed above are important.</para>
</sect2>
<sect2 id="ModifyingTheClass">
<title>Modifying the Class</title>

<para>There are two basic reasons to modify a
<classname>MKUnitGenerator</classname> class that's generated by
<command>dspwrap</command>:</para>

<itemizedlist>
<listitem><para>To set the values of the <acronym>DSP</acronym> memory arguments that are passed to the macro</para>
</listitem>
<listitem><para>To define the class's response to some common messages</para>
</listitem>
</itemizedlist>

<para>Of the files generated by <command>dspwrap</command>, you should
modify only those that define the master class.  In other words,
continuing with the Unoisehp example, only
<filename>UnoisehpUG.m</filename> and <filename
class=headerfile>UnoisehpUG.h</filename> should be edited.  The entire
implementation file of the UnoisehpUG master class as generated by
<command>dspwrap</command> is shown below:</para>

<programlisting>
#import &lt;MusicKit/MusicKit.h&gt;
#import "UnoisehpUG.h"
@implementation UnoisehpUG:MKUnitGenerator

/* DSP memory arguments. */
enum args { aout, seed};
#import "unoisehpUGInclude.m"
</programlisting>

<sect3 id="SettingTheArguments">
<title>Setting the Arguments</title>

<para>The two <emphasis role="bold">enum</emphasis> variables shown
above, <emphasis role="bold">aout</emphasis> and <emphasis
role="bold">seed</emphasis>, are <acronym>DSP</acronym> memory arguments.  A memory
argument represents a location on the <acronym>DSP</acronym> from which the unit
generator that's executing can read information sent to it by the
<productname>MusicKit</productname>.  There are two types of memory arguments:</para>

<itemizedlist>
<listitem><para>Address-valued arguments administer the location in
<acronym>DSP</acronym> memory from which, or to which, the executing unit generator reads
or writes data.</para>
</listitem>

<listitem><para>Datum-valued arguments take a value that's used as
part of the unit generator's computation.</para>
</listitem>
</itemizedlist>

<para>In the example, <emphasis role="bold">aout</emphasis> variable
is an address-valued argument that represents the
<classname>MKUnitGenerator</classname>'s output patchpoint.  We create
a Unoisehp method named <emphasis role="bold">setOutput:</emphasis>
that sets this argument:</para>

<programlisting>
-setOutput:outputPatchPoint
{
    return [self setAddressArg:aout to:outputPatchPoint];
}
</programlisting>

<para>The <emphasis role="bold">setAddressArg:to:</emphasis> method is
defined by <classname>MKUnitGenerator</classname> to set an
address-valued <acronym>DSP</acronym> memory argument.</para>

<para>The other <emphasis role="bold">enum</emphasis> variable,
<emphasis role="bold">seed</emphasis>, is a datum-valued memory
argument.  It's set through <classname>MKUnitGenerator</classname>'s
<emphasis role="bold">setDatumArg:to:</emphasis> method, as
demonstrated in our implementation of Unoisehp's <emphasis
role="bold">setSeed:</emphasis>method:</para>

<programlisting>
-setSeed:(int)aSeed
{
    return [self setDatumArg:seed to:aSeed];
}
</programlisting>
</sect3>
<sect3 id="DefiningTheClassResponse">
<title>Defining the Class's Response</title>

<para>During a performance, a <classname>MKUnitGenerator</classname>
can expect to receive the following messages:</para>

<itemizedlist>
<listitem><para><emphasis role="bold">run</emphasis> tells the receiver to begin doing whatever it does.</para>
</listitem>

<listitem><para><emphasis role="bold">finish</emphasis> winds down the receiver before coming to a halt.</para>
</listitem>

<listitem><para><emphasis role="bold">idle</emphasis> provides instructions for halting the receiver's activity.</para>
</listitem>
</itemizedlist>

<para>Invocations of these methods were shown in the implementations
of the Simplicity and Envy <classname>MKSynthPatch</classname>es.
Remember that <emphasis role="bold">finish</emphasis> returns the
amount of time the <classname>MKUnitGenerator</classname> needs to
complete its mission&horbar;the amount of time to wait before
<emphasis role="bold">idle</emphasis> should be sent.  The default
implementations of these methods can be sufficient.  For further
tuning, you should implement, in your master class, the methods
<emphasis role="bold">runSelf</emphasis>, <emphasis
role="bold">finishSelf</emphasis>, and <emphasis
role="bold">idleSelf</emphasis>&horbar;methods that are automatically
invoked when the corresponding performance messages are
received.</para>

<para>You almost always provide an implementation of <emphasis
role="bold">idleSelf</emphasis> to ensure that your
<classname>MKUnitGenerator</classname> is brought to a halt in a
manner befitting its activity.  The Unoisehp implementation of this
method sets its output to the <acronym>DSP</acronym>'s <emphasis>sink</emphasis>, a
location that, by convention, is never read:</para>

<programlisting>
-idleSelf
{
    /* Set the output (aout) to sink. */
    [self setAddressArgToSink:aout];
    return self;
}
</programlisting>
</sect3>
</sect2>
</sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document: "MusicKitConcepts.sgml"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
