<!-- $Id$ -->
<chapter id="MusicPerformance">
  <title>Music Performance</title>

<para>This chapter describes the classes and functions that you use to
create a musical performance with the
<productname>MusicKit</productname>.  The material presented here
falls roughly into three sections: realizing music data,
<productname>MusicKit</productname> scheduling, and guidelines for
building an efficient application.  To fully appreciate this chapter,
you should be familiar with the material in the preceding two
chapters, <xref linkend="MusicData"> and <xref
linkend="MusicSynthAndProc">.</para>

    <sect1 id="PerformanceDesignPhilosophy">
      <title>Design Philosophy</title>

      <para>The primary task in a musical performance is to take a
representation of music and render it in an appropriate fashion.
Traditionally, this task is met by a performer wielding an instrument.
Similarly, the <productname>MusicKit</productname> has its
<classname>MKPerformer</classname> and
<classname>MKInstrument</classname> objects: A
<classname>MKPerformer</classname> obtains a
<classname>MKNote</classname> object, either by reading it from a
database such as a <classname>MKPart</classname> or scorefile or by
improvising the <classname>MKNote</classname> itself.  The
<classname>MKPerformer</classname> then relays the
<classname>MKNote</classname> to an
<classname>MKInstrument</classname> that provides the machinery for
rendering, or <emphasis>realizing</emphasis>, the
<classname>MKNote</classname>.</para>

      <para>Of <classname>MKInstrument</classname> and
<classname>MKPerformer</classname>, the former is the more crucial to
a <productname>MusicKit</productname> performance.  Realization is the
whole point of a performance, thus
<classname>MKInstrument</classname>s are ubiquitous.
<classname>MKPerformer</classname>s provide a convenient means for
acquiring or generating <classname>MKNote</classname>s but they're not
essential to a performance application; in fact, some applications
can't use <classname>MKPerformer</classname>s but, instead, must
manufacture <classname>MKNote</classname>s themselves and send them
directly to <classname>MKInstrument</classname>s.  In any case, the
means by which a <classname>MKNote</classname> is acquired is
separated from its means of realization and the mechanism for
connecting an agent of acquisition to that of realization is extremely
general.  Specifically, any <classname>MKPerformer</classname> (or
your application) can be connected to any&horbar;and any number
of&horbar;<classname>MKInstrument</classname>s.  These connections can
be created and severed dynamically, allowing you to create a
kaleidoscopic network of <classname>MKNote</classname> sources and
destinations.</para>

      <para>With <classname>MKPerformer</classname> and
<classname>MKInstrument</classname>, the
<classname>MKConductor</classname> class completes the triumvirate of
preeminent performance classes.  A <classname>MKConductor</classname>
object acts as a time keeper as it determines the tempo of the
performance and starts and stops groups of
<classname>MKPerformer</classname>s.  Essentially, a
<classname>MKConductor</classname> is a timed-message sending object
that dispatches Objective-C messages at distinct times (in this
regard, it's similar to the timed entry mechanism of
<classname>NSTimer</classname>, but with a more sophisticated
interface).  For example, it's through a
<classname>MKConductor</classname> that a
<classname>MKPerformer</classname> schedules the messages that relay
<classname>MKNote</classname>s to an
<classname>MKInstrument</classname>.</para>

      <para>Because of the demands of music performance, the
<productname>MusicKit</productname> provides hooks into the operating
system that allow you to create applications that can run with
heightened priority.  Well-debugged and fine-tuned applications will
find great benefit in these enhancements.
      </para>

      <para><xref linkend="figurePerformance"> is a subset of the <productname>MusicKit</productname>'s
performance classes, showing their hierarchical relationship:
      </para>

      <figure id="figurePerformance">
	<title>Performance Classes</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="Images/MusicPerformance.eps" scalefit=1>
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="Images/MusicPerformance.gif">
	  </imageobject>
	  <textobject><phrase><productname>MusicKit</productname> Image</phrase></textobject>
	</mediaobject>
      </figure>

    </sect1>
    <sect1 id="PerformanceOutline">
      <title>Performance Outline</title>
      <para>A <productname>MusicKit</productname> performance
	can be divided into three phases:
      </para>

      <itemizedlist>
	<listitem>
	  <para>Preparation: You must determine the sources and
destinations of the <classname>MKNote</classname>s that you wish to
perform and establish other characteristics of the performance.
	  </para>
	</listitem>

	<listitem>
	  <para>Commencement: This is always accomplished by
	    sending <emphasis role="bold">startPerformance</emphasis> to the
<classname>MKConductor</classname> class.
	  </para>
	</listitem>

      <listitem>
	  <para>Termination: This is achieved by sending <emphasis
role="bold">finishPerformance</emphasis> to the
<classname>MKConductor</classname> class.
	  </para>
	</listitem>
      </itemizedlist>

      <para>This sequence of activities can be repeated any number of
times while an application is running.  While a single application can
have but a single performance in progress at any particular time, that
single performance can do any number of things.  For example, if you
want to capture <acronym>MIDI</acronym> input as a scorefile while
playing along to a <classname>MKPart</classname> that's synthesized on
the <acronym>DSP</acronym>, you perform both tasks in a single
performance&horbar;you don't have to set up separate environments.
Obviously, the two endeavors involve different classes of objects, but
when the <classname>MKConductor</classname> class receives the
<emphasis role="bold">startPerformance</emphasis> message, everybody
starts wheezing.</para>

      <para>Much of the work that goes into a performance is involved in
setting it up; in fact, many of the methods that are defined by the
classes that are involved in a performance can only be invoked before
the performance starts (or between performances).  As you design your
own application, you should consult the class descriptions in 
<ulink url="&MKClassReferences;">
<productname>MusicKit</productname> Class References</ulink>
to check for the conditions under
which a method may be invoked.</para>

<para>The following sections examine the three primary classes
involved in a performance: <classname>MKInstrument</classname>,
<classname>MKPerformer</classname>, and
<classname>MKConductor</classname>.</para>
  </sect1>
  <sect1 id="MKInstrumentClass">
    <title>The <classname>MKInstrument</classname> Class</title>

    <para><classname>MKInstrument</classname>s are the agents through
which <classname>MKNote</classname> objects are realized.  Since
realization is the ultimate destiny of a <classname>MKNote</classname>
object, the <classname>MKInstrument</classname> class is the ultimate
focus of a <productname>MusicKit</productname> performance: Every performance involves at least
one <classname>MKInstrument</classname>.</para>

    <para>At the heart of an <classname>MKInstrument</classname> is
its <emphasis role="bold">realizeNote:fromNoteReceiver:</emphasis>
method.  The <classname>MKInstrument</classname> class itself is
abstract and doesn't implement this method; it's the responsibility of
each <classname>MKInstrument</classname> subclass to provide an
implementation of <emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis> to establish the
manner in which instances of the subclass realize
<classname>MKNote</classname>s.  The
<productname>MusicKit</productname> includes a number of
<classname>MKInstrument</classname> subclasses (and
pseudo-<classname>MKInstrument</classname>s) that realize
<classname>MKNote</classname>s by synthesizing them on the
<acronym>DSP</acronym> or an external <acronym>MIDI</acronym>
synthesizer, and that store <classname>MKNote</classname>s by adding
them to a <classname>MKPart</classname> or
<classname>MKScore</classname> or by writing them to a file.</para>

<para>One of the principals of <classname>MKInstrument</classname>
design is that an <classname>MKInstrument</classname> doesn't create
the <classname>MKNote</classname>s that it realizes.  Instead, it
realizes <classname>MKNote</classname>s that are sent to it by another
object or by your application.  The machinery by which an
<classname>MKInstrument</classname> receives
<classname>MKNote</classname>s is well defined by the <productname>MusicKit</productname>; unlike
that for <classname>MKNote</classname>-realization, you don't reinvent
the <classname>MKNote</classname>-reception mechanism for each
<classname>MKInstrument</classname> subclass.</para>

<para>The following sections examine the
<classname>MKInstrument</classname> class according to its two tasks:
receiving and realizing <classname>MKNote</classname>s.  The latter
topic centers upon descriptions of the
<classname>MKInstrument</classname> subclasses included in the
<productname>MusicKit</productname>, followed by an example of
<classname>MKInstrument</classname> subclass design.</para>

    <sect2 id="ReceivingMKNotes">
      <title>Receiving <classname>MKNote</classname>s</title>

      <para>An <classname>MKInstrument</classname> receives
<classname>MKNote</classname>s through the same method that defines
their realization, <emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis>.
However, you don't send <classname>MKNote</classname>s to an
<classname>MKInstrument</classname> by invoking this method directly;
instead, you send the <classname>MKNote</classname>s to one of the
<classname>MKInstrument</classname>'s
<classname>MKNoteReceiver</classname> objects which, in turn, invokes
<emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis>
for you.</para>

      <para><classname>MKNoteReceiver</classname> is an auxiliary
class that acts as a &ldquo;<classname>MKNote</classname> port&rdquo;
for an <classname>MKInstrument</classname>.  This is manifested as the
three features that a <classname>MKNoteReceiver</classname> brings to
an <classname>MKInstrument</classname>:</para>

      <itemizedlist>
	<listitem><para> It provides methods through which an
<classname>MKInstrument</classname> receives
<classname>MKNote</classname>s (in other words, methods that invoke
<classname>MKInstrument</classname>'s <emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis>).</para>
	</listitem>

	<listitem><para> It lets you control the stream of
<classname>MKNote</classname>s into an
<classname>MKInstrument</classname> by allowing you to toggle its
ability to forward <classname>MKNote</classname>s to an
<classname>MKInstrument</classname>.</para>
	</listitem>

<listitem><para> It acts as a jack into which you can plug a
<classname>MKPerformer</classname> object's
<classname>MKNoteSender</classname>.  This connects the
<classname>MKPerformer</classname> that owns the
<classname>MKNoteSender</classname> to the
<classname>MKInstrument</classname> that owns the
<classname>MKNoteReceiver</classname>, such that the
<classname>MKNote</classname>s generated by the
<classname>MKPerformer</classname> are automatically delivered to and
realized on the connected <classname>MKInstrument</classname>.  The
methods by which you marry a <classname>MKNoteReceiver</classname> to
a <classname>MKNoteSender</classname> are described later in the
section on <classname>MKPerformer</classname>s and
<classname>MKNoteSender</classname>s.</para>
	  </listitem>
	</itemizedlist>

<para>Creating and adding <classname>MKNoteReceiver</classname>s is
usually part of the design of the <classname>MKInstrument</classname>
subclass, although some subclasses require you to create and add
<classname>MKNoteReceiver</classname>s yourself.  In either case, the
method by which a <classname>MKNoteReceiver</classname> is added to an
<classname>MKInstrument</classname> is the same:
<classname>MKInstrument</classname>'s <emphasis
role="bold">addNoteReceiver:</emphasis>.
While an <classname>MKInstrument</classname> can own more than one
<classname>MKNoteReceiver</classname>, a single
<classname>MKNoteReceiver</classname> can belong to only one
<classname>MKInstrument</classname>: An invocation of <emphasis
role="bold">addNoteReceiver:</emphasis>
removes the argument (the <classname>MKNoteReceiver</classname>) from
its current owner.</para>

      <sect3 id="receiveNote">
	<title>The receiveNote: Method</title>

<para>The fundamental method through which a
<classname>MKNoteReceiver</classname> itself receives
<classname>MKNote</classname>s&horbar;and thereby forwards them to its
owning <classname>MKInstrument</classname>&horbar;is called <emphasis
role="bold">receiveNote:</emphasis>.  However, before you can send
<emphasis role="bold">receiveNote:</emphasis> to a
<classname>MKNoteReceiver</classname>, you must be able to locate the
object.  If you created and added
<classname>MKNoteReceiver</classname>s to an
<classname>MKInstrument</classname> yourself, finding these objects
shouldn't pose a problem&horbar;you made them, you should know where
they are.  But keep in mind that many
<classname>MKInstrument</classname>s create and add
<classname>MKNoteReceiver</classname>s for you.  Any
<classname>MKInstrument</classname>'s
<classname>MKNoteReceiver</classname>s can be retrieved as a
<classname>NSArray</classname> object by sending the <emphasis
role="bold">noteReceivers</emphasis> message to the
<classname>MKInstrument</classname>; members of this
<classname>NSArray</classname> can then be sent the <emphasis
role="bold">receiveNote:</emphasis> message.  As a convenience, the
first <classname>MKNoteReceiver</classname> in this
<classname>NSArray</classname> can be retrieved through the <emphasis
role="bold">noteReceiver</emphasis> method.  This is particularly
handy for <classname>MKInstrument</classname>s that define only one
<classname>MKNoteReceiver</classname>, or in situations where you
don't care which <classname>MKNoteReceiver</classname> you send the
<classname>MKNote</classname> to.  In the following example, an
instance of <classname>MKSynthInstrument</classname> is created and a
<classname>MKNote</classname> is sent to its
<classname>MKNoteReceiver</classname>.  <classname>MKSynthInstrument</classname> is a
subclass of <classname>MKInstrument</classname> that realizes
<classname>MKNote</classname>s by synthesizing them on the <acronym>DSP</acronym>; it
creates a single <classname>MKNoteReceiver</classname> as part of its
<emphasis role="bold">init</emphasis> method:</para>

<programlisting>
/* Create a MKSynthInstrument and send it a MKNote (assumed to exist). */
aSynthIns = [[MKSynthInstrument alloc] init];

[MKConductor lockPerformance];
[[aSynthIns noteReceiver] receiveNote:aNote];
[MKConductor unlockPerformance];
</programlisting>

<para>You'll note the presence of the
<classname>MKConductor</classname> class methods <emphasis
role="bold">lockPerformance</emphasis> and <emphasis
role="bold">unlockPerformance</emphasis>; invocations of these two
methods should bracket all invocations of <emphasis
role="bold">receiveNote:</emphasis> (with some exceptions, as noted in
the sections on <classname>MKConductor</classname>s and
<classname>MKPerformer</classname>s, later in this chapter).  Briefly,
these methods ensure that your cast of characters are in synch and
primed for timely <classname>MKNote</classname> realization.  A fuller
explanation of <emphasis role="bold">lockPerformance</emphasis> and
<emphasis role="bold">unlockPerformance</emphasis> is given in
<xref linkend="LockingThePerformance"> later in this chapter.</para>

<para>You can create and add any number of
<classname>MKNoteReceiver</classname>s to the
<classname>MKInstrument</classname>s that you allocate, even if these
<classname>MKInstrument</classname>s create
<classname>MKNoteReceiver</classname>s themselves.  However, with some
exceptions&horbar;notably that described in the next
section&horbar;there isn't much reason to do so: One
<classname>MKNoteReceiver</classname> is as good as the next.  Any
number of <classname>MKNote</classname>-producing
agents&horbar;whether <classname>MKPerformer</classname>s or different
mechanisms in your application&horbar;can all send <emphasis
role="bold">receiveNote:</emphasis> to the same
<classname>MKNoteReceiver</classname>.  In general, adding a gaggle of
<classname>MKNoteReceiver</classname>s to an
<classname>MKInstrument</classname> doesn't make the
<classname>MKInstrument</classname> more interesting, it simply makes
it bigger.</para>
      </sect3>
      <sect3 id="SquelchingAMKNoteReceiver">
	<title>Squelching a <classname>MKNoteReceiver</classname></title>

<para>You can throttle a <classname>MKNoteReceiver</classname>'s
ability to invoke <emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis>
by sending it the <emphasis role="bold">squelch</emphasis> message.
To release this clench, you invoke <emphasis
role="bold">unsquelch</emphasis>.  Through this simple feature, you
can easily and quickly mute an
<classname>MKInstrument</classname>.</para>

<para>While a <classname>MKNoteReceiver</classname> is squelched, the
<emphasis role="bold">receiveNote:</emphasis> method ceases to
function: It immediately returns <emphasis role="bold">nil</emphasis>
without forwarding the argument <classname>MKNote</classname> to the
<classname>MKNoteReceiver</classname>'s owner (unsquelched, <emphasis
role="bold">receiveNote:</emphasis> returns <emphasis
role="bold">self</emphasis>).  Realization of the
<classname>MKNote</classname> isn't merely deferred, it's abandoned
for good.  You can determine whether a
<classname>MKNoteReceiver</classname> is squelched by sending it the
<emphasis role="bold">isSquelched</emphasis> message: If the message
returns <constant>YES</constant>, the object is squelched.</para>

<para>The squelch feature, in certain applications, argues for the use
of multiple <classname>MKNoteReceiver</classname>s for a single
<classname>MKInstrument</classname>.  For example, you can create an
application in which <classname>MKNote</classname>s are generated from
<acronym>MIDI</acronym> input and read from a <classname>MKPart</classname> object at the
same time.  If you feed these two <classname>MKNote</classname>
sources to the same <classname>MKInstrument</classname>, you may want
to create and add two distinct <classname>MKNoteReceiver</classname>s,
one for either source, so you can independently squelch the two
streams of <classname>MKNote</classname>s.</para>
      </sect3>
      <sect3 id="PerformanceStatus">
	<title>Performance Status</title>

<para>An <classname>MKInstrument</classname> is considered to be in
performance from the time that you send <emphasis
role="bold">receiveNote:</emphasis> to any of its unsquelched
<classname>MKNoteReceiver</classname>s until the performance is
over&horbar;in other words, until the
<classname>MKConductor</classname> class receives the <emphasis
role="bold">finishPerformance</emphasis> message.  You can query an
<classname>MKInstrument</classname>'s performance status by sending it
the <emphasis role="bold">inPerformance</emphasis> message, where a
return of <constant>YES</constant> signifies that the object is currently in
performance.</para>

<para>The performance status of an <classname>MKInstrument</classname>
is significant because some <classname>MKInstrument</classname>
methods aren't effective while the <classname>MKInstrument</classname>
is in performance.  This can be a particularly devilish source of
confusion since the state of an <classname>MKInstrument</classname>'s
performance doesn't require a performance, in the larger sense, to be
in progress.  Specifically, if you send <emphasis
role="bold">receiveNote:</emphasis> to an
<classname>MKInstrument</classname>'s
<classname>MKNoteReceiver</classname> <emphasis>before</emphasis> the
<classname>MKConductor</classname> class receives <emphasis
role="bold">startPerformance</emphasis>, the
<classname>MKInstrument</classname> will, nonetheless, be considered
to be performing (and thus the aforementioned performance-status
dependent methods will have no effect).</para>
      </sect3>
    </sect2>
    <sect2 id="RealizingMKNotes">
      <title>Realizing <classname>MKNote</classname>s</title>

<para>There are very few rules when it comes to realizing
<classname>MKNote</classname>s: You can implement <emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis>
to realize a <classname>MKNote</classname> in almost any arbitrary
manner.  As mentioned earlier, the <productname>MusicKit</productname> includes
<classname>MKInstrument</classname>s that synthesize and store
<classname>MKNote</classname>s as their forms of realization.  For
many performance applications, the
<classname>MKInstrument</classname>s provided by the <productname>MusicKit</productname> are
sufficient.  The following sections describe these subclasses.</para>

      <sect3 id="MKSynthInstrument">
	<title><classname>MKSynthInstrument</classname></title>

<para>A <classname>MKSynthInstrument</classname> is by far the most complicated
<classname>MKInstrument</classname>; it realizes
<classname>MKNote</classname>s by causing them to be synthesized on
the <acronym>DSP</acronym>.  It operates on three basic principles:</para>

<itemizedlist>

<listitem><para> Every instance of <classname>MKSynthInstrument</classname> is associated
with a single subclass of <classname>MKSynthPatch</classname>.</para>
	  </listitem>

<listitem><para> Before or during a performance, a <classname>MKSynthInstrument</classname>
object allocates (through requests to the <classname>MKOrchestra</classname>) and manages
instances of its <classname>MKSynthPatch</classname> subclass.  These <classname>MKSynthPatch</classname> objects
are used to synthesize the <classname>MKNote</classname>s that the
<classname>MKSynthInstrument</classname> receives through its
<classname>MKNoteReceiver</classname>.</para>
	  </listitem>
	</itemizedlist>

<para>Following these principles, the primary decisions you need to
make regarding a <classname>MKSynthInstrument</classname> are which <classname>MKSynthPatch</classname> subclass to
assign it and which of two schemes it should use to allocate instances
of the <classname>MKSynthPatch</classname> subclass.</para>

	<sect4 id="SettingTheMKSynthPatchSubclass">
	  <title>Setting the <classname>MKSynthPatch</classname> Subclass</title>

<para>You set a <classname>MKSynthInstrument</classname>'s <classname>MKSynthPatch</classname> subclass by invoking
the <emphasis role="bold">setSynthPatchClass:</emphasis> method.  As
the method's argument you specify one of the <classname>MKSynthPatch</classname> classes
included in the <productname>MusicKit</productname>, or one of your own.  If you have a
multiple-<acronym>DSP</acronym> system, the <classname>MKSynthInstrument</classname> will allocate its
<classname>MKSynthPatch</classname> objects on the first <acronym>DSP</acronym> that has sufficient available
resources.  You can restrict allocation to a specific <acronym>DSP</acronym> by invoking
<emphasis role="bold">setSynthPatchClass:orchestra:</emphasis>,
passing an <classname>MKOrchestra</classname> object as the second argument.</para>

<para><emphasis role="bold"><classname>MKNote</classname>:</emphasis>
If you use a <classname>MKSynthPatch</classname> class included in the <productname>MusicKit</productname>, you must
import the file <emphasis
role="bold">&lt;musickit/synthpatches/</emphasis><emphasis>ClassName</emphasis>.h&gt;,
where <emphasis>ClassName</emphasis> is the name of the class you wish
to use.  Alternatively, the file <emphasis
role="bold">&lt;musickit/synthpatches/synthpatches.h&gt;</emphasis>
will import all the <productname>MusicKit</productname> <classname>MKSynthPatch</classname> interface files.</para>

<para>The <emphasis role="bold">setSynthPatchClass:</emphasis> method
(and the <emphasis role="bold">...orchestra:</emphasis> version)
checks its (first) argument to ensure that it's a class that inherits
from <classname>MKSynthPatch</classname>, returning <emphasis
role="bold">nil</emphasis> if it doesn't.</para>

<para>You can also change the synthPatchClass by sending it a
<emphasis role="bold">mute</emphasis> note with a parameter <emphasis
role="bold">synthPatch:</emphasis>.  The value of this parameter
should be the name of the class (a string.)</para>

	</sect4>
	<sect4 id="AllocationMode">
	  <title>Allocation Mode</title>

	  <para><classname>MKSynthInstrument</classname> defines two allocation modes:</para>

	  <itemizedlist>

	    <listitem>
	      <para>In <emphasis>automatic allocation mode</emphasis>
the <classname>MKSynthInstrument</classname> allocates <classname>MKSynthPatch</classname> objects as it receives
<classname>MKNote</classname>s, tagging each <classname>MKSynthPatch</classname> with the
note tag of the <classname>MKNote</classname> for which it was
allocated.  As it receives subsequent <classname>MKNote</classname>s,
the <classname>MKSynthInstrument</classname> compares each <classname>MKNote</classname>'s
note tag to those of the <classname>MKSynthPatch</classname>es it has already allocated.  If
it finds a match, the <classname>MKNote</classname> is sent to that
<classname>MKSynthPatch</classname>.  If it doesn't match, the <classname>MKSynthInstrument</classname> allocates a
new <classname>MKSynthPatch</classname>.</para>
	    </listitem>

	    <listitem>
<para>In <emphasis>manual allocation mode</emphasis> the <classname>MKSynthPatch</classname>
objects are allocated all at once, before
<classname>MKNote</classname>s begin to arrive.  The number of
<classname>MKSynthPatch</classname>es to allocate is set through the method <emphasis
role="bold">setSynthPatchCount:</emphasis>.  The number of
<classname>MKSynthPatch</classname>es that are actually allocated may be less than the number
requested, depending on the availability of <acronym>DSP</acronym> resources at the time
that the message is sent.  The method returns the number of
<classname>MKSynthPatch</classname>es that were actually allocated.</para>
	    </listitem>
	  </itemizedlist>

<para>By default, a <classname>MKSynthInstrument</classname> is in automatic allocation mode.
Simply sending <emphasis role="bold">setSynthPatchCount:
</emphasis>places it in manual mode.  To set it back to automatic
mode, you send it the <emphasis role="bold">autoAlloc</emphasis>
message.</para>

<para>You can query a <classname>MKSynthInstrument</classname>'s
allocation mode by invoking <emphasis
role="bold">allocMode</emphasis>, a method that returns one of the
following integer constants:</para>

	  <table frame=all>
	    <title><classname>MKSynthInstrument</classname>'s allocation modes</title>
	    <tgroup cols=2 colsep=1 rowsep=1>
	      <colspec colnum=1 align=left>
	      <colspec colnum=2 align=left>
	      <thead>
		<row>
		  <entry>Constant</entry> <entry>Mode</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><constant>MK_AUTOALLOC</constant></entry>
		  <entry>Automatic allocation</entry>
		</row>
		<row>
		  <entry><constant>MK_MANUALALLOC</constant></entry>
                  <entry>Manual allocation</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</sect4>
	<sect4 id="ChangingTheMKSynthPatchCount">
	  <title>Changing the <classname>MKSynthPatch</classname> Count</title>

<para>You can change the number of manually allocated
<classname>MKSynthPatch</classname>es at any time&horbar;even during a
performance&horbar;simply by resending the <emphasis
role="bold">setSynthPatchCount:</emphasis> message.  Notice, however,
that the argument is always taken as the total number of
<classname>MKSynthPatch</classname>es that are allocated to the
<classname>MKSynthInstrument</classname>&horbar;it doesn't represent
the number of new objects to allocate.  For example, in the following
sequence of messages, a total of four
<classname>MKSynthPatch</classname>es are allocated.</para>


<programlisting>
/* Allocate three MKSynthPatches. */
[aSynthIns setSynthPatchCount: 3];
. . .

/* Allocate one more. */
[aSynthIns setSynthPatchCount: 4];
</programlisting>

<para>The <emphasis role="bold">synthPatchCount</emphasis> method
returns the number of manually allocated <classname>MKSynthPatch</classname>es.  Thus, the
previous example can be rewritten as:</para>

<programlisting>
/* Allocate three MKSynthPatches. */
[aSynthIns setSynthPatchCount: 3];
. . .

/* Allocate one more. */
[aSynthIns setSynthPatchCount: [aSynthIns synthPatchCount]+1];
</programlisting>

<para>If the <classname>MKSynthInstrument</classname> is in automatic
mode, <emphasis role="bold">synthPatchCount</emphasis> returns
0.</para>

<para>Deallocating <classname>MKSynthPatch</classname> objects is also
possible:</para>

<programlisting>
/* Allocate three MKSynthPatches. */
[aSynthIns setSynthPatchCount: 3];
. . .

/* Deallocate two of them. */
[aSynthIns setSynthPatchCount: [aSynthIns synthPatchCount]-2];
</programlisting>

<para>If the argument signifies a deallocation, the
<classname>MKSynthInstrument</classname>'s idle
<classname>MKSynthPatch</classname>es, if any, are deallocated first;
the balance are deallocated as they become inactive.</para>

<para>You can also change the synthPatchCount by sending it a
<emphasis role="bold">mute</emphasis> note with a parameter <emphasis
role="bold">synthPatchCount</emphasis>.</para>

	</sect4>
	<sect4 id="TheMKPatchTemplate">
	  <title>The <classname>MKPatchTemplate</classname></title>

<para>Some <classname>MKSynthPatch</classname>es come in a variety of
configurations.  For example, the <classname>Fm1vi</classname>
<classname>MKSynthPatch</classname> (frequency modulation with
optional vibrato) is configured differently depending on whether the
<classname>MKNote</classname> it's synthesizing specifies vibrato.  It
does this to be as efficient as possible&horbar;excluding vibrato from
<classname>Fm1vi</classname>'s configuration means that it uses less
of the <classname>MKOrchestra</classname>'s resources.</para>

<para>A <classname>MKSynthPatch</classname> represents each of its
configurations as a different <classname>MKPatchTemplate</classname>
object.  When you set a <classname>MKSynthInstrument</classname> to
manual allocation mode, you can specify the number of
<classname>MKSynthPatch</classname>es with a particular
<classname>MKPatchTemplate</classname> by invoking the <emphasis
role="bold">setSynthPatchCount:forPatchTemplate:</emphasis> method.
The second argument is the <emphasis role="bold">id</emphasis> of the
<classname>MKPatchTemplate</classname> that you want.  This is
returned by sending the <emphasis
role="bold">patchTemplateFor:</emphasis> message to the
<classname>MKSynthInstrument</classname>'s
<classname>MKSynthPatch</classname> class, with a
<classname>MKNote</classname> object as the argument.  This is best
explained by example:</para>

<programlisting>
/* Create a MKSynthInstrument. */
id aSynthIns = [[MKSynthInstrument alloc] init];

/* Create a variable to store the MKPatchTemplate. */
id noVibTemplate;

/* Create a dummy MKNote. */
id aNote = [[MKNote alloc] init];

/* Set its vibrato amplitudes to 0.0. */
[aNote setPar: MK_svibAmp toDouble: 0.0];
[aNote setPar: MK_rvibAmp toDouble: 0.0];

/* Retrieve the MKPatchTemplate senza vibrato. */
noVibTemplate = [[aSynthIns synthPatchClass] patchTemplateFor:aNote];

/* Allocate three vibratoless MKSynthPatches. */
[aSynthIns setSynthPatchCount: 3 forPatchTemplate: noVibTemplate];
</programlisting>

<para>If the <classname>MKPatchTemplate</classname> isn't specified,
the <classname>MKSynthPatch</classname>es are created using the
<emphasis>default <classname>MKPatchTemplate</classname></emphasis>.
Each subclass of <classname>MKSynthPatch</classname> designates one of
its <classname>MKPatchTemplate</classname>s as the default for that
class; by convention, the most extravagant
<classname>MKPatchTemplate</classname> is provided as the default.
Thus, the default <classname>Fm1vi</classname>
<classname>MKPatchTemplate</classname> includes vibrato.  In the
example, the <classname>Fm1vi</classname>
<classname>MKPatchTemplate</classname> without vibrato is retrieved by
passing (as the second argument to <emphasis
role="bold">patchTemplateFor:</emphasis>) a
<classname>MKNote</classname> that explicitly sets the vibrato
parameters to 0.0.</para>

<para>Within the same <classname>MKSynthInstrument</classname>, you
can manually allocate <classname>MKSynthPatch</classname>es that use
different <classname>MKPatchTemplate</classname>s.  The following
extension of the previous example demonstrates this:</para>

<programlisting>
/* Allocate one vibratoless MKSynthPatch. */
[aSynthIns setSynthPatchCount: 1 forPatchTemplate: noVibTemplate];

/* And two with vibrato. */
[aSynthIns setSynthPatchCount: 2];
</programlisting>

<para><emphasis role="bold">setSynthPatchCount:</emphasis> always uses
the default <classname>MKPatchTemplate</classname> (which, as
mentioned earlier, includes vibrato for <classname>Fm1vi</classname>).
When the <classname>MKSynthInstrument</classname> in the example
receives a <classname>MKNote</classname> that initiates a new phrase,
it automatically forwards the <classname>MKNote</classname> to the
proper <classname>MKSynthPatch</classname>: If the
<classname>MKNote</classname> contains vibrato parameters with zero
values (similar to the dummy <classname>MKNote</classname> used in the
previous example), it's forwarded to the
<classname>MKSynthPatch</classname> that excludes vibrato; otherwise,
it's sent to one of the other two
<classname>MKSynthPatch</classname>es.</para>

<para>The <classname>MKSynthInstrument</classname> keeps a count of
the number of <classname>MKSynthPatch</classname>es it has manually
allocated for each <classname>MKPatchTemplate</classname>.  The count
for a particular <classname>MKPatchTemplate</classname> is returned by
the method <emphasis
role="bold">synthPatchCountForPatchTemplate:</emphasis>.  The
<emphasis role="bold">synthPatchCount</emphasis> method, used in an
example in the previous section, returns the count for the default
<classname>MKPatchTemplate</classname>.</para>

<para>If the <classname>MKSynthPatch</classname> is in automatic mode,
you don't need to specify which <classname>MKPatchTemplate</classname>
to use.  The <classname>MKSynthInstrument</classname> automatically
creates a <classname>MKSynthPatch</classname> with the correct
<classname>MKPatchTemplate</classname> to accommodate the parameters
in the <classname>MKNote</classname>s it receives.</para>

	</sect4>
	<sect4 id="TalkingToTheMKSynthPatches">
	  <title>Talking to the <classname>MKSynthPatch</classname>es</title>

<para>A <classname>MKSynthInstrument</classname>'s primary task is to
forward <classname>MKNote</classname>s to its
<classname>MKSynthPatch</classname>es.  The
<classname>MKSynthPatch</classname> class defines three methods that
are designed to be invoked by a
<classname>MKSynthInstrument</classname> for this purpose:</para>

<itemizedlist>

<listitem><para> <emphasis role="bold">noteOn:</emphasis> is used to
forward a noteOn type <classname>MKNote</classname>.</para>
	  </listitem>

<listitem><para> <emphasis role="bold">noteUpdate:</emphasis> forwards
noteUpdates.</para>
	  </listitem>

<listitem><para> <emphasis role="bold">noteOff:</emphasis>, likely
enough, forwards noteOffs.</para>
	  </listitem>
	</itemizedlist>

<para>The <classname>MKNote</classname> itself is passed as the
argument to the method.  Invocation of these methods is automatic;
when a <classname>MKSynthInstrument</classname> receives a
<classname>MKNote</classname> during a performance, it automatically
invokes the appropriate method.</para>

<para>Notice that noteDurs and mutes aren't included in this scheme.
A noteDur is split into a noteOn/noteOff pair.  If the noteDur doesn't
have a noteTag, a unique noteTag is created and given to the two new
<classname>MKNote</classname>s.  Mutes are simply ignored.</para>

<para>Besides forwarding <classname>MKNote</classname>s, the <emphasis
role="bold">noteOn:</emphasis> and <emphasis
role="bold">noteOff:</emphasis> methods also set a
<classname>MKSynthPatch</classname>'s <emphasis>synthesis
status</emphasis>.  This describes the object's current synthesis
state as one of the following MKSynthStatus constants:</para>

	  <table frame=all>
	    <title><classname>MKSynthInstrument</classname>'s synthesis states</title>
	    <tgroup cols=2 colsep=1 rowsep=1>
	      <colspec colnum=1 align=left>
	      <colspec colnum=2 align=left>
	      <thead>
		<row>
		  <entry>Constant</entry> <entry>Meaning</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><constant>MK_idle</constant></entry>
		  <entry>The <classname>MKSynthPatch</classname> is currently inactive.</entry>
		</row>
		<row>
		  <entry><constant>MK_running</constant></entry> 
		  <entry>The
		  <classname>MKSynthPatch</classname> is synthesizing
		  the body of a musical note.</entry>
		</row>
		<row>
		  <entry><constant>MK_finishing</constant></entry>
                  <entry>The
		  <classname>MKSynthPatch</classname> is in the
		  release portions of its
		  <classname>MKEnvelope</classname>s.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	  
<para>The <emphasis role="bold">noteOn:</emphasis> message sets the
synthesis status to <constant>MK_running</constant>; <emphasis
role="bold">noteOff:</emphasis> sets it to
<constant>MK_finishing</constant>.  In either of these states, the
<classname>MKSynthPatch</classname> is considered to be active.  The
status is set to <constant>MK_idle</constant> when the release portion of the
<classname>MKSynthPatch</classname>'s amplitude
<classname>MKEnvelope</classname> (in other words, the object set as
the value of the MK_ampEnv parameter of the
<classname>MKNote</classname> that the
<classname>MKSynthPatch</classname> is realizing) is complete.  None
of the other <classname>MKEnvelope</classname>s are taken into
consideration when determining if the
<classname>MKSynthPatch</classname> is idle: It's assumed that the
amplitude <classname>MKEnvelope</classname> will ultimately fall to an
amplitude of 0.0, thus whatever course the other
<classname>MKEnvelope</classname>s take after that point is for nought
since the <classname>MKSynthPatch</classname> will no longer be making
any noise.</para>

	</sect4>
	<sect4 id="TheUpdateState">
	  <title>The Update State</title>

<para>The <classname>MKSynthInstrument</classname> class gives special
consideration to a noteUpdate that doesn't have a note tag:</para>

<itemizedlist>

<listitem><para> The noteUpdate is forwarded to all the active
<classname>MKSynthPatch</classname>es (within the <classname>MKSynthInstrument</classname> that received the
<classname>MKNote</classname>).</para>
	  </listitem>

<listitem><para> The <classname>MKNote</classname>'s parameters are
stored in the <classname>MKSynthInstrument</classname>'s <emphasis>update
state</emphasis>.</para>
	  </listitem>
	</itemizedlist>

<para>Every <classname>MKSynthInstrument</classname> has an update
state.  When a <classname>MKSynthInstrument</classname> begins a new
phrase, the parameters in the update state are merged into the
<classname>MKNote</classname> that initiated the phrase (always a
noteOn, whether by nature or due to a noteDur split).  The update
state parameters never overwrite the value of a parameter already
present in a noteOn&horbar;in the case of a parameter collision, the
noteOn's parameter takes precedence.  Conversely, a noteOn's
parameters never affect the update state, it can only be changed by
another noteUpdate with no note tag.</para>

<para>As a demonstration of these principles, consider the following
scorefile excerpt:</para>

<programlisting>
/* Scorefile body excerpt. */
t 0.0;
part1 (noteUpdate) amp:.25;
t 1.0;
part1 (noteOn 1) freq:c4; /* amplitude is .25 */
t 2.0;
part1 (noteOff 1);
t 3.0;
part1 (noteOn 2) freq:d4 amp:.75; /* amplitude is .75 */
t 4.0;
part1 (noteOff 2);
t 5.0;
part1 (noteOn 3) freq:e4; /* amplitude is, once again, .25 */
t 6.0;
part1 (noteUpdate) amp:.5;
t 7.0;
part1 (noteUpdate 3) amp:.25;
t 8.0;
part1 (noteOff 3);
t 9.0;
part1 (noteOn 4) freq: f4; /* amplitude is .5 */
t 10.0;
part1 (noteOff 4);
</programlisting>

<para>The initial note tag-less noteUpdate sets the amplitude
parameter in the <classname>MKSynthInstrument</classname>'s update
state; notice that the update state is set even though the
<classname>MKSynthInstrument</classname> doesn't have any active
<classname>MKSynthPatch</classname>es.  Of the four subsequent
noteOns, the first, third, and fourth don't have amplitude parameters
so they inherit the one in the update state.  The second noteOn has
its own amplitude; it ignores the parameter in the update
state.</para>

<para>While the third musical note is sounding, two more noteUpdates
arrive.  The first has no note tag, so it affects both the active
<classname>MKSynthPatch</classname> and the update state.  The second
noteUpdate's note tag matches that of the active
<classname>MKSynthPatch</classname>; it's forwarded to the
<classname>MKSynthPatch</classname> but doesn't affect the update
state.</para>

	</sect4>
	<sect4 id="PreemptingAMKSynthPatch">
	  <title>Preempting a <classname>MKSynthPatch</classname></title>

	  <para>While the <acronym>DSP</acronym> makes a great synthesizer, its resources
are by no means unlimited.  It's possible to ask it to synthesize, at
the same time, more <classname>MKNote</classname>s than it can
accommodate.  The number of <classname>MKNote</classname>s that can be
synthesized at one time depends on a number of factors, the most
significant being the sampling rate and the requirements of the
<classname>MKSynthPatch</classname>es that are being used.  There
sometimes comes a time in the life of a
<classname>MKSynthInstrument</classname> when it tries to allocate
just one more <classname>MKSynthPatch</classname> and finds that the
well is empty.</para>

<para>When a <classname>MKSynthInstrument</classname> can't get the
resources to synthesize a new <classname>MKNote</classname>, it tries
to preempt an active <classname>MKSynthPatch</classname> rather than
lose the <classname>MKNote</classname>.  The following steps are taken
to determine which <classname>MKSynthPatch</classname> to
preempt:</para>

	  <orderedlist>
	    <listitem>
	      <para>The preempted <classname>MKSynthPatch</classname>
should have sufficient resources to synthesize the
<classname>MKNote</classname>, thus the
<classname>MKSynthInstrument</classname> first looks for a
<classname>MKSynthPatch</classname> that uses the same
<classname>MKPatchTemplate</classname> that's needed to synthesize the
new <classname>MKNote</classname>.</para>
	    </listitem>

	    <listitem>
	      <para>If there's more than one such
<classname>MKSynthPatch</classname>, the one that first received a
<emphasis role="bold">noteOff:</emphasis> message, if any, is
preempted.  In other words, the preemption scheme first looks for a
<classname>MKSynthPatch</classname> whose synthesis status is
<constant>MK_finishing</constant>.</para>
	    </listitem>

	    <listitem>
<para>If there aren't any finishing
<classname>MKSynthPatch</classname>es, the oldest
<classname>MKSynthPatch</classname> is chosen.</para>
	    </listitem>

	    <listitem>
	      <para>If a <classname>MKSynthPatch</classname> with the
appropriate <classname>MKPatchTemplate</classname> isn't available,
the <classname>MKSynthInstrument</classname> tries other
<classname>MKSynthPatch</classname>es until one is found that has
sufficient resources to synthesize the new
<classname>MKNote</classname>.</para>
	    </listitem>
	  </orderedlist>

<para>A <classname>MKSynthInstrument</classname> object can only
preempt its own <classname>MKSynthPatch</classname>es&horbar;it can't
steal one from another <classname>MKSynthInstrument</classname>.  The
search for a preemptible <classname>MKSynthPatch</classname> is
sometimes unsuccessful; for example, if there are no more resources to
build a new <classname>MKSynthPatch</classname>, the new
<classname>MKNote</classname> can't be synthesized.</para>

	</sect4>
	<sect4 id="ProvidingYourOwnPreemptionScheme">
	  <title>Providing Your Own Preemption Scheme</title>

<para>The determination of which <classname>MKSynthPatch</classname>
to preempt is performed in the <emphasis
role="bold">preemptSynthPatchFor:patches:</emphasis> method: The
method's return value is taken as the
<classname>MKSynthPatch</classname> to preempt.  If you want to
provide your own system for preempting
<classname>MKSynthPatch</classname>es, you have to create your own
subclass of <classname>MKSynthInstrument</classname> in which to
reimplement this method.</para>

<para>The method is automatically invoked when the
<classname>MKSynthInstrument</classname> has to preempt a
<classname>MKSynthPatch</classname>.  The two arguments are:</para>

	  <itemizedlist>
	    <listitem>
	      <para>The newly arrived
	      <classname>MKNote</classname></para>
	    </listitem>

	    <listitem>
	      <para>The first in a list of candidate
	      <classname>MKSynthPatch</classname>es</para>
	    </listitem>
	  </itemizedlist>

<para>Notice that the second argument is a single
<classname>MKSynthPatch</classname> object.  To get to the next object
in the list, you send <emphasis role="bold">next</emphasis> to the
<classname>MKSynthPatch</classname> at hand.</para>
	</sect4>
      </sect3>
      <sect3 id="MKMidi">
      <title><classname>MKMidi</classname></title>

<para>The <classname>MKMidi</classname> class isn't a true
<classname>MKInstrument</classname>&horbar;it inherits from <classname>NSObject</classname>.
However, it creates <classname>MKNoteReceiver</classname>s and
implements <emphasis
role="bold">realizeNote:fromNoteReceiver:</emphasis>
and so can be used as an <classname>MKInstrument</classname>.</para>

<para>A <classname>MKMidi</classname> object creates 17
<classname>MKNoteReceiver</classname>s, one for the Basic Channel and
one each for the 16 Voice Channels.  You can retrieve the
<classname>MKNoteReceiver</classname> that corresponds to a particular
channel through the <emphasis
role="bold">channelNoteReceiver:</emphasis>
message, passing the channel number that you want: 0 retrieves the
<classname>MKNoteReceiver</classname> for System and Channel Mode
Messages; 1-16 retrieves the <classname>MKNoteReceiver</classname> for
the corresponding Voice Channel.  You create a
<classname>MKMidi</classname> object to correspond to a <acronym>MIDI</acronym> device (a
serial port on NeXT hardware, <acronym>MIDI</acronym> card on Intel-based hardware, CoreMIDI
port on MacOS X, DirectMusic port on Windows etc.),
specified as &ldquo;midi0&rdquo;, &ldquo;midi1,&rdquo; etc., in the
<emphasis role="bold">midiOnDevice:</emphasis> method.</para>

<para>When it receives a <classname>MKNote</classname>, the
<classname>MKMidi</classname> object translates it into a series of
<acronym>MIDI</acronym> messages, based on the <classname>MKNote</classname>'s note type
and parameters that it contains.  It then sends the messages out the
serial port.</para>

<para>A <classname>MKMidi</classname> object has a device status
that's much like the device status of the
<classname>MKOrchestra</classname> object, as described in 
<xref linkend="MusicSynthAndProc">
Before you can send <classname>MKNote</classname>s to a
<classname>MKMidi</classname> object (more accurately, before the
object will do anything with these <classname>MKNote</classname>s),
you must open and run it, through the <emphasis
role="bold">open</emphasis> and <emphasis role="bold">run</emphasis>
methods.</para>

<para>A <classname>MKMidi</classname> object can be made to receive
<acronym>MIDI</acronym> time code and provide it to a <classname>MKConductor</classname>
so that a performance can be synchronized to <acronym>MIDI</acronym> time code.  For
further information, see the <classname>MKMidi</classname> and
<classname>MKConductor</classname> class descriptions, as well as 
<xref linkend="MIDITimeCode">.</para>
    </sect3>
    <sect3 id="MKPartRecorderAndMKScoreRecorder">
      <title><classname>MKPartRecorder</classname> and
      <classname>MKScoreRecorder</classname></title>

<para><classname>MKPartRecorder</classname> is a fairly
straightforward <classname>MKInstrument</classname>: The
<classname>MKNote</classname>s that it receives through its single
<classname>MKNoteReceiver</classname> are copied and added to the
<classname>MKPart</classname> with which it's associated.  The
<classname>MKNoteReceiver</classname> is created automatically; the
<classname>MKPart</classname> must be set by your application, through
the <emphasis role="bold">set<classname>MKPart</classname>:</emphasis>
method.</para>

<para>A <classname>MKPartRecorder</classname> sets a
<classname>MKNote</classname>'s time tag to the current time as it
receives the <classname>MKNote</classname>; the measure of the current
time is either in beats or seconds, depending on the value of its
&ldquo;time unit.&rdquo; You can set the time unit through the
<emphasis role="bold">setTimeUnit:</emphasis> method, passing either
MK_second, MK_beat or MK_timeTag as the argument.  Other than the
manipulation of the time tag, the <classname>MKNote</classname> is
unchanged by the <classname>MKPartRecorder</classname>.</para>

<para><classname>MKScoreRecorder</classname> isn't actually an
<classname>MKInstrument</classname>; it's used to correspond to
<classname>MKScore</classname> just as a
<classname>MKPartRecorder</classname> corresponds to a
<classname>MKPart</classname>.  A
<classname>MKScoreRecorder</classname> actually creates and controls
some number of <classname>MKPartRecorder</classname>s, one for each
<classname>MKPart</classname> in its
<classname>MKScore</classname>.</para>

      </sect3>
      <sect3 id="MKScorefileWriter">
	<title><classname>MKScorefileWriter</classname></title>

<para>A <classname>MKScorefileWriter</classname> object realizes
<classname>MKNote</classname>s by writing them to a scorefile.  It's
the one <classname>MKInstrument</classname> defined by the <productname>MusicKit</productname>
that requires you to create and add
<classname>MKNoteReceiver</classname>s from your application.  Each
<classname>MKNoteReceiver</classname> that you add corresponds to a
<classname>MKPart</classname> that will be represented in the
scorefile that's written.  Typically, you name the
<classname>MKNoteReceiver</classname>s that you create; these names
are used to identify the corresponding
<classname>MKPart</classname>-representations in the scorefile:</para>

<programlisting>
/* Create a MKScorefileWriter and add to it 3 MKNoteReceivers. */
id aSFWriter = [[MKScorefileWriter alloc] init];
id fordReceiver = [[MKNoteReceiver alloc] init];
id pageReceiver = [[MKNoteReceiver alloc] init];
id quicklyReceiver = [[MKNoteReceiver alloc] init];

/* Name the MKNoteReceivers. */
MKNameObject("Ford", fordReceiver);
MKNameObject("Page", pageReceiver);
MKNameObject("Quickly", quicklyReceiver);

/* Add the MKNoteReceivers. */
[aSFWriter addNoteReceiver: fordReceiver];
[aSFWriter addNoteReceiver: pageReceiver];
[aSFWriter addNoteReceiver: quicklyReceiver];

/* Set the MKScorefileWriter's file by name. */
[aSFWriter setFile: "Falstaff.score"];
</programlisting>
      </sect3>
    </sect2>
    <sect2 id="MKInstrumentSubclass">
      <title>Creating an <classname>MKInstrument</classname> Subclass</title>

      <para>While there are no strict rules governing realization,
intelligent <classname>MKInstrument</classname> design should follow
these guidelines:</para>

      <itemizedlist>
	<listitem><para>An <classname>MKInstrument</classname> should realize
<classname>MKNote</classname>s as it receives them.  It's possible to
design an <classname>MKInstrument</classname> that, for instance,
reschedules its <classname>MKNote</classname>s to be realized later,
but for the sake of generality, an <classname>MKInstrument</classname>
should act immediately upon the <classname>MKNote</classname>s it
receives.</para>
	</listitem>

	<listitem><para>If an <classname>MKInstrument</classname> needs to
alter or store a <classname>MKNote</classname>, it should create a
copy of the <classname>MKNote</classname> and act upon the
copy.</para>
	</listitem>

	<listitem><para>An <classname>MKInstrument</classname> shouldn't be a
source of <classname>MKNote</classname>s.  The task of generating new
<classname>MKNote</classname>s belongs to a
<classname>MKPerformer</classname> or to your application.  The role
of an <classname>MKInstrument</classname> is to respond, not to
conceive.  This doesn't mean that an
<classname>MKInstrument</classname> can't create
<classname>MKNote</classname>s, but it should only do so in response
to receiving a <classname>MKNote</classname>.</para>
	</listitem>
      </itemizedlist>

      <para>Along with these guidelines, keep in mind that an
<classname>MKInstrument</classname> should, if possible, create and
add to itself some number of <classname>MKNoteReceiver</classname>s,
usually in its <emphasis role="bold">init</emphasis> method.</para>
    </sect2>
  </sect1>
  <sect1 id="MKConductorClass">
    <title>The <classname>MKConductor</classname> Class</title>

<para>The <classname>MKConductor</classname> class defines the
mechanism that controls the timing of a <productname>MusicKit</productname> performance.  This
control is divided between the class object and instances of
<classname>MKConductor</classname>:</para>

    <itemizedlist>
      <listitem><para>The <classname>MKConductor</classname> class
itself represents an entire <productname>MusicKit</productname>
performance.  The class methods perform global operations such as
setting characteristics that apply to all
<classname>MKConductor</classname> instances, and starting and
stopping a performance.</para>
      </listitem>

      <listitem><para>Each <classname>MKConductor</classname>
instance embodies a <emphasis>message request queue</emphasis>, a list
of messages that are to be sent to particular objects at specific
times.  Most of the instance methods are designed to affect a
<classname>MKConductor</classname>'s queue in some way.  The most
commonly invoked of these are the methods that enqueue message
requests, and those that determine how quickly a
<classname>MKConductor</classname> processes the requests in its queue
(in other words, the <classname>MKConductor</classname>'s
tempo).</para>
      </listitem>
    </itemizedlist>
    <sect2 id="MKConductorsCreatedByTheMusicKit">
      <title><classname>MKConductor</classname>s Created by the
      <productname>MusicKit</productname></title>

<para>The <productname>MusicKit</productname> automatically creates two
<classname>MKConductor</classname> instances for you, the
<emphasis>clockConductor</emphasis> and the
<emphasis>defaultConductor</emphasis>:</para>

      <itemizedlist>
	<listitem><para> As its name implies, the
<emphasis>clockConductor</emphasis> acts as a clock: It ticks away at
a steady and immutable 60.0 beats per minute.  Any timing information
that's reckoned by the other <classname>MKConductor</classname>
instances is computed in reference to the <emphasis>clockConductor</emphasis>.</para>
	</listitem>

	<listitem><para>Many applications need only a single
<classname>MKConductor</classname> instance (in addition to the
<emphasis>clockConductor</emphasis>); the
<emphasis>defaultConductor</emphasis> is created as a convenience to
meet this need.  The <emphasis>defaultConductor</emphasis> is more
pliable than the <emphasis>clockConductor</emphasis> in that its tempo
can be altered and its activities can be temporarily suspended during
a performance.</para>
	</listitem>
      </itemizedlist>

<para>The <emphasis>clockConductor</emphasis> is retrieved by sending the <emphasis
role="bold">clockConductor</emphasis> message to the
<classname>MKConductor</classname> class; similarly, <emphasis
role="bold">defaultConductor</emphasis> retrieves the
<emphasis>defaultConductor</emphasis>.</para>

    </sect2>
    <sect2 id="TheMessageRequestQueue">
      <title>The Message Request Queue</title>

<para>Every instance of <classname>MKConductor</classname> (this
includes the <emphasis>clockConductor</emphasis> and
<emphasis>defaultConductor</emphasis>) maintains a message request
queue.  This queue consists of a list of structures, each of which
encapsulates a request for a message to be sent to some object.  Every
request is given a timestamp that indicates when its message should be
sent.  The requests in a message request queue are sorted according to
these timestamps.  When a performance starts (through the <emphasis
role="bold">startPerformance</emphasis> class method), the
<classname>MKConductor</classname> instances begin processing their
message queues, sending the requested messages at the appropriate
times.</para>

<tip><para>The structures in the
message request queues are of type MKMsgStruct.  All the fields of
this structure are private: You can examine them, but you should never
alter their values directly.  Detailed knowledge of the MKMsgStruct
isn't necessary.  The structure is defined without further explanation
in the file <filename
class=headerfile>MusicKit/MKConductor.h</filename>.</para></tip>

      <sect3 id="CreatingAndSchedulingAMessageRequest">
	<title>Creating and Scheduling a Message Request</title>

	<para>To enqueue a message request with a
<classname>MKConductor</classname>, you invoke the <emphasis
role="bold">sel:to:atTime:argCount:</emphasis> or <emphasis
role="bold">sel:to:withDelay:argCount:</emphasis> method.  The
arguments to these methods are similar:</para>

	<table frame=all>
	  <title><classname>MKConductor</classname>'s message request arguments</title>
	  <tgroup cols=2 colsep=1 rowsep=1>
	    <colspec colnum=1 align=left>
	    <colspec colnum=2 align=left>
	    <thead>
	      <row>
		<entry>Keyword</entry> <entry>Argument</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>sel:</entry> 
		<entry>Selector that identifies the method you wish to
invoke.</entry>
	      </row>
	      <row>
		<entry>to:</entry> 
		<entry>The object that implements the desired method.</entry>
	      </row>
	      <row>
		<entry>atTime: <emphasis>or</emphasis> withDelay:</entry>
		<entry>The time at which you wish the method to be invoked.</entry>
	      </row>
	      <row>
		<entry>argCount:</entry>
		<entry>The number of method arguments, followed by the
arguments themselves, separated by commas.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

<para>The difference between the two methods is the manner in which
the time argument is interpreted.  A message request enqueued through
the <emphasis role="bold">...atTime:...</emphasis> method is sent at
the specified time measured from the beginning of the performance.  If
you use the <emphasis role="bold">...withDelay:...</emphasis> method,
the requested message is sent after the specified amount of time has
elapsed since the <emphasis
role="bold">sel:to:withDelay:argCount:</emphasis> method itself was
invoked (given that a performance is in progress).  Invoked before a
performance begins, the two methods are identical.</para>

<para>Once you've made a message request through one of these methods,
you can't rescind the action; if you need more control over message
requests&horbar;for example, if you need to be able to reschedule or
to remove a request&horbar;you should use the following C
functions:</para>

	  <itemizedlist>
	    <listitem><para> <emphasis
role="bold">MKNewMsgRequest(double</emphasis>
<emphasis>time</emphasis>, <emphasis role="bold">SEL</emphasis>
<emphasis>selector</emphasis>, <emphasis role="bold">id</emphasis>
<emphasis>receiver</emphasis>, <emphasis role="bold">int</emphasis>
<emphasis>argCount</emphasis>, <emphasis role="bold">...)</emphasis>
creates a new MKMsgStruct structure and returns a pointer to it.  The
arguments are similar, although in a different order, to those of the
<emphasis role="bold">sel:to:atTime:argCount:</emphasis>
method.</para>
</listitem>

	    <listitem><para><emphasis
role="bold">MKScheduleMsgRequest(MKMsgStruct
</emphasis>*<emphasis>aMsgStructPtr</emphasis>,<emphasis role="bold">
id </emphasis><emphasis>conductor</emphasis><emphasis
role="bold">)</emphasis> places the structure pointed to by
<emphasis>aMsgStructPtr</emphasis>, which was previously created
through <function>MKNewMsgRequest()</function>, in
<emphasis>conductor</emphasis>'s message request queue.</para>
</listitem>

	    <listitem><para><emphasis
role="bold">MKRepositionMsgRequest(MKMsgStruct
</emphasis>*<emphasis>aMsgStructPtr</emphasis>, <emphasis
role="bold">double </emphasis><emphasis>time</emphasis><emphasis
role="bold">)</emphasis> repositions a message request within a
<classname>MKConductor</classname>'s queue.  The value of the
<emphasis>time</emphasis> argument is absolute: It indicates the
request's new position as the number of beats since the beginning of
the performance.</para>
	    </listitem>

	    <listitem><para> <emphasis role="bold">MKCancelMsgRequest(MKMsgStruct
</emphasis>*<emphasis>aMsgStructPtr</emphasis><emphasis
role="bold">)</emphasis> removes a message request.</para>
	    </listitem>
	  </itemizedlist>

	  <para>The <classname>MKConductor</classname> class provides two
special message request queues, one that contains messages that are
sent at the beginning of a performance and another for messages that
are sent after a performance ends.  The class methods <emphasis
role="bold">beforePerformanceSel:to:argCount:</emphasis> and <emphasis
role="bold">afterPerformanceSel:to:argCount:</emphasis> enqueue
message requests in the before- and after-performance queues,
respectively.</para>

      </sect3>
      <sect3 id="ControllingAPerformance">
	<title>Controlling a Performance</title>

	<para>As previously mentioned, a <productname>MusicKit</productname> performance starts when the
<classname>MKConductor</classname> class receives the <emphasis
role="bold">startPerformance</emphasis> message.  This starts the
<classname>MKConductor</classname>'s clock ticking (as represented by
the <emphasis>clockConductor</emphasis>).  If you're synthesizing music on the <acronym>DSP</acronym> or
sending messages to an external <acronym>MIDI</acronym> synthesizer, you should send the
<emphasis role="bold">run</emphasis> message to the
<classname>MKOrchestra</classname> class or to your
<classname>MKMidi</classname> object at virtually the same time that
you invoke <emphasis role="bold">startPerformance</emphasis>:</para>

<programlisting>
/* Start MKMidi, the DSP, and the performance at the same time. */

[aMidi run]; /* assuming aMidi was previously created */
[MKOrchestra run];
[MKConductor startPerformance];
</programlisting>

	<para>When it receives <emphasis
role="bold">startPerformance</emphasis>, the
<classname>MKConductor</classname> class sends the messages in its
before-performance queue and then the
<classname>MKConductor</classname> instances start processing their
individual message request queues.  As a message is sent, the request
that prompted the message is removed from its queue.  The performance
ends when the <classname>MKConductor</classname> class receives
<emphasis role="bold">finishPerformance</emphasis>, at which time the
after-performance messages are sent.  Any message requests that remain
in the individual <classname>MKConductor</classname>s' message request
queues are removed.  Note, however, that the before-performance queue
isn't cleared.  If you invoke <emphasis
role="bold">beforePerformanceSel:to:argCount:</emphasis> during a
performance, the message request will survive a subsequent <emphasis
role="bold">finishPerformance</emphasis> and will affect the next
performance.</para>

<para>By default, if all the <classname>MKConductor</classname>s'
queues become empty at the same time (not including the before- and
after-performance queues), <emphasis
role="bold">finishPerformance</emphasis> is invoked automatically.
This is convenient if you're performing a
<classname>MKPart</classname> or a <classname>MKScore</classname> and
you want the performance to end when all the
<classname>MKNote</classname>s have been played.  However, for many
applications, such as those that create and perform
<classname>MKNote</classname>s in response to a user's actions,
universally empty queues aren't necessarily an indication that the
performance is over.  To allow a performance to continue even if all
the queues are empty, send <emphasis role="bold">setFinishWhenEmpty:NO
</emphasis> to the <classname>MKConductor</classname> class.</para>

<para>While a performance is in progress, you can pause all
<classname>MKConductor</classname>'s by sending <emphasis
role="bold">pausePerformance</emphasis> to the
<classname>MKConductor</classname> class.  A paused performance is
resumed through the <emphasis role="bold">resumePerformance</emphasis>
method.  Individual <classname>MKConductor</classname> objects can be
paused and resumed through the <emphasis role="bold">pause</emphasis>
and <emphasis role="bold">resume</emphasis> methods.</para>

      </sect3>
      <sect3 id="SettingTheTempo">
	<title>Setting the Tempo</title>

<para>The <classname>MKConductor</classname> supports two alternative
protocols for tempo-management.  The simpler of the two is called the
"Tempo Protocol".  For more complex applications, the "Time Map
Protocol" is provided.  The <classname>MKConductor</classname> decides
which protocol to use based on what the delegate implements.  If the
delegate implements <emphasis role="bold">beatToClock:from:</emphasis>
and <emphasis role="bold">clockToBeat:from:</emphasis> then the Time
Map Protocol is used.  Otherwise, the Tempo Protocol is used.</para>

      </sect3>
      <sect3 id="TempoProtocol"> 
	<title>Tempo Protocol</title>

	<para>With this protocol, a <classname>MKConductor</classname>'s tempo
controls the rate with which it processes the requests in its message
request queue.  Two methods are provided for setting a
<classname>MKConductor</classname> object's tempo:</para>

	<itemizedlist>
	  <listitem><para><emphasis role="bold">setTempo:</emphasis>, which
takes a <emphasis role="bold">double</emphasis> argument, sets the
tempo in beats-per-minute.</para>
	  </listitem>

	  <listitem><para> <emphasis role="bold">setBeatSize:</emphasis> also
takes a <emphasis role="bold">double</emphasis>, but it sets the tempo
by defining the duration, in seconds, of a single beat.</para>
	  </listitem>
	</itemizedlist>

	<para>Regardless of which method you use to set the tempo, the values
returned by the retrieval methods <emphasis
role="bold">tempo</emphasis> and <emphasis
role="bold">beatSize</emphasis> are computed appropriately, as shown
in the following example:</para>

<programlisting>
double bSize;

/* Sets the defaultConductor's tempo. */
[[MKConductor defaultConductor] setTempo: 240.0];

/* Return the beat size; bSize will be 60.0/240.0, or 0.25. */
bSize = [[MKConductor defaultConductor] beatSize];
</programlisting>

<para>You can change a <classname>MKConductor</classname>'s tempo at
any time, even during a performance.  If your application requires
multiple simultaneous tempi, you need to create more than one
<classname>MKConductor</classname>, one for each tempo.  A
<classname>MKConductor</classname>'s tempo is initialized to 60.0
beats per minute.</para>

      </sect3>
      <sect3 id="TimeMapProtocol">
	<title>Time Map Protocol</title>

<para>While the Tempo Protocol is fine for simply adding a tempo
slider to a performance, you are better off using the Time Map
Protocol if you want to apply a tempo track (a planned series of tempo
changes) or if you are applying varying tempo changes in the context
of a performance that is synchronized to <acronym>MIDI</acronym> time code.</para>

<para>A Time Map is a mapping from "beat time" (time as read by a
human conductor reading a score) to "clock time" (the resulting time
as performed by the conductor, after he has made any tempo
modifications.)  A few examples will help clarify this:</para>

<programlisting>
f(t) = t                 /* steady tempo of 60 bpm. */
f(t) = 2 * t             /* steady tempo of 30 bpm. */
f(t) = 0.5 * t           /* steady tempo of 120 bpm. */
f(t) = t ^ 2             /* tempo that continually slows down. */
f(t) = t ^ 0.5           /* tempo that continually speeds up. */
f(t) = t + sin(t) * .01  /* tempo that cyclically speeds up and slows down. */
</programlisting>

<para>For more information on Time Maps see the following
reference:</para>

<para><emphasis>Ensemble Timing in Computer Music</emphasis>.  David
A. Jaffe.</para>

<para>1985.  Computer Music Journal, MIT Press, 9(4):38-48.</para>

<para>To implement the Time Map Protocol (an informal protocol), the
delegate must implement two methods:</para>

	<itemizedlist>
	  <listitem><para>
<emphasis role="bold">beatToClock:from:</emphasis>
takes two arguments.  The first is a <emphasis
role="bold">double</emphasis> that represents the current beat number.
The second argument is the <classname>MKConductor</classname> that
sends the message.  This delegate's implementation should return the
corresponding "clock time", the time after the tempo adjustments have
been made.  In other words, this method implements the time
map.</para>
	  </listitem>

	  <listitem><para> <emphasis role="bold">clockToBeat:from:</emphasis> is
the opposite of <emphasis role="bold">beatToClock:from:</emphasis>.
It maps a "clock time" value to a beat number.  In other words, this
method implements the inverse time map.</para>
	  </listitem>
	</itemizedlist>

<para>There are a number of restrictions these methods must
follow:</para>

	<orderedlist>
	  <listitem><para>It is essential that these two methods are complementary.  In
particular, the following must be true:</para>

<programlisting>
t == [delegate beatToClock: [delegate clockToBeat: t from:aCond] from: aCond]
</programlisting>
	  </listitem>

	  <listitem><para>Neither method should cause time to go backwards.  That is,
if t1 is less than t2, then [delegate beatToClock:t1 from:aCond] must
be less than [delegate beatToClock:t2 from:aCond].  The same applies
to <emphasis role="bold">clockToBeat:</emphasis>.  In other words,
both functions must be monotonically increasing.</para>
	  </listitem>

	  <listitem><para>These methods must not change over the course of a
performance.  For example, if the message [delegate beatToClock: 3. 1
from:aCond] returns 2.8, it must always return 2.8, whether invoked at
the start, middle or end of the performance.</para>
	  </listitem>
	</orderedlist>

<para>Note that while the Time Map Protocol makes tempo maps possible,
it is up to the application to apply such a map.  For example, when a
Standard <acronym>MIDI</acronym> file is read into a
<classname>MKScore</classname> object, the first part gets the tempo
map.  The <productname>MusicKit</productname> does not apply this map
by default&horbar;this responsibility belongs to the
application.</para>

<tip>
<para>
See for example <emphasis role="bold">setMidifilesEvaluateTempo:</emphasis>
of <classname>MKScore</classname>.
</para>
</tip>

      </sect3>
      <sect3 id="LockingThePerformance">
	<title>Locking the Performance</title>

<para>Every <classname>MKConductor</classname> instance has a notion
of the current time, measured in beats.  This notion is updated by the
<classname>MKConductor</classname> class only when a message from one
of the request queues is sent; <emphasis>all</emphasis>
<classname>MKConductor</classname>s are updated when
<emphasis>any</emphasis> <classname>MKConductor</classname> sends such
a message.  If your application sends a message (or calls a C
function) that depends on a <classname>MKConductor</classname>'s
notion of time being current, you must first send <emphasis
role="bold">lockPerformance</emphasis> to the
<classname>MKConductor</classname> class.  Every invocation of
<emphasis role="bold">lockPerformance</emphasis> should be balanced by
an invocation of <emphasis role="bold">unlockPerformance</emphasis>.
For example, if you send <emphasis role="bold">receiveNote:</emphasis>
to an <classname>MKInstrument</classname>'s
<classname>MKNoteReceiver</classname>, you must bracket the message
with <emphasis role="bold">lockPerformance</emphasis> and <emphasis
role="bold">unlockPerformance</emphasis>.  (However, invocations of
<emphasis role="bold">receiveNote:</emphasis> that are<emphasis
role="bold"></emphasis> requested through a
<classname>MKConductor</classname>'s messge request queue shouldn't be
bracketed by these methods.)</para>

      </sect3>
      <sect3 id="MKConductorsAndMKNotes">
	<title><classname>MKConductor</classname>s and <classname>MKNote</classname>s</title>

	<para>Every <classname>MKNote</classname> is associated with a
<classname>MKConductor</classname> object.  A
<classname>MKNote</classname>'s <classname>MKConductor</classname> is
determined as follows: If the <classname>MKNote</classname> is being
sent by a <classname>MKPerformer</classname> during a performance, its
<classname>MKConductor</classname> is that of the
<classname>MKPerformer</classname>.  If not, the
<classname>MKConductor</classname> is the one set with
<classname>MKNote</classname>'s <emphasis
role="bold">setConductor</emphasis> method.  If no
<classname>MKConductor</classname> was set, the
<emphasis>defaultConductor</emphasis> is used.</para>

<para>The association between a <classname>MKNote</classname> and a
<classname>MKConductor</classname> is of particular importance if the
<classname>MKNote</classname> is a noteDur that's sent to a
<classname>MKSynthInstrument</classname> or
<classname>MKMidi</classname> object.  Both of these
<classname>MKInstrument</classname>s split a noteDur into a
noteOn/noteOff pair.  The noteOn is realized immediately and the
noteOff is scheduled for realization at a later time, as indicated by
the original <classname>MKNote</classname>'s duration value.  To do
this, a request for the noteOff to be sent in a <emphasis
role="bold">receiveNote:</emphasis> message is enqueued with the
<classname>MKNote</classname>'s <classname>MKConductor</classname>.
The exact time at which the <classname>MKNote</classname> arrives
depends, therefore, on this <classname>MKConductor</classname>'s
tempo.</para>

<para>A <classname>MKNote</classname>'s
<classname>MKConductor</classname> is also important if you send the
<classname>MKNote</classname> to an
<classname>MKInstrument</classname> through
<classname>MKNoteReceiver</classname>'s <emphasis
role="bold">receiveNote:atTime:</emphasis> or <emphasis
role="bold">receiveNote:withDelay:</emphasis> methods.  These methods
cause the <classname>MKNoteReceiver</classname> to enqueue a <emphasis
role="bold">receiveNote:</emphasis> request with the
<classname>MKNote</classname>'s <classname>MKConductor</classname> at
the specified time: The former method takes the <emphasis
role="bold">atTime:</emphasis> argument as an absolute measure from
the beginning of the performance, while the latter measures the
<emphasis role="bold">withDelay:</emphasis> argument as some number of
beats from the time that it's invoked.</para>

      </sect3>
      <sect3 id="MKConductorsAndMKEnvelopes">
	<title><classname>MKConductor</classname>s and <classname>MKEnvelope</classname>s</title>

<para>The relationship between an <classname>MKEnvelope</classname>
and a <classname>MKConductor</classname> is as important as it is
unique: The dispatching of an <classname>MKEnvelope</classname>'s
breakpoints during <acronym>DSP</acronym> synthesis is always done through message
requests with the <emphasis>clockConductor</emphasis>.  You don't have to do anything to
obtain this behavior, it happens automatically through <function>MKUpdateAsymp()</function>, the function that you use in
the design of a <classname>MKSynthPatch</classname> subclass to apply
an <classname>MKEnvelope</classname> to a synthesis patch.</para>

<para>This association is particularly important not for the
particular <classname>MKConductor</classname> with which the
breakpoints are scheduled, but that they are scheduled at all.  Since
the <emphasis>clockConductor</emphasis> handles breakpoint dispatching, this means that its
queue may be filled with breakpoint messages without you knowing it.
As a result, if you set the performance to finish when the queues are
empty, the performance won't finish until all the breakpoint messages
are sent from the <emphasis>clockConductor</emphasis>'s queue.  This is generally desirable
behavior.  Where things can become confusing is if you pause an entire
performance (through <classname>MKConductor</classname>'s <emphasis
role="bold">pausePerformance</emphasis> class method) while
<classname>MKEnvelope</classname>s are being handled.  Not only will all
<classname>MKNote</classname> handling stop, all <classname>MKEnvelope</classname>s will
freeze as well.  This usually isn't pleasant.</para>

<para>One way to avoid the problem is to pause all your
<classname>MKConductor</classname> objects, through the <emphasis
role="bold">pause</emphasis> method, rather than pause the entire
performance.</para>

      </sect3>
      <sect3 id="SynchronizingToMIDITimeCode">
	<title>Synchronizing a Performance to <acronym>MIDI</acronym> Time Code</title>

<para>A <classname>MKConductor</classname> object can be made to
synchronize to <acronym>MIDI</acronym> time code.  For further
information, see the <classname>MKMidi</classname> and
<classname>MKConductor</classname> class descriptions, as well as
<xref linkend="MIDITimeCode">.</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="MKPerformerClass">
    <title>The <classname>MKPerformer</classname> Class</title>

<para>A <classname>MKPerformer</classname> object does two
things:</para>

<itemizedlist>
<listitem><para> It generates or otherwise obtains a series of
<classname>MKNote</classname> objects during a performance.</para>
</listitem>

<listitem><para> It acts as a cover for
<classname>MKConductor</classname>'s scheduling mechanism by
sequentially and repeatedly requesting invocations of its own
<emphasis role="bold">perform</emphasis> method.</para>
</listitem>
</itemizedlist>

<para>The <classname>MKPerformer</classname> class itself is abstract;
you create a subclass of <classname>MKPerformer</classname> to
correspond to a unique sources of <classname>MKNote</classname>s.  The
<productname>MusicKit</productname> includes subclasses that read <classname>MKNote</classname>s
from a <classname>MKPart</classname>
(<classname>MKPartPerformer</classname>) or a scorefile
(<classname>MKScorefilePerformer</classname>)&horbar;the latter
actually inherits from the MKFilePerformer class, a subclass of
<classname>MKPerformer</classname> that defines methods for managing
files.  The <productname>MusicKit</productname> also includes
pseudo-<classname>MKPerformer</classname>s that fashion
<classname>MKNote</classname>s from <acronym>MIDI</acronym> input
(<classname>MKMidi</classname>), and that read
<classname>MKNote</classname>s from a <classname>MKScore</classname>
(<classname>MKScorePerformer</classname>, which creates a
<classname>MKPartPerformer</classname> for each
<classname>MKPart</classname> in the <classname>MKScore</classname>).
Consult 
<ulink url="&MKClassReferences;">
<productname>MusicKit</productname> Class References</ulink> for
further descriptions of these classes.</para>

<para>Using a <classname>MKPerformer</classname> object is quite
simple; creating your own subclass is a bit more complicated and
requires a firm understanding of how a
<classname>MKPerformer</classname> goes about its business.  These two
topics are presented below.</para>

    <sect2 id="UsingAMKPerformer">
      <title>Using a <classname>MKPerformer</classname></title>

<para>To use a <classname>MKPerformer</classname>, you need to do two
things: connect it to an <classname>MKInstrument</classname> and tell
it to go.  Every <classname>MKPerformer</classname> contains some
number of <classname>MKNoteSender</classname>s, auxiliary objects that
are created by the <classname>MKPerformer</classname> to act as
<classname>MKNote</classname> &ldquo;spigots.&rdquo;
<classname>MKNoteSender</classname>s are analogous to an
<classname>MKInstrument</classname>'s
<classname>MKNoteReceiver</classname>s.</para>

<para>To connect a <classname>MKPerformer</classname> to an
<classname>MKInstrument</classname>, you retrieve a
<classname>MKNoteSender</classname> and
<classname>MKNoteReceiver</classname> from either, respectively, and
connect these objects through the <emphasis
role="bold">connect:</emphasis> method, as defined by both
<classname>MKNoteSender</classname> and
<classname>MKNoteReceiver</classname>.  For example, to connect a
<classname>MKPartPerformer</classname> to a
<classname>MKSynthInstrument</classname>, you would do the
following:</para>

<programlisting>
/* aPartPerformer and aSynthIns are assumed to exist. */ 
[[a<classname>MKPartPerformer</classname> noteSender] connect:[aSynthIns noteReceiver]];
</programlisting>

<para>Since both classes define the <emphasis
role="bold">connect:</emphasis> method, the following is
equivalent:</para>

<programlisting>
/* aPartPerformer and aSynthIns are assumed to exist. */
[[aSynthIns noteReceiver] connect: [aPartPerformer noteSender]];
</programlisting>

<para>The <emphasis role="bold">noteSender</emphasis> method returns
one of a <classname>MKPerformer</classname>'s
<classname>MKNoteSender</classname>s, just as the <emphasis
role="bold">noteReceiver</emphasis> method retrieves one of an
<classname>MKInstrument</classname>'s
<classname>MKNoteReceiver</classname>s.  If you're using a <productname>MusicKit</productname>
<classname>MKPerformer</classname> subclass, you should refer to its
description to determine if it creates more than one
<classname>MKNoteSender</classname>.  If it creates only one, then the
<emphasis role="bold">noteSender</emphasis> method is sufficient.  If
it creates more than one, you can retrieve the entire set as a
<classname>NSArray</classname> through the <emphasis
role="bold">noteSenders</emphasis> method and then choose the
<classname>MKNoteSender</classname> that you want by plucking it from
the <classname>NSArray</classname>.  A
<classname>MKScorefilePerformer</classname>, for example, creates a
<classname>MKNoteSender</classname> for each
<classname>MKPart</classname> that's represented in its
scorefile.</para>

      <sect3 id="ActivatingAMKPerformer">
	<title>Activating a <classname>MKPerformer</classname></title>

<para>To make a <classname>MKPerformer</classname> run, you send it
the <emphasis role="bold">activate</emphasis> message.  This prepares
the object for a performance but it doesn't actually start performing
<classname>MKNote</classname>s until you send <emphasis
role="bold">startPerformance</emphasis> to the
<classname>MKConductor</classname> class.  If you invoke <emphasis
role="bold">activate</emphasis> while a performance is in progress (in
other words, <emphasis>after</emphasis> you send <emphasis
role="bold">startPerformance</emphasis>), the
<classname>MKPerformer</classname> will immediately start running.  In
addition, the <classname>MKPerformer</classname> may require
subclass-specific preparation; for example, you have to set a
<classname>MKPartPerformer</classname>'s <classname>MKPart</classname>
before you send it the <emphasis role="bold">activate</emphasis>
message.</para>

<para>While a <classname>MKPerformer</classname> is running, you can
pause and resume its activity through the <emphasis
role="bold">pause</emphasis>, <emphasis
role="bold">pauseFor:</emphasis>, and <emphasis
role="bold">resume</emphasis> methods.  To completely stop a
<classname>MKPerformer</classname> you invoke <emphasis
role="bold">deactivate</emphasis>.  In addition, all
<classname>MKPerformer</classname>s are automatically deactivated when
the <classname>MKConductor</classname> class receives the <emphasis
role="bold">finishPerformance</emphasis> message.  A
<classname>MKPerformer</classname> can be given a delegate object that
can be designed to respond to the messages <emphasis
role="bold">performerDidActivate:</emphasis>, <emphasis
role="bold">performerDidPause:</emphasis>, <emphasis
role="bold">performerDidResume:</emphasis>, and <emphasis
role="bold">performerDidDeactivate:</emphasis>.  These messages are
sent by the <classname>MKPerformer</classname> at the obvious
junctures in its performance.</para>
      </sect3>

      <sect3 id="MKPerformersAndMKConductors">
	<title><classname>MKPerformer</classname>s and
	<classname>MKConductor</classname>s</title>

<para>Every <classname>MKPerformer</classname> object is associated
with a <classname>MKConductor</classname>.  If you don't set a
<classname>MKPerformer</classname>'s
<classname>MKConductor</classname> explicitly (through <emphasis
role="bold">setConductor:</emphasis>), it will be associated with the
<emphasis>defaultConductor</emphasis>.  The rate at which a
<classname>MKPerformer</classname> performs its
<classname>MKNote</classname>s is controlled by its
<classname>MKConductor</classname>'s tempo.  In general, all the
<classname>MKPerformer</classname>s you create can be associated with
the same <classname>MKConductor</classname>.  The only case in which a
<classname>MKPerformer</classname> demands its own
<classname>MKConductor</classname> is if you want the
<classname>MKPerformer</classname> to proceed at a different tempo
from its fellow <classname>MKPerformer</classname>s.</para>
      </sect3>
    </sect2>
    <sect2 id="CreatingAMKPerformerSubclass">
      <title>Creating a <classname>MKPerformer</classname>
      Subclass</title>

<para>The design of a <classname>MKPerformer</classname> subclass must
address three tasks: acquiring a <classname>MKNote</classname>,
sending it into a performance, and scheduling the next
<classname>MKNote</classname>.</para>

      <sect3 id="AcquiringMKNotes">
	<title>Acquiring <classname>MKNote</classname>s</title>

<para>Each subclass of <classname>MKPerformer</classname> defines a
unique system for acquiring <classname>MKNote</classname>s.  You can
design your own <classname>MKPerformer</classname>s that, for example,
read <classname>MKNote</classname>s from a specialized database or
create <classname>MKNote</classname>s algorithmically.  Regardless of
how a <classname>MKPerformer</classname> acquires its
<classname>MKNote</classname>s, it does so as part of the
implementation of its <emphasis role="bold">perform</emphasis>
method.</para>

<para>The <emphasis role="bold">perform</emphasis> method can be
designed to acquire any number of <classname>MKNote</classname>s with
a single invocation.
</para>
      </sect3>
      <sect3 id="SendingMKNotes">
	<title>Sending <classname>MKNote</classname>s</title>

<para>To send a <classname>MKNote</classname> into a performance, a
<classname>MKPerformer</classname> relies on its
<classname>MKNoteSender</classname> objects.  A
<classname>MKPerformer</classname> creates and adds some number of
<classname>MKNoteSender</classname>s to itself, usually as part of its
<emphasis role="bold">init</emphasis> method.
<classname>MKNoteSender</classname>s are created through the usual
sequence of <emphasis role="bold">alloc</emphasis> and <emphasis
role="bold">init</emphasis> messages; they're added to a
<classname>MKPerformer</classname> through
<classname>MKPerformer</classname>'s <emphasis
role="bold">addNoteSender:</emphasis> method.  A
<classname>MKPerformer</classname> can add any number of
<classname>MKNoteSender</classname>s to itself, although it's
anticipated that most <classname>MKPerformer</classname>s will need
only one.</para>

<para>As part of its implementation of the<emphasis role="bold">
perform</emphasis> method, a <classname>MKPerformer</classname> passes
the <classname>MKNote</classname> it has acquired as the argument in a
<emphasis role="bold">sendNote:</emphasis> message, which it sends to
its <classname>MKNoteSender</classname>s.  Each
<classname>MKNoteSender</classname> then relays the
<classname>MKNote</classname> to the
<classname>MKNoteReceiver</classname>s to which it's connected; each
<classname>MKNoteReceiver</classname> passes the
<classname>MKNote</classname> to the
<classname>MKInstrument</classname> that it (the
<classname>MKNoteReceiver</classname>) belongs to.  Thus, by sending
<emphasis role="bold">sendNote:</emphasis> to a
<classname>MKNoteSender</classname>, a
<classname>MKPerformer</classname> communicates
<classname>MKNote</classname>s to one or more
<classname>MKInstrument</classname>s.  If more than one
<classname>MKNote</classname> is acquired in the <emphasis
role="bold">perform</emphasis> method, each is sent in a separate
<emphasis role="bold">sendNote:</emphasis> message.</para>

<para><emphasis role="bold"><classname>MKNote</classname>:</emphasis>
Methods that are invoked from within the <emphasis
role="bold">perform</emphasis> method&horbar;and this includes the
<emphasis role="bold">sendNote:</emphasis>
method&horbar;<emphasis>shouldn't</emphasis> be bracketed by <emphasis
role="bold">lockPerformance</emphasis> and <emphasis
role="bold">unlockPerformance</emphasis>.</para>
      </sect3>
      <sect3 id="SchedulingMKNotes">
	<title>Scheduling <classname>MKNote</classname>s</title>

<para>As described above, every time a
<classname>MKPerformer</classname> receives the <emphasis
role="bold">perform</emphasis> message it acquires a
<classname>MKNote</classname> and then sends it to its
<classname>MKNoteSender</classname>s.  The final obligation of the
<emphasis role="bold">perform</emphasis> method is to schedule its own
next invocation.  This is done by setting the value of the <emphasis
role="bold">nextPerform</emphasis> instance variable.  The value of
<emphasis role="bold">nextPerform</emphasis> is measured in beats
according to the tempo of the <classname>MKConductor</classname> and,
most important, it's taken as a time delay: If you set <emphasis
role="bold">nextPerform</emphasis> to 3.0, for example, the <emphasis
role="bold">perform</emphasis> method will be invoked after 3.0
beats.</para>

<para>To get things started, a <classname>MKPerformer</classname>'s
first <emphasis role="bold">perform</emphasis> message is
automatically scheduled to be sent just after the
<classname>MKPerformer</classname> is activated.  You can delay this
initial invocation by setting the <emphasis
role="bold">nextPerform</emphasis> variable from within the
<emphasis role="bold">activateSelf</emphasis> method.  The default
implementation of <emphasis role="bold">activateSelf</emphasis> does
nothing; a subclass can implement it to provide pre-performance
initialization just such as this.</para>

<para>An important implication of this scheduling mechanism is that a
<classname>MKPerformer</classname> must be able to determine when it
wants to perform its next <classname>MKNote</classname> at the time
that it acquires and performs its current
<classname>MKNote</classname>.</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="FineTuningAPerformanceApplication">
    <title>Fine-Tuning a Performance Application</title>

    <sect2 id="Responsiveness">
      <title>Responsiveness</title>

<para>The responsiveness of a performance to the user's actions
depends on whether the <classname>MKConductor</classname> class is
clocked or unclocked, and upon the value of the performance's
<emphasis>delta time</emphasis>.  By default, the
<classname>MKConductor</classname> class is clocked.  This means that
the messages in the message request queues are sent at the times
indicated by their timestamps.  When the
<classname>MKConductor</classname> class is clocked, a running
<classname>NSApplication</classname> object must be present (unless
the performance is being run in a separate thread, as described
below).</para>

<para>If you don't need interactive control over a performance, you
may find it beneficial to set it to unclocked by sending <emphasis
role="bold">setClocked:NO</emphasis> to the
<classname>MKConductor</classname> class.  In an unclocked
performance, messages in the message request queues are sent one after
another as quickly as possible, leaving it to some other
device&horbar;the <acronym>DSP</acronym> or the <acronym>MIDI</acronym> device driver&horbar;to handle the
timing of the actual realization.</para>

<para>Setting the delta time further refines the responsiveness of a
performance.  Delta time is set through the <function>MKSetDeltaT()</function> C function; the argument defines
an imposed time lag, in seconds, between the
<classname>MKConductor</classname>'s notion of time and that of the
<acronym>DSP</acronym> and <acronym>MIDI</acronym> device drivers.  It acts as a timing cushion that can
help to maintain rhythmic integrity by granting your application a
sort of computational head start: As you set the delta time to larger
values, your application has more time to process
<classname>MKNote</classname>s before they are realized.  However,
this computational advantage is obtained at the expense of degraded
responsiveness.  Choosing the proper delta time value depends on how
responsive your application needs to be.  For example, if you are
driving <acronym>DSP</acronym> synthesis from <acronym>MIDI</acronym> input, a delta time of as much as 10
milliseconds (0.01 seconds) is generally acceptable.  If you are
adjusting <classname>MKNote</classname> parameters by moving a
<classname>NSSlider</classname> with the mouse, a delta time of 100
milliseconds or more can be tolerated.  Finding the right delta time
for your application is largely a matter of experimentation.</para>

<para>For further information, see
<xref linkend="MIDIDSPMKConductorWallClock"> below.</para>

    </sect2>
    <sect2 id="SeparateThreadedPerformance">
      <title>Separate-Threaded Performance</title>

<para>To enhance the efficiency of a performance, you can run it in
its own thread.  This is done by sending <emphasis
role="bold">useSeparateThread:<constant>YES</constant></emphasis> to the
<classname>MKConductor</classname> class.  Running a performance in
its own thread separates it from the main event loop, thus allowing
music to play with greater independence from your application's other
computations.  However, certain restrictions must be adhered to when
running a performance in its own thread:</para>

      <itemizedlist>
	<listitem><para>You can't use <classname>MKScorefileWriter</classname> or
<classname>MKScorefilePerformer</classname> objects in the performance.</para>
	</listitem>

	<listitem><para>You can't invoke an
<classname>MKOrchestra</classname> method that changes the
<classname>MKOrchestra</classname>'s status; these are <emphasis
role="bold">open</emphasis>, <emphasis role="bold">run</emphasis>,
<emphasis role="bold">stop</emphasis>, <emphasis
role="bold">close</emphasis>, and <emphasis
role="bold">abort</emphasis>.</para>
	</listitem>

	<listitem><para>You can't send messages to instances of
classes defined by the <productname>Application Kit</productname>, or
to instances of the <productname>SndKit</productname>'s
<classname>SndView</classname> and <classname>SndMeter</classname>
classes.  In addition, you can't read or write soundfiles, or play or
record sounds through an instance of the
<productname>SndKit</productname>'s <classname>Snd</classname> class
(note, however, that you <emphasis>can</emphasis> use the sound
library functions).</para>
	</listitem>

	<listitem><para>You can't call DPS client functions.</para></listitem>

	<listitem><para>You can't call NXStreams functions.</para></listitem>

	<listitem><para>You can't call C functions that rely on
standard input and output; these are functions such as
<function>printf()</function> and <function>scanf()</function>.
Because of this, <acronym>DSP</acronym> error logging and
<productname>MusicKit</productname> tracing can't be used.  In
addition, if you need to handle <productname>MusicKit</productname>
errors, you must provide your own error handler function through
<function>MKSetErrorProc()</function>.</para>
	</listitem>
      </itemizedlist>

<para>These restrictions apply only to that part of your application
that's running in the performance thread; specifically, messages sent
by a <classname>MKConductor</classname> through its message request
queue, and method invocations and C function class that are part of
the design of a <classname>MKPerformer</classname> or
<classname>MKInstrument</classname> (or
pseudo-<classname>MKPerformer</classname>s such as
<classname>MKMidi</classname>) must follow these restrictions.  For
example, you can't use an <classname>MKInstrument</classname> that
sends messages to an <productname>Application Kit</productname>
<classname>NSWindow</classname> object; however, you can send messages
to the <classname>NSWindow</classname> from your application's main
thread.</para>

<para>The performance thread can cause a restricted method to be
invoked or a restricted function to be called by sending a
<productname>Mach</productname> message to a message port.  To do
this, you must first register the port through
<function>DPSAddPort()</function> in the main thread.  This is
demonstrated in the <application>Ensemble</application> programming
example (<filename
class="directory">/Local/Developer/Examples/MusicKit/Ensemble</filename>).</para>

<para>An important restriction in a multi-threaded performance is that
<emphasis>all</emphasis> messages (or groups of messages) to
<productname>MusicKit</productname> objects sent from the main thread
should be bracketed with <emphasis
role="bold">lockPerformance</emphasis> and <emphasis
role="bold">unlockPerformance</emphasis>.</para>

    </sect2>
    <sect2 id="PerformancePriority">
      <title>Performance Priority</title>

<para>Give your real time application an advantage through the
<emphasis role="bold">setTheadPriority:</emphasis>
<classname>MKConductor</classname> class method.  This method sets the
Mach-scheduling priority of the performance thread, whether or not
it's separate.  Performance priority values are between 0.0 and 1.0,
where 0.0 is unheightened (the default) and 1.0 is the maximum
priority for a user process.  Normally, Mach priorities degrade over
time; by using <emphasis role="bold">setThreadPriority:</emphasis> and
setting it to a value larger than 0, fixed scheduling policy is
enabled.  In this mode, your priority will not degrade.</para>
    </sect2>
    <sect2 id="PerformingWithTheDSP"> 
    <title>Performing with the <acronym>DSP</acronym></title>

<para>You can also shape your performance's capabilities by affecting
the <classname>MKOrchestra</classname> class, thus influencing the
manner in which <acronym>DSP</acronym> resources are used.</para>

      <sect3 id="SamplingRate">
	<title>Sampling Rate</title>

<para>The <acronym>DSP</acronym> can output stereo samples at two rates, 22050 samples
per second, or 44100 samples per second.  By default, it runs at the
low sampling rate.  You can improve a performance's response time with
regard to <acronym>DSP</acronym> synthesis by using the high sampling rate, as
accomplished by sending the message</para>

<programlisting>
[MKOrchestra setSamplingRate:44100.0];
</programlisting>

<para>However, by asking the <acronym>DSP</acronym> to run at a higher sampling rate, you
rob it of some of its power.  In general, the <acronym>DSP</acronym> can be considered to
be twice as &ldquo;big&rdquo; at the low sampling rate as at the high.
In other words, if the <acronym>DSP</acronym> is able to synthesize twelve simultaneous
voices at the low sampling rate using a particular <classname>MKSynthPatch</classname>, it
may only be able to synthesize six such voices at the high sampling
rate.</para>
      </sect3>
      <sect3 id="SoundBufferSizes">
	<title>Sound Buffer Sizes</title>

<para>While the speed of the <acronym>DSP</acronym> makes real-time synthesis
approachable, there's always an imposed time delay that's equal to the
size of the buffer used to collect computed samples before they're
shovelled to the DAC.  To accommodate applications that require the
best possible response time (the time between the initiation of a
sound and its actual broadcast from the DAC), a smaller sample output
buffer can be requested by sending the <emphasis
role="bold">setFastResponse:<constant>YES</constant></emphasis> message to an <classname>MKOrchestra</classname>.
However, the more frequent attention demanded by the smaller buffer
will detract from the <acronym>DSP</acronym>'s synthesis computation and, again, fewer
simultaneous voices may result.</para>
      </sect3>
      <sect3 id="Headroom">
	<title>Headroom</title>

<para>The <classname>MKOrchestra</classname> doesn't know, at the
beginning of a <classname>MKNote</classname>, if the <acronym>DSP</acronym> can execute a
given set of <classname>MKUnitGenerator</classname>s quickly enough
to produce a steady supply of output samples for the entire duration
of the <classname>MKNote</classname>.  However, it makes an educated
estimate and will deny allocation requests that it thinks will
overload the <acronym>DSP</acronym> and cause it to fall out of real time.  Such a denial
may result in a smaller number of simultaneously synthesized
voices.</para>

<para>You can adjust the <classname>MKOrchestra</classname>'s <acronym>DSP</acronym>
processing estimate, or <emphasis>headroom</emphasis>, by invoking the
<emphasis role="bold">setHeadroom:</emphasis>
<classname>MKOrchestra</classname> method.  This takes an argument
between -1.0 and 1.0; a negative headroom allows a more liberal
estimate of the <acronym>DSP</acronym> resources&horbar;resulting in more simultaneous
voices&horbar;but it runs the risk of causing the <acronym>DSP</acronym> to fall out of
real time.  Conversely, a positive headroom is more conservative: You
have a greater assurance that the <acronym>DSP</acronym> won't fall out of real time but
the number of simultaneous voices is decreased.  The default is a
somewhat conservative 0.1.</para>
      </sect3>
    </sect2>
    <sect2 id="MIDIDSPMKConductorWallClock">
      <title>The Relationships between <acronym>MIDI</acronym>, the <acronym>DSP</acronym>, the
      <classname>MKConductor</classname> and the Clock on the
      Wall</title>

<para>The <productname>MusicKit</productname> needs to satisfy two
conflicting requirements, timely execution of scheduled events and
steady performance.  The <productname>MusicKit</productname> variable
<emphasis>deltaT</emphasis> adjusts the trade-off between
responsiveness and dependability.  <emphasis>deltaT</emphasis>
provides the <productname>MusicKit</productname> with a "cushion" of
time to absorb any bursts of computation that would otherwise result
in unsteady performance.  Setting <emphasis>deltaT</emphasis> to 0.0
gives the most responsive performance, but one that is likely to be
unsteady in musically dense textures.  Setting
<emphasis>deltaT</emphasis> to a larger values gives a more dependable
performance at the expense of a greater latency.  The function
<function>MKGetDeltaT()</function> returns
<emphasis>deltaT</emphasis>.  You can set the value of
<emphasis>deltaT</emphasis> with the function
<function>MKSetDeltaT()</function>. For convenience, these have
<classname>MKConductor</classname> class method equivalents,
<emphasis>+deltaT</emphasis> and <emphasis>+setDeltaT</emphasis>,
respectively.</para>

<para>The manner in which <emphasis>deltaT</emphasis> is interpreted
depends on the <emphasis>deltaT mode</emphasis>.
<productname>MusicKit</productname> supplies two modes,
<emphasis>device lag mode</emphasis> and <emphasis>scheduler advance
mode</emphasis>. In <emphasis>device lag mode</emphasis>, the
<productname>MusicKit</productname> <emphasis>clockConductor</emphasis> stays in synch, as
much as possible, with &ldquo;wall time&rdquo;, the actual time since
the performance began, while devices such as <acronym>MIDI</acronym>
and the <acronym>DSP</acronym> lag behind by
<emphasis>deltaT</emphasis>.  In contrast, in <emphasis>scheduler
advance mode</emphasis>, the devices stay in synch with wall time,
while the <emphasis>clockConductor</emphasis> runs in advance of wall time by
<emphasis>deltaT</emphasis>.  You set the <emphasis>deltaT</emphasis>
mode with the C function: <function>MKSetDeltaTMode()</function>,
passing it an argument of either
<constant>MK_DELTAT_SCHEDULER_ADVANCE</constant> or
<constant>MK_DELTAT_DEVICE_LAG</constant>.  Both of these modes work
whether or not any <classname>MKConductor</classname>s are
synchronizing to MTC.</para>

<para>Keep in mind that in order for a non-zero
<emphasis>deltaT</emphasis> to have the desired effect, you must set
the <classname>MKMidi</classname> and
<classname>MKOrchestra</classname> objects to timed mode.  See the
<ulink url="&MKClassReferences;">Class References</ulink> of these
objects for details.</para>

      <sect3 id="DeviceLagMode">
	<title>Device Lag Mode</title>

<para>The default mode is <emphasis>device lag mode</emphasis> (for
historical reasons.)  The value returned by <function>MKGetDeltaT()</function> is added to time stamps sent to
the <acronym>MIDI</acronym> driver and <acronym>DSP</acronym>, providing the
<productname>MusicKit</productname> with its "cushion".  The function
<function>MKGetDeltaTTime()</function> does this addition.  The
<classname>MKConductor</classname> runs steadily from the time it is
started, while the output of the devices, such as <acronym>MIDI</acronym> and the <acronym>DSP</acronym>,
seems to wait <emphasis>deltaT</emphasis> seconds and then runs
steadily.  The amount of time it waits is
<emphasis>deltaT</emphasis>.</para>

<para>In addition, the <classname>MKOrchestra</classname> and
<classname>MKMidi</classname> provide a &ldquo;local deltaT&rdquo;
which is added in on top of the ordinary
<emphasis>deltaT</emphasis>. This allows you to compensate for any
difference of delay between these devices.</para>

<para><emphasis>Device lag mode</emphasis> works well for many cases.
But there are other cases, and <acronym>MIDI</acronym> Time Code synchronization is one
of them, when we want the <emphasis>devices'</emphasis> notion of time
to be that of wall time, while still keeping a cushion to absorb
bursts of computation.  This is the functionality provided by
<emphasis>scheduler advance mode</emphasis>.</para>
      </sect3>
      <sect3 id="SchedulerAdvanceMode">
	<title>Scheduler Advance Mode</title>

<para>Here, we let the <emphasis>clockConductor</emphasis>'s notion of
time run <emphasis>ahead</emphasis> of wall time by
<emphasis>deltaT</emphasis>. That is, the
<emphasis>clockConductor</emphasis> races ahead when started, then
maintains time such that the wall time since the performance began is
the <emphasis>clockConductor</emphasis>'s time minus
<emphasis>deltaT</emphasis>.  The time it reports (returned by
<function>MKGetTime()</function> and <emphasis role="bold">
[[<classname>MKConductor</classname>
<emphasis>clockConductor</emphasis>] time]</emphasis>) includes this
<emphasis>deltaT</emphasis>.</para>

<para>For example, assume <emphasis>deltaT</emphasis> is 1.0.  At MTC
time 4.0, the <classname>MKConductor</classname> runs
<classname>MKPerformer</classname>s scheduled for time 5.0, causing
them to send the events destined for time 5.0 to the drivers.  The
drivers provide a delay of <emphasis>deltaT</emphasis> to compensate
for the fact that the events were sent early.  Thus, the events are
rendered at the correct time&horbar;when MTC reaches 5.0, the listener
hears the events for time 5.0.</para>

<para>Implementation details: In this mode, instead of adding
<emphasis>deltaT</emphasis> to the time stamps sent to the devices, we
just send the <classname>MKNote</classname>s early by
<emphasis>deltaT</emphasis>.  Thus,
<function>MKGetDeltaTTime()</function> returns the same value as
<function>MKGetTime()</function> so objects such as
<classname>MKMidi</classname> and <classname>MKOrchestra</classname>
that use <function>MKGetDeltaTTime()</function> to determine their
time stamps work correctly.  As a final refinement, if
<classname>MKMidi</classname>'s method <emphasis
role="bold">useInputTimeStamps:</emphasis><constant>YES</constant> was
sent, the time stamps returned from the <classname>MKMidi</classname>
driver are adjusted by <emphasis>adding</emphasis>
<emphasis>deltaT</emphasis> before the
<classname>MKConductor</classname>'s time is set from them.  The makes
sure that these stamps are in the <classname>MKConductor</classname>'s
time base.  <classname>MKNote</classname> that it is still possible to
add a &ldquo;local deltaT&rdquo; to <classname>MKMidi</classname> or the
<classname>MKOrchestra</classname>&horbar;these methods work the same
way in <emphasis>scheduler advance mode</emphasis> as they do in
<emphasis>device lag mode</emphasis>.</para>
      </sect3>
      <sect3 id="SequencerOverdubbing">
	<title>Sequencer Overdubbing</title>

<para>To simplify the task of overdubbing,
<classname>MKPartRecorder</classname> and
<classname>MKFileRecorder</classname> provide a method that makes sure
that recorded time tags match wall time:</para>

<programlisting>
- compensateForDeltaT:(BOOL)yesOrNo /* default is NO */
</programlisting>

<para>If sent with an argument of <constant>YES</constant>, this
method instructs the object to subtract <emphasis>deltaT</emphasis>
from the time it assigns the <classname>MKNote</classname>s it
records.  This is useful because the effect of
<emphasis>deltaT</emphasis> causes the listener to respond to an event
at time <emphasis>t</emphasis> with a response at time <emphasis>t +
deltaT</emphasis>. By subtracting<emphasis> deltaT</emphasis>, we undo
that undesired offset.</para>
      </sect3>
      <sect3 id="HintsAndReminders"> 
<title>Hints and Reminders</title>

<para>To minimize delays when using the <acronym>DSP</acronym>, be sure to send
[MKOrchestra setFastResponse:YES].  Also, using a high sampling rate
will give less of a delay when sending sound. The best response is
obtained by taking sound from the <acronym>DSP</acronym> serial port.  The delay here is
on the order of a few milliseconds.</para>
      </sect3>
    </sect2>
  </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document: "MusicKitConcepts.sgml"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
