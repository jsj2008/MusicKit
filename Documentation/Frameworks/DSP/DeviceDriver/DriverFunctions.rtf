{\rtf0\ansi\paperw16228 \paperh22175 \margl-907 \margr0 \margt0 \margb0 {\fonttbl\f0\fswiss Helvetica;\f1\froman Times;\f2\fmodern Courier;\f3\ftech Symbol;\f4\froman Palantino;}
{\stylesheet{\s0 \li4636 \fi-2520 \ri1007 \ql \tx4636   FctLibrary;}{\s1 \li0 \fi0 \ri0 \ql \tx-26 \tx5644 \tx12196   FooterLeft;}{\s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132   BodyIndented;}{\s3 \li2116 \fi0 \ri1007 \ql \tx2116 \tx2620 \tx3124 \tx3628   Body;}{\s4 \li0 \fi0 \ri0 \ql   Figure;}{\s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132   HeaderFile;}{\s6 \li1108 \fi0 \ri1007 \ql   FctHeadShort;}{\s7 \li2116 \fi0 \ri1007 \ql   Fig1Caption;}{\s8 \li2620 \fi-503 \ri1007 \ql \tx2620 \tx3124 \tx3628 \tx4132   BulletShort;}{\s9 \li2116 \fi0 \ri1007 \ql   FctSubHead;}{\s10 \li2116 \fi0 \ri1007 \ql   FigCaption;}{\s11 \li3124 \fi-503 \ri1007 \ql   Function;}{\s12 \li3124 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132   BodyIndented2;}{\s13 \li3124 \fi-503 \ri1007 \ql \tx3124 \tx3628 \tx4132 \tx4636   Num1Long;}{\s14 \li2620 \fi-503 \ri1007 \ql \tx2620 \tx3124 \tx3628 \tx4132   BulletLong;}{\s15 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132   FunctVarDesc;}{\s16 \li3628 \fi0 \ri1007 \ql   CodeExamp3;}{\s17 \li3124 \fi-503 \ri1007 \ql \tx3124 \tx3628 \tx4132 \tx4636   NumLong;}{\s18 \li0 \fi0 \ri0 \ql \tx11313 \tx12196   FooterRight;}{\s19 \li2116 \fi-2015 \ri1007 \ql \tx1743 \tx2116   Warning;}{\s20 \li2116 \fi0 \ri1007 \ql   Note;}{\s21 \li2620 \fi0 \ri1007 \ql   CodeExamp;}{\s22 \li4636 \fi-2520 \ri1007 \ql \tx4636   FctSummary;}{\s23 \li3124 \fi0 \ri1007 \ql \tx4636 \tx6652 \tx8668 \tx10684   TableBody;}{\s24 \li3124 \fi0 \ri1007 \ql   CodeExamp2;}{\s25 \li2116 \fi0 \ri1007 \ql   ChapterTitle;}{\s26 \li100 \fi0 \ri1007 \ql   1Head;}{\s27 \li1108 \fi0 \ri1007 \ql   2Head;}{\s28 \li2116 \fi0 \ri1007 \ql   3Head;}{\s29 \li2116 \fi0 \ri1007 \ql   4Head;}{\s30 \li2620 \fi-503 \ri1007 \ql \tx2620 \tx3124 \tx3628 \tx4132   Num1Short;}{\s31 \li2620 \fi-503 \ri1007 \ql   NumShort;}{\s32 \li1108 \fi0 \ri1007 \ql   FctHead;}{\s33 \li2116 \fi0 \ri1007 \ql   FctSynopsis;}{\s34 \li2116 \fi0 \ri1007 \ql   ChapterNum;}{\s35 \li3124 \fi0 \ri1007 \ql \tx4636 \tx6652 \tx8668 \tx10684   TableHead;}}
\li0 \fi0 \ri0 \ql \sb0 \f1 \fs24 
Release 2.0  Copyright \f3 \'e3\f1 1990 by NeXT Computer, Inc.  All Rights Reserved.\
\
\pard \s0 \li2116 \fi0 \ri1007 \ql \tx2116 \tx2620 \tx3124 \tx3628 \f1 \fs28 \fs16 \
\fs28 \
\fs16 \
\fs28 \s3 \fs16 \fs28 \
\fs16 \
\fs28 \pard \s26 \li100 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\
\
\fs36 Sound/DSP Driver Functions\
\fs16 \
\fs36 \pard \s3 \li2116 \fi0 \ri1007 \ql \tx2116 \tx2620 \tx3124 \tx3628 \b0 \fs28 \fs16 \fs28 These functions access the sound/DSP driver.  For brevity, the driver is referred to as \'aathe sound driver\'ba throughout the following. \
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\
\
\fs36 snddriver_dsp_boot(), snddriver_dsp_reset()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Start the DSP\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dsp_boot(\b0 port_t\b  \b0 \i commandPort\i0 , \b \b0 int\b  \b0 \i *bootImage\i0 ,\b \b0  \b \b0 \
\fi0 int \i imageSize\i0 , int \i priority\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_dsp_reset(\b0 port_t\b  \b0 \i commandPort\i0 , \b \b0 int \b \b0 \i priority\b \i0 )\
\s9 \li2116 \fi503 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_boot()\b0  enqueues a command to boot the DSP.  The arguments are:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i commandPort\i0  is the DSP command port, as retrieved by \b snddriver_get_dsp_cmd_port()\b0 . \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i bootImage\i0  is a pointer to a DSP program image that\'27s downloaded to the DSP (program memory location 0x0) and immediately executed.  The image is created by reading a \'aa.lod\'ba file that\'27s assembled from DSP56001 assembly code.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i imageSize\i0  is the size of the DSP boot image, in bytes.  The image must not exceed 512 words (24-bit DSP words right-justified within 32-bit integers).\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i priority\i0  is one of the three priority constants SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_HIGH_PRIORITY.  The sound driver sorts the commands in its DSP command queue according to priority.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Booting the DSP clears neither external memory nor on-chip data memory.\
\fs16 \
\fs28 \b snddriver_dsp_reset()\b0  puts the DSP in its reset state.  By this it\'27s meant that the DSP\'27s execution is immediately halted and a bootstrap program is awaited.  Booting the DSP automatically resets it, thus you don\'27t need to call this function before calling \b snddriver_boot_dsp()\b0 .  \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28   RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\fs36 snddriver_dsp_dma_read() \f3 \b0 \'ae\f1  \b snddriver_dsp_dma_write()\
\fs16 \
\fs36 \fs16 \
\
\
\
\fs36 snddriver_dsp_dma_write(), snddriver_dsp_dma_read()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Transfer data to and from the DSP via DMA\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dsp_dma_write(\b0 port_t\b  \b0 \i commandPort\i0 ,\b \b0  int\b  \b0 \i elementCount\i0 ,\
\fi0 int \i dataFormat\i0 , pointer_t \i data\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_dsp_dma_read(\b0 port_t\b  \b0 \i commandPort\i0 ,\b \b0  int\b  \b0 \i elementCount\i0 ,\
\fi0 int \i dataFormat\i0 , pointer_t \i data\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 These functions\b  \b0 enqueue commands that perform application-initiated DMA transfers\b  \b0 to and from the DSP.  You must include complex DMA protocol to use these functions.  The arguments to the two functions are similar:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i commandPort\i0  is the DSP command port, as retrieved by \b snddriver_get_dsp_cmd_port()\b0 . \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i elementCount\i0  is the number of data elements to send during each transfer.\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx4636 \tx6148 \fs16 \fs28 \'b7	\i dataFormat \i0 is an integer constant that describes the size and packing of an individual data element.  These are\
\fs16 \
\fs28 \pard \s23 \li3124 \fi0 \ri1007 \ql \li3628 \fi-503 \fi0 \tx6652 \tx8668 \tx10684 DSP_MODE8	1 byte per element\
\fi0 DSP_MODE16	2 bytes per element\
\fi0 DSP_MODE24	3 bytes per element\
\fi0 DSP_MODE32	3 bytes per element, right-justified in 4\
\fi0 DSP_MODE2416	2 bytes per element, packed and right-justified in 4\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	\i data\i0  is a pointer to the data that you\'27re transferring.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 There are three rules regarding the size and alignment of a DMA transfer buffer:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	The size in bytes of a single DMA transfer buffer, reckoned as \i elementCount \i0 * bytes-per-element, must be a multiple of 16.  Note that bytes-per-element isn\'27t given directly as an argument.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	The data must be \'aaquad-aligned\'ba; in other words, the starting address (\i data\i0 ) must be a multiple of 16.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	All the data in a transfer buffer must lie on the same page of virtual memory.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 If you\'27re writing data, the \b snddriver_dsp_dma_write()\b0  function enqueues a command to send the data to the DSP and then immediately returns.  \b snddriver_dsp_dma_read()\b0 , on the other hand, waits until it has read the prescribed amount of data and returns with \i data\i0  filled.  DMA-transfer commands are always enqueued with high priority.   \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_read()\b0 , \b snddriver_dsp_write(), snddriver_dsp_protocol()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_dsp_host_cmd()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Enqueue a DSP command\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dsp_host_cmd(\b0 port_t\b  \b0 \i commandPort\i0 ,\b \b0  u_int\b  \b0 \i hostCommand\i0 ,\
\fi0 u_int\b  \b0 \i priority\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_host_cmd()\b0  enqueues a command on the sound driver\'27s DSP command queue that interrupts the DSP and causes it to execute one of 32 interrupt routines (or \i host commands\i0 ).  Its arguments are:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i commandPort\i0  is the DSP command port, as retrieved by \b snddriver_get_dsp_cmd_port()\b0 . \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	The host command that you want to execute is represented by an integer that you pass as the \i hostCommand \i0 argument.  The first 22 host commands are already defined (or reserved).  The host commands provided by NeXT are represented by constants (prefix \'aaDSP_hc_\'ba) that are defined in \b /usr/include/nextdev/snd_dsp.h\b0 .  Creating your own host command requires a familiarity with DSP programming that lies beyond the scope of this description.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i priority\i0  is one of the three priority constants SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_HIGH_PRIORITY.  The sound driver sorts the commands in its DSP command queue according to priority.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 When the DSP receives a host command, it sets the HC flag in the Command Vector Register.  After executing the command, the DSP clears the flag.   You should always precede a call to \b snddriver_dsp_host_cmd()\b0  with a call to \b snddriver_dspcmd_req_condition()\b0  that waits for HC to clear in order to avoid overwriting a previously requested, but as yet unexecuted, host command:\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 /* CVR_HC is defined in <nextdev/snd_dspreg.h> */ \
\fi0 err = snddriver_dspcmd_req_condition(commandPort, CVR_HC, 0, ...);\
\fi0 if (err != 0)\
\fi0     . . .\
\fi0 \
\fi0 /* Now enqueue the host command request. */\
\fi0 err = snddriver_dsp_host_cmd(...);\
\fi0 if (err != 0)\
\fi0     . . .\
\s9 \li2116 \fi0 \f1 \fs28 \fs16 \
\
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dspcmd_req_condition()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_dsp_protocol()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Set the sound driver\'27s protocol vis-a-vis the DSP\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dsp_protocol(\b0 port_t\b  \b0 \i devicePort\i0 , \b \b0 port_t\b  \b0 \i ownerPort\i0 ,\b \b0  \b \b0 \
\fi0 int \i protocol\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_protocol()\b0  lets you establish the manner in which the sound driver    communicates with the DSP; specifically, it determines whether to create 0, 1, or 2 DSP-reply buffers and whether DSP interrupts are enabled.  The existence of the DSP-reply buffers determines whether you can use streams to transfer data.  \
\fs16 \
\fs28 The function\'27s first two arguments are the sound driver device port and the DSP owner port, as acquired through \b SNDAcquire()\b0 . \
\fs16 \
\fs28  \i protocol\i0  is the heart of the matter:  It\'27s a code that represents the protocol that you wish to establish.  There are two ways to create the appropriate protocol:  If you\'27re using streams to access the DSP, then you should pass the protocol variable that\'27s modified by calls to \b snddriver_stream_setup()\b0 ,\b  \b0 as explained (with an example) in the description of that function.  Alternatively\'d0or in addition to the foregoing\'d0you can create a protocol code by \b or\b0 \'27ing the following DSP protocol constants:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_DSP_PROTO_RAW represents the barest of protocols.  The sound driver makes no assumptions about how the DSP is being used:  No DSP-reply buffers are created and the DSP can\'27t interrupt the host.  You can\'27t use streams in raw protocol; to transfer data, you use the \b snddriver_dsp_write()\b0  and \b snddriver_dsp_read()\b0  functions.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 All the other protocols create at least one DSP-reply buffer and allow DSP interrupts, thus allowing you to transfer data through a stream:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_DSP_PROTO_DSPMSG (\'aaDSP-message\'ba) creates a single DSP-reply message buffer that can hold 512 messages.  A message fom the DSP (as it lies in the reply buffer) is a 24-bit word right-justified in 32 bits.  To receive the contents of this buffer, you enqueue a request through \b snddriver_dsp_req_msg()\b0 .\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_DSP_PROTO_DSPERR (\'aaDSP-error\'ba) creates an additional 512-message DSP-reply buffer that collects error messages sent from the DSP.  An error message is identified as having its MSB (bit 23) set.  You can request the contents of the error buffer through \b snddriver_dsp_req_err()\b0 .\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_DSP_PROTO_C_DMA (\'aacomplex DMA\'ba) implies DSP message mode (a single DSP-reply buffer is created) and allows DSP-initiated DMA transfers.  \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_DSP_PROTO_HFABORT (\'aahost flag abort\'ba) causes the driver to take note if the DSP aborts.  (The DSP indicates that it has aborted by setting HF2 and HF3.)\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b Note:\b0   To get the documented behavior from these protocols, you \i must\b \i0  \b0 include\b  \b0 SNDDRIVER_DSP_PROTO_RAW.  \
\fs16 \
\fs28 \b Note:\b0   A protocol of 0 produces Release 1.0 behavior; this is roughly equivalent to a combination of DSP message,  DSP error, and host flag abort modes.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_setup()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\fs36 snddriver_dsp_read() \f3 \b0 \'ae\f1  \b snddriver_dsp_write()\
\fs16 \
\fs36 \s6 \fs16 \fs36 snddriver_dsp_read_data() \f3 \b0 \'ae\f1  \b snddriver_dsp_write()\
\fs16 \
\fs36 \fs16 \fs36 snddriver_dsp_read_messages() \f3 \b0 \'ae\f1  \b snddriver_dsp_write()\
\fs16 \
\fs36 \fs16 \fs36 snddriver_dsp_reset() \f3 \b0 \'ae\f1  \b snddriver_dsp_boot()\
\fs16 \
\fs36 \s32 \fs16 \
\
\
\
\fs36 snddriver_dsp_set_flags()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Set the DSP host flags\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dsp_set_flags(\b0 port_t\b  \b0 \i commandPort\i0 ,\b \b0  u_int\b  \b0 \i flagMask\i0 ,\
\fi0 \b u_int \i flagValue\i0 ,\b0  u_int\b  \b0 \i priority\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_set_flags()\b0  enqueues a command to modify one or both of the DSP host interface flags HF0 (host flag 0) and HF1 (host flag 1).   \
\fs16 \
\fs28 The \i flagMask\i0  argument defines which of the host flags you want to affect.  The flags are represented by the constants SNDDRIVER_ICR_HF0 and  SNDDRIVER_ICR_HF1.  You can set both flags at the same time by \b or\b0 \'27ing  these two constants.  (ICR stands for \'aaInterrupt Control Register\'ba; this is the register to which the host flags belong.)\
\fs16 \
\fs28 \i flagValue\i0  is the value to which you\'27re setting the flag(s).  A host flag can be either on or off, states that are also referred to as \'aaset\'ba and \'aacleared\'ba.  To set a flag, you pass its constant identifier; to clear it, you pass 0.  The following examples illustrate this concept:\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 /* Set HF0 (turn it on). */\
\fi0 snddriver_dsp_set_flags(..., SNDDRIVER_ICR_HF0,\
\fi0            SNDDRIVER_ICR_HF0,...)\
\fi0 \
/* Clear HF1. */\
\fi0 snddriver_dsp_set_flags(..., SNDDRIVER_ICR_HF1,0,...)\
\fi0 \
/* Set both flags. */\
\fi0 snddriver_dsp_set_flags(..., \
\fi0         SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1,\
\fi0            SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1, ...)\
\fi0 \
/* Set HF0 and clear HF1. */\
\fi0 snddriver_dsp_set_flags(..., \
\fi0         SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1,\
\fi0            SNDDRIVER_ICR_HF0, ...)\
\fi0 \
/* Clear both flags. */\
\fi0 snddriver_dsp_set_flags(..., \
\fi0         SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1, 0,...)\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 The other two arguments, \i commandPort \i0 and \i priority, \i0 are the\i  \i0 DSP command port and command-queue priority, respectively.  The DSP command port is retrieved through \b snddriver_dsp_cmd_port()\b0 ; you set the priority to one of SNDDRIVER_HIGH_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_LOW_PRIORITY.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dspcmd_req_condition()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_dsp_write(), snddriver_dsp_read(), snddriver_dsp_read_data(), snddriver_dsp_read_messages()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Transfer data to and from the DSP \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dsp_write(\b0 port_t\b  \b0 \i commandPort\i0 , \
\fi0 \b void *\b0 \i buffer\i0 ,\b  int \b0 \i elementCount\i0 ,\b \b0  int\b  \b0 \i elementSize, \b \i0 \b0 int\b \b0 \i  priority\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_dsp_read(\b0 port_t\b  \b0 \i commandPort\i0 , \
\fi0 \b void *\b0 \i buffer\i0 ,\b  int \b0 \i elementCount\i0 ,\b \b0  int\b  \b0 \i elementSize, \b \i0 \b0 int\b \b0 \i  priority\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_dsp_read_messages(\b0 port_t\b  \b0 \i commandPort\i0 , \
\fi0 \b void *\b0 \i buffer\i0 ,\b  int \b0 \i elementCount\i0 ,\b \b0  int\b  \b0 \i elementSize, \b \i0 \b0 int\b \b0 \i  priority\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_dsp_read_data(\b0 port_t\b  \b0 \i commandPort\i0 , \
\fi0 \b void **\b0 \i buffer\i0 ,\b  int \b0 \i elementCount\i0 ,\b \b0  int\b  \b0 \i elementSize, \b \i0 \b0 int\b \b0 \i  priority\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_write()\b0  enqueues a command to perform a one-shot, application-initiated data transfer to the DSP; \b snddriver_dsp_read()\b0  brings data back from the DSP in a like manner.  You generally use these functions if you have a small amount of data to transfer or if the transfers are infrequent enough that the overhead of the obvious alternative\'d0setting up a DMA stream\'d0would be exorbitant.  \
\fs16 \
\fs28 The other two functions, \b snddriver_dsp_read_messages()\b0  and \b snddriver_dsp_read_data()\b0  are auxilliary to \b snddriver_dsp_read()\b0 .  When you call \b snddriver_dsp_read()\b0 , it, in turn, calls one of the auxilliary functions; which of the two functions it calls depends on the current DSP protocol, as described below.  You can call these functions yourself, by-passing \b snddriver_dsp_read()\b0 , although you should adhere to the same protocol rules that \b snddriver_dsp_read() \b0 obeys.\
\fs16 \
\fs28 The arguments to all four functions are similar:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \i \fs16 \fs28 \'b7	commandPort \i0 is the DSP command port, as retrieved through \b snddriver_get_dsp_cmd_port().\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \b0 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \i \fs16 \fs28 \'b7	buffer\i0 , as used by \b snddriver_dsp_write()\b0 , is a pointer to the data that you want to send to the DSP.  For the \b snddriver_dsp_read...()\b0  functions, it\'27s a pointer to the location where you want the retrieved data to be stored.  Note that for \b snddriver_dsp_read_data()\b0 , \i buffer \i0 is the address of a pointer; this allows the function to allocate memory for the data if you haven\'27t allocated it yourself.  \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i elementCount\i0  and \i elementSize\i0  are the number of data elements to transfer and the size in bytes of a single element, respectively.  \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i priority\i0  is an integer that's used to sort the command on the DSP command queue. The sound driver defines three priorities represented by the constants SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, and SNDDRIVER_HIGH_PRIORITY.  You normally set all application-initiated data transfers to low priority, thus reserving medium and high priority for operations that need to jump to the head of the DSP command queue. \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Of these functions, \b snddriver_dsp_write()\b0  is most straightforward:  When it\'27s called, a transfer-data-to-the-DSP command is sorted (by priority) into the DSP command queue.  If, when its turn comes, the command can\'27t be executed, the driver simply pushes it back on the queue and tries again.  No other commands of equal or lower priority can be executed while a frustrated write command is sitting on top of the queue.  Note, however, that higher priority commands \i will\i0  get through.  \
\fs16 \
\fs28 As mentioned earlier, \b snddriver_dsp_read()\b0  calls one of its two auxilliary functions as determined by the current DSP protocol:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	If your application is in raw protocol, then \b snddriver_dsp_read_data()\b0  is used to read data from the DSP transmit registers.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	If DSP message protocol is included,  \b snddriver_dsp_read_messages()\b0  is used to read data from the DSP-reply buffer.  \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The difference between the two mechanisms is generally transparent such that you can  call \b snddriver_read_data()\b0  without regard for the current protocol.  However, the manner in which either of the underlying functions handles incomplete reads can influence the design of your application:  If the read can\'27t be completed (typically because the DSP hasn\'27t generated enough data), \b snddriver_dsp_read_data()\b0  blocks the DSP command queue in the fashion of \b snddriver_dsp_write()\b0 .  In the same situation, \b snddriver_dsp_read_messages()\b0  waits for more data without blocking the command queue.  Thus \b snddriver_dsp_read_messages()\b0  can safely be called from a separate thread at any time.  This isn\'27t true of \b snddriver_dsp_read_data()\b0 ; you should be scrupulous about ensuring that sufficient data has been processed by the DSP before you attempt to read it through this function (or through \b snddriver_dsp_read()\b0  while in raw protocol).  \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_dma_read(), snddriver_dsp_dma_write()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_dspcmd_req_condition\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Request a DSP host interface register condition\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dspcmd_req_condition(\b0 port_t\b  \b0 \i commandPort\i0 ,\b \b0  \b \b0 \
\fi0 u_int\b  \b0 \i registerMask\i0 , \b \b0 u_int \b \b0 \i conditionFlags, \b \i0 \b0 int \b \b0 \i priority, \b \i0 \b0 port\b _\b0 t \i replyPort\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dspcmd_req_condition()\b0  does two things:  It causes the DSP command queue to block until the specified host interface register condition is true, and it registers a request for an asynchronous message to be sent to \i replyPort\i0  when the condition is fulfilled.  The function returns immediately.\
\fs16 \
\fs28 You specify a condition through a combination of the \i registerMask\i0  and \i conditionFlags\i0  arguments: \
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i registerMask\i0  specifies the host interface registers (actually, the bits therein) that you\'27re interested in.  It\'27s created by \b or\b0 \i \'27\i0 ing the register-bit constants defined in \b <nextdev/snd_dspregs.h>\b0 .  A subset of these are also defined as sound driver constants in \b <sound/sounddriver.h>\b0 .   \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i conditionFlags\i0  encodes the states of the register bits that define a satisfied condition.  To specify that you want a register bit set, you \b or\b0  the register-bit constant that represents it; if you want it clear, you exclude the constant.  If you want all the specified bits to be clear, set \i conditionFlags\i0  to 0.  \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 In the following example, the command queue is blocked until HF0 is set and HF1 is clear (both flags are in the Interrupt Control Register): \
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 /* Block until HF0 is set and HF1 is clear. */\
\fi0 snddriver_dspcmd_req_condition(..., \
\fi0         SNDDRIVER_ICR_HF0 | SNDDRIVER_ICR_HF1,\
\fi0         SNDDRIVER_ICR_HF2, ...)\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 The condition request is sorted into the DSP command queue according to \i priority, \i0 which must be one of SNDDRIVER_LOW_PRIORITY, SNDDRIVER_MED_PRIORITY, or SNDDRIVER_HIGH_PRIORITY.\
\fs16 \
\fs28 The message that\'27s sent to the reply port when the condition is fulfilled contains the value of the host interface register.  By setting the \i registerMask\i0  argument to 0, you can use the \b snddriver_dspcmd_req_condition()\b0  function to simply poll for this value. \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_dsp_set_flags()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_dspcmd_req_err() \f3 \b0 \'ae\f1  \b snddriver_dspcmd_req_msg()\
\fs16 \
\fs36 \fs16 \
\
\
\
\fs36 snddriver_dspcmd_req_msg(), snddriver_dspcmd_req_err()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Request the contents of the DSP-reply buffers \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_dspcmd_req_msg(\b0 port_t\b  \b0 \i commandPort\i0 , \b \b0  port_t\b  \b0 \i replyPort\b \i0 )\
\b0 \b kern_return_t snddriver_dspcmd_req_err(\b0 port_t\b  \b0 \i commandPort\i0 , \b \b0  port_t\b  \b0 \i replyPort\b \i0 )\
\s9 \li2116 \fi503 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The\b  snddriver_dspcmd_req_msg()\b0  and \b snddriver_dspcmd_req_err()\b0  functions are part of the mechanism by which your application retrieves messages from the sound driver\'27s DSP-reply buffers.  They request that the contents of the appropriate buffer (as described below) be sent in a Mach message to \i replyPort\i0 , a valid port that must already be allocated.  Simply requesting a message is only half of the story:  You then have to receive the message that\'27s been sent, usually by sitting in a \b msg_receive()\b0  loop.  You typically process the Mach messages that these functions induce by passing them (the messages) to the \b snddriver_reply_handler()\b0  function.\
\fs16 \
\fs28 The utility of these functions depends on your application\'27s DSP protocol:  \
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	You should never use these functions in raw protocol since the sound driver doesn\'27t create any DSP-reply buffers.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	By including DSP message protocol, a single DSP-reply buffer is created in which both error and non-error messages are stored; thus \b ...req_msg()\b0  is of use, but \b ...req_err()\b0  isn\'27t. \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	DSP error protocol deems that two buffers be created, one for error messages and the other for non-error messages.  Both functions are useful in this protocol. \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 DSP protocol and how to set it is explained in the description of the \b snddriver_set_dsp_protocol()\b0  function.  \b \b0 For both functions, the\b \b0 \i  commandPort\b \i0 \b0  argument is the DSP command port as retrieved by \b snddriver_get_dsp_cmd_port()\b0 .  \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_set_dsp_protocol()\b0 , \b snddriver_reply_handler()\b0  \
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\
\
\fs36 snddriver_get_device_parms() \f3 \b0 \'ae\f1  \b snddriver_set_device_parms()\
\fs16 \
\fs36 \fs16 \
\
\
\
\fs36 snddriver_get_dsp_cmd_port()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Get the DSP command port \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_get_dsp_cmd_port(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 \b port_t \b0 \i ownerPort\i0 ,\b  \b0 port_t\b  \b0 \i *commandPort\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_get_dsp_cmd_port()\b0  attempts to get the \i DSP command port\i0 , the port through which the sound driver issues commands to the DSP.  If it\'27s successful, the port is returned in the \i commandPort\i0  argument, which needn\'27t have been previously allocated.  \
\fs16 \
\fs28 The first two arguments, \i devicePort\i0  and \i ownerPort\i0 , are the sound driver device port and the DSP owner port, as acquired through \b SNDAcquire()\b0 . \
\fs16 \
\fs28 The DSP command port is required as an argument by almost all sound driver functions that communicate with the DSP.  The one notable exception, for which you don\'27t have to get the command port as it\'27s gotten implicitly when needed, is if you send and retrieve DSP data via streams after having booted the DSP through the \b SNDBootDSP()\b0  sound library function.  But even in this case getting the command port as a reflex to getting the DSP owner port won\'27t serve you ill.  \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28   RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\
\
\fs36 snddriver_get_volume() \f3 \b0 \'ae\f1  \b snddriver_set_device_parms()\
\fs16 \
\fs36 \fs16 \
\
\
\
\fs36 snddriver_new_device_port()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Reallocate the sound driver device port\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_new_device_port(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 \b port_t \b0 \i superuserPort\i0 , port_t \i *newDevicePort\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 This function deallocates the sound driver device port \i devicePort\i0 , as previously acquired through \b SNDAcquire()\b0 , then allocates a new port to the device which it returns as \i newDevicePort\i0 .  When the old device port is deallocated, so, too, are all its resource owner ports and sound streams; thus any currently operating sound driver tasks, such as recording and playing sounds, are aborted.  Because of the ruthlessness of this act, you must be the UNIX superuser to call this function, as verified by the \i superuserPort\i0  argument, for which you should pass the return value of \b host_priv_self()\b0 .   The new device port\'27s registration with regard to the Network Name Server is the same as that of the old; in other words, if the old port had been registered (through \b netname_check_in()\b0 ), the new one will be registered automatically.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\
\
\fs36 snddriver_reply_handler()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Respond to asynchronous sound driver messages\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_reply_handler(\b0 msg_header_t *\b \b0 \i reply\b \i0 \b0 , \b \b0 \
\fi0 snddriver_handlers_t *\i handlers\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_reply_handler()\b0  helps your application respond to asynchronous sound driver messages.  The function is designed around the \b snddriver_handlers\b0  structure, which provides a correspondence between the sound driver messages and a list of C functions that you provide\b .  \b0 When you receive a message from the sound driver, you pass the message and a\b  snddriver_handlers\b0  structure to \b snddriver_reply_handler()\b0  which then executes the handler function that corresponds to the message.\
\fs16 \
\fs28 The definition of the \b snddriver_handlers\b0  structure (\b typedef\b0 \'27d, for convenience, as \b snddriver_handlers_t\b0 ) reveals the nature of the functions that you can register as reply handlers:\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 typedef struct snddriver_handlers \{\
\fi0     void                     *arg;\
\fi0     int                       timeout;\
\fi0     sndreply_tagged_t         started;\
\fi0     sndreply_tagged_t         completed;\
\fi0     sndreply_tagged_t         aborted;\
\fi0     sndreply_tagged_t         paused;\
\fi0     sndreply_tagged_t         resumed;\
\fi0     sndreply_tagged_t         overflow;\
\fi0     sndreply_recorded_data_t  recorded_data;\
\fi0     sndreply_dsp_cond_true_t  condition_true;\
\fi0     sndreply_dsp_msg_t        dsp_message;\
\fi0     sndreply_dsp_msg_t        dsp_error;\
\fi0    \} snddriver_handlers_t;\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 The structure\'27s\i  \b \i0 arg\b0  field is a value that\'27s passed to the reply handlers when they\'27re called by \b snddriver_reply_handler()\b0 ; you can set it to whatever value best suits your application but keep in mind that the value must fit within the size of a pointer (four bytes).  The \b timeout\b0  field is currently unused.  \
\fs16 \
\fs28 The final ten fields are the heart of the structure\'d0each corresponds to a particular sound driver message.  The first six of these correspond to messages that indicate a change in the state of a stream (\'aastream-state\'ba messages); in other words, the sound driver sends a specific message when a stream starts processing data, when it completes its processing, when it aborts, and so on.  By setting a field to a particular function, you register that function as the handler for the message to which the field corresponds.  For example, to establish a function named \b handleStreamStart()\b0  as the function that\'27s executed when your application receives a stream-started message from the sound driver, you would do the following:\
\fs16 \
\fs28 \s24 \li3124 \fi-503 \fi0 \f2 \fs24 /* Create a snddriver_handlers_t and register the \
\fi0  * function handleStreamStart() (which we\'27ll assume already \
\fi0  * exists) to process stream-started messages.\
\fi0  */\
\fi0 snddriver_handlers_t replyHandlers;\
\fi0 replyHandlers.started = handleStreamStart;\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 While this registers \b handleStreamStart()\b0  as the handler for stream-started messages,  you must also tell the sound driver that you actually want such messages sent to your application.  To do this, you set the \i msgStarted \i0 boolean argument to true when you call \b snddriver_stream_start_reading()\b0  or \b snddriver_stream_start_writing()\b0 .   Analogous \i msg...\i0  message flags exist for the other five stream-state messages.  \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 When the sound driver sends a stream-state message to your application, it sends it to the port that you specify as the last argument (\i replyPort\i0 ) to \b snddriver_stream_start_reading(\b0 ) or \b snddriver_stream_start_writing()\b0 .  To receive the message, you create a \b msg_header_t\b0  structure, set its \b local_port\b0  field to the stream\'27s reply port, and then wait for the message to arrive by sitting in a message receive (\b msg_receive()\b0 ) loop.  After so capturing the message, you then pass it, along with your handler structure, to \b snddriver_reply_handler()\b0 .  This is demonstrated by example below.  \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Notice, from the definition of \b snddriver_handlers\b0 , that the six stream-state handlers are all of type \b sndreply_tagged_t\b0 .  This type represents a two-argument function protocol that\'27s defined as\
\fs16 \
\fs28 \s24 \li3124 \fi-503 \fi0 \f2 \fs24 typedef void (*sndreply_tagged_t) (void *arg, int tag);\
\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 The functions that you register to handle the stream-state messages must adhere to this protocol.   The values of the arguments are set by \b snddriver_reply_handler()\b0 :\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i arg\i0  is given the value of the \i arg\i0  field of the \b snddriver_handlers\b0  structure in which the function is registered.  As mentioned earlier, you can set the structure\'27s \i arg \i0 field to a (four-byte) value\i  \i0 that suits the needs of your application.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i tag\i0  is the region-identifying tag that you provide as an argument to \b snddriver_stream_start_writing()\b0  or \b snddriver_stream_start_reading()\b0 .\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The seventh of the ten \b snddriver_handlers\b0  handler fields, \b recorded_data\b0 , also applies to streams.  However, unlike the fist six, which are optional, \b recorded_data\b0  is essential when you\'27re reading data from a stream.  It\'27s importance arises from the way that the sound driver handles read data:  It keeps the data in the kernel\'27s virtual memory until you ask to bring it into your application.  The only way to bring this data back is to supply a \b recorded_data\b0  handler that does so.  The following program excerpt, a modified and distilled version of the example given in \b /NextDeveloper/Examples/DSP/SoundDSPDriver/dsp_example_3/\b0 , demonstrates a typical way to achieve this effect.  In the example, details such as acquiring the sound driver and sound resource owner ports are omitted.  The read stream shown here is anonymous\'d0the code can be used equally well for a stream that reads from sound-in or from the DSP: \
\fs16 \
\fs28 \s21 \f2 \fs24 /* The code shown in the example requires the following header \
\fi0    files  */\
\fi0 #import <sound/sounddriver.h>\
\fi0 #import <mach.h>\
\fi0 \
\fi0 /* Define a read stream tag, a read pointer, and a byte count \
\fi0    variable. */\
\fi0 #define READ_TAG 1\
\fi0 static short *readData;\
\fi0 static int readCount;\
\fi0 \
/* Create a recorded_data handler; the function\'27s protocol is \
\fi0  * explained following the example.\
\fi0  */\
\fi0 static void read_completed(void *arg, int tag, void *kernelData, \
\fi0                             int size) \
\fi0 \{\
\fi0     /* Make sure this is the read stream. */\
\fi0     if (tag == READ_TAG) \{\
\fi0         readData = (short *)kernelData;\
\fi0         readCount = size; \
\fi0     \}\
\fi0 \}\
\fi0 \
main()\
\fi0 \{\
\fi0     /* Define a read port, a reply port, and a reply structure. */\
\fi0     port_t readPort, replyPort;\
\fi0     snddriver_handlers_t replyHandlers;\
\fi0 \
    /* Allocate a Mach message header. msg_header_t and MSG_SIZE_MAX\
\fi0      * (and msg_receive, below) are defined in mach.h.\
\fi0      */\
\fi0     msg_header_t *reply_msg = (msg_header_t *)malloc(MSG_SIZE_MAX);\
\fi0 \
    /* Create an error-check variable. */\
\fi0     int err;\
\fi0 \
    /* Allocate the reply port. */\
\fi0     err = port_allocate(task_self(), &replyPort); \
\fi0     if (err != 0)\
\fi0         . . .\
\fi0 \
    /* Set the recorded_data handler. */\
\fi0     replyHandlers.recorded_data = read_completed;\
\fi0 \
    /* Set the amount of data you wish to read; for the purposes of \
\fi0      * this example, an arbitrary amount is specified. \
\fi0      */\
\fi0     readCount = 1024;\
\fi0 \
    /* Here, a number of activities -- such as acquiring the sound \
\fi0      * driver port and sound resource owner port, setting up a read \
\fi0      * stream through snddriver_stream_setup(), and (possibly) \
\fi0      * booting the DSP and sending it data -- are omitted. \
\fi0      */\
\fi0     . . .\
\fi0 \
    /* Enqueue a read request.  The six 0 arguments are the message\
\fi0      * request flags.  \
\fi0      */\
\fi0     err = snddriver_stream_start_reading(readPort, 0, readCount, \
\fi0                       READ_TAG, 0,0,0,0,0,0, replyPort);\
\fi0     if (err != 0)\
\fi0         .  .  .\
\fi0 \
    /* Sit in a message-receive loop. */\
\fi0     while(1) \{\
\fi0         /* Set up the reply message.  This must be done inside the \
\fi0          * loop since msg_receive() may change the message header.\
\fi0          */\
\fi0         replyMsg->msg_size = MSG_SIZE_MAX;\
\fi0         replyMsg->msg_local_port = replyPort;\
\fi0         err = msg_receive(replyMsg, MSG_OPTION_NONE, 0);\
\fi0         if (err != 0)\
\fi0             . . .\
\fi0     \}\
\fi0 \
    /* Dispatch the message to the reply handlers.*/\
\fi0     err = snddriver_reply_handler(replyMsg, &replyHandlers);\
\fi0     if (err != 0)\
\fi0         . . .\
\fi0     /* Provide a means to break out of the loop. */\
\fi0     . . .\
\fi0     \}\
\fi0 \}\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 As implied by the example, you don\'27t need to tell the sound driver that you want a data-recorded message to be sent to your application; the message is always sent automatically.  The example also illustrates the rule that the reply port used to receive messages while in the \b msg_receive()\b0  loop is that which is specified as the final argument to the \b snddriver_stream_start_reading()\b0  function.  \
\fs16 \
\fs28 The data type of the \b recorded_data \b0 field dictates the protocol of the function that you design to bring data back to the application.  The type is \b sndreply_recorded_data_t\b0 :\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 typedef void (*sndreply_recorded_data_t)(void *arg, int tag, \
\fi0                 void *kernelData, int size);\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 The first two arguments, \i arg \i0 and\i  tag\i0 , are the same as in the \b snddreply_tagged_t\b0  type. \i kernelData\i0  is a pointer to the recorded data as it resides in the kernel; \i size\i0  is the size of the recorded data in bytes.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The final three \b snddriver_handlers\b0  fields correspond to messages that are inspired by the DSP:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	The\b  condition_true\b0  handler is called when a requested DSP host interface register condition comes true.  (More accurately, the handler is called when the message that indicates that the condition is true is passed to \b snddriver_reply_handler()\b0 .) \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b dsp_message\b0 \i  \i0 handles general messages that the sound driver receives from the DSP.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b dsp_error\b0 \i  \i0 does the same for DSP error messages.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 For each of these three handlers, there is a corresponding sound driver function that enqueues a request for a condition, a DSP message, or a DSP error message, respectively:  \
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b snddriver_dspcmd_req_condition()\b0  blocks the DSP command queue until the state of the DSP host interface registers satisfies a requested condition.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b snddriver_dspcmd_req_msg()\b0 \i  \i0 requests that the contents of the 512-byte DSP-reply buffer be sent in a single message to your application.  You must include DSP-message protocol for this to have an effect.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b snddriver_dspcmd_req_err()\b0 \i  \i0 requests that the 512-byte DSP-reply error buffer be sent in a message.  You must include DSP-error protocol for this to have an effect.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 As with the \b snddriver_stream_start...()\b0  functions, the three DSP request functions require that you provide a reply port as an argument.  It\'27s to this reply port that the sound driver sends the requested DSP-inspired messages.  A single call to one of these functions causes a single reply message to be sent to your application.  Thus, for each call to \b snddriver_dspcmd_req_msg()\b0 , for example, your application will receive one message from the sound driver.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The \b condition_true\b0  handler is of type \b sndreply_dsp_cond_true_t\b0 :  \
\fs16 \
\fs28 \s24 \li3124 \fi-503 \fi0 \f2 \fs24 typedef void (*sndreply_dsp_cond_true_t)(void *arg, u_int mask, \
\fi0                 u_int flags, u_int registers);\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 \i arg\i0  is the value of the \b arg\b0  field.  The next two arguments, \i mask\i0  and \i flags\i0 , are given the values that were passed to \b snddriver_dspcmd_req_condition()\b0  (which also has \i mask\i0  and \i flags\i0  arguments).  \i registers \i0 encodes the current status of the four DSP host interface registers in a single 32-bit vector.  See the description of \b snddriver_dspcmd_req_condition()\b0  for more information on how this works. \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The \b dsp_message\b0  and \b dsp_error \b0 are of type \b sndreply_dsp_msg_t\b0 :\
\fs16 \
\fs28 \s24 \li3124 \fi-503 \fi0 \f2 \fs24 typedef void (*sndreply_dsp_msg_t)(void *arg, int *data, \
\fi0                 int size);\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 \i arg\i0  is the value of the \b arg\b0  field.  \i data\i0  is a pointer to the contents of the appropriate DSP-message buffer (regular or error, as the handler is \b dsp_message\b0  or \b dsp_error\b0 ).  \i size\i0  is the size of the buffer contents\i ,\i0  in bytes.\
\fs16 \
\fs28 \b snddriver_reply_handler()\b0  ignores messages for which you haven\'27t created and registered a handler function.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28   RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_start_reading()\b0 ,\b  snddriver_stream_start_writing()\b0 ,\b  snddriver_dspcmd_req_condition()\b0 ,\b  snddriver_dspcmd_req_msg()\b0 ,\b  snddriver_dspcmd_req_err()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_set_device_parms(), snddriver_get_device_parms(), snddriver_set_volume(), snddriver_get_volume(), snddriver_set_ramp()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Set and get sound playback attributes\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_set_device_parms(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 boolean\b _t \i speakerOn\i0 , \b0 boolean\b \b0 _t\b  \b0 \i filterOn\b \i0 , \b0 boolean\b \b0 _t\b  \b0 \i zerofill\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_get_device_parms(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 boolean_t *\b \i speakerOn\i0 , \b0 boolean\b \b0 _t\b  \b0 \i *filterOn\b \i0 , \b0 boolean\b \b0 _t\b  \b0 \i *zerofill\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_set_volume(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 int\b  \b0 \i leftVolume\i0 ,\b  \b0 int\b  \b0 \i rightVolume\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_get_volume(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 int\b  \b0 \i *leftVolume\i0 ,\b  \b0 int\b  \b0 \i *rightVolume\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_set_ramp(\b0 port_t\b  \b0 \i devicePort\i0 , int \i rampOn\b \i0 )\
\s9 \li2116 \fi503 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 These functions set and get attributes of the sound playback system.  Each takes, as its first argument, the sound driver device port as acquired through \b SNDAcquire()\b0 .  You needn\'27t acquire ownership of sound-out to set the playback attributes.   \
\fs16 \
\fs28 \b snddriver_set_device_parms()\b0  sets three attributes as specified by the values of its boolean arguments:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	The internal speaker is turned on or off as \i speakerOn\i0  is true or false.  Calling the function with alternating true and false \i speakerOn\i0  values is equivalent to toggling the Mute key (Command Mute) on the keyboard. \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	Similarly, the value of \i filterOn\i0  turns the de-emphasis filter on or off.  The filter can be controlled from the keyboard by toggling the louder key while holding down the Command key (this isn\'27t marked on the keyboard).  In addition, the de-emphasis filter is automatically turned on when a de-emphasis format sound is played and returned to its previous state when the sound is done playing. \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	During playback, low sampling rate (22.05 kHz) sounds are converted to the high sampling rate (44.1 kHz) as they are sent to the DAC (which converts data at 44.1 kHz only).  To do this, the sound driver emits an extra sample for every existing sample in the sound data.  The value of\i  zerofill\i0  determines whether these extra samples are set to 0 (true) or if they\'27re copies of the existing samples (false).  In almost all cases, copying the samples is preferable since zerofilling results in a decrease in power.  Note that you can\'27t toggle this attribute from the keyboard.  Also, keep in mind that CODEC rate sounds are converted to 22.05 kHz before being sent to the DAC and so are also affected by the state of \i zerofill\i0 . \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_get_device_parms()\b0  returns, by reference in its final three arguments, the values of the attributes described above. \
\fs16 \
\fs28 \b snddriver_set_volume()\b0  sets the volume of the internal speaker and similarly adjusts the signal that\'27s sent to the stereo headphone jack (the signal to the line-out jacks is unaffected).  The two channels of the stereo signal are set independent of each other,  specified as the values of \i leftSpeaker\i0  and \i rightSpeaker.  \i0 The\i  \i0 volume of the internal speaker is the sum of these two values.  Volume values are integers in the range 0 to 43, inclusive, where 0 is inaudible and 43 is full blast.  You can also adjust playback volume by pressing the speaker-louder and speaker-softer keys on the keyboard.  Each discrete tap on a volume key increments or decrements both the left and the right volume settings by 1.  \
\fs16 \
\fs28 \b snddriver_get_volume()\b0  returns the left and right playback volumes by reference in \i leftVolume\i0  and \i rightVolume\i0 , respectively.  \
\fs16 \
\fs28 \b \b0 By default,\b  \b0 sounds are ramped during playback:  The first few samples are ramped up from zero and the last samples are ramped down.  This helps prevent clicks at the beginnings and ends of sounds. \b  snddriver_set_ramp() \b0 enables or disables this feature as its \i rampOn\i0  argument is nonzero or zero.  You almost always want ramping enabled; the one obvious case in which it\'27s undesirable is if you\'27re chaining a series of separate sounds that are meant to be played seamlessly, one immediately after the other.  In this case, ramping will cause annoying amplitude dips at each seam.\
\fs16 \
\fs28 \s9 \li2116 \fi503 \fi0 \fs16 \
\fs28  RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \b \fs36 \fs16 \
\
\
\
\fs36 snddriver_set_dsp_owner_port(), snddriver_set_sndin_owner_port(), snddriver_set_sndout_owner_port()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Acquire ownership of sound resources \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_set_dsp_owner_port(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 \b port_t \b0 \i ownerPort\i0 ,\b  \b0 port_t\b  \b0 \i *negotiationPort\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_set_sndin_owner_port(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 \b port_t \b0 \i ownerPort\i0 ,\b  \b0 port_t\b  \b0 \i *negotiationPort\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_set_sndout_owner_port(\b0 port_t\b  \b0 \i devicePort\i0 , \
\fi0 \b port_t \b0 \i ownerPort\i0 ,\b  \b0 port_t\b  \b0 \i *negotiationPort\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 These functions try to acquire ownership of the DSP, sound-in, or sound-out by setting the resource\'27s owner port to a port that you supply.  They duplicate part of the functionality provided by \b SNDAcquire()\b0 ; the latter should, in most cases, be used to the exclusion of these. \
\fs16 \
\fs28 The arguments are the same for all three functions:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i devicePort\i0  is a valid port to the sound driver device, as acquired through \b SNDAcquire()\b0 . \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\i ownerPort\i0  is the port that will become the owner port for the requested resource if the function is successful.  You must have already allocated \i ownerPort\i0  through the  function \b port_allocate()\b0 .\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	If the function successfully acquires ownership of the resource, then the port pointed to by \i negotiationPort\i0  is registered as the negotiation port for the resource.  However, if the function isn\'27t successful\'d0most likely because ownership of the resource has already been claimed\'d0then the currently registered negotiation port is returned in the\i  negotiationPort\i0  argument.  By convention you point \i negotiationPort\i0  to \i ownerPort \i0 before calling these functions, thereby making the owner port accessible to other tasks.  Similarly, if your bid for ownership fails and the current owner has followed this convention, then you can use the port returned in \i negotiationPort\i0  as the owner port for the resource.  Note, however, that if the function call fails, there\'27s no way to determine if the port pointed to by \i negotiationPort\i0  is actually the owner port.   If you want to acquire sole ownership of a resource, set \i negotiationPort\i0  to something other than the \i ownerPort\i0  before calling these functions.  This will ensure that only the caller will have access to the resource (assuming that the function is successful).  \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 A single port can be used to claim ownership of more than one device.  This is sometimes necessary when setting up a multiple-device stream (as explained in \b snddriver_stream_setup()\b0 ).  In the following example, the same port attempts to own both the DSP and sound-out:\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 \tx3729 \tx4334 \tx4939 \tx5544 \tx6148 \tx6753 \tx7358 \tx7963 \tx8568 \tx9172 \tx9777 \tx10382 \tx10987 \tx11592 \tx12196 \tx12801 err = port_allocate(task_self(), &ownerPort)\
\fi0 . . .\
\fi0 \
\fi0 /* Acquire ownership of the DSP. */   \
\fi0 err=snddriver_set_dsp_owner_port(devPort, ownerPort, &negPort);\
\fi0 . . . \
\fi0 \
\fi0 /* Acquire ownership of sound-out. */   \
\fi0 err=snddriver_set_sndout_owner_port(devPort,ownerPort,&negPort);\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 After you\'27ve claimed ownership of a resource, you should do something with it.  With  sound-in you set up a stream port through which you read (record) data.  This is done by calling the \b snddriver_stream_setup()\b0  and \b snddriver_stream_start_reading()\b0  functions.  Analogously, with sound-out you set up a stream through which you write (playback) data through the  \b snddriver_stream_start_writing()\b0  function.\
\fs16 \
\fs28 If you claim ownership of the DSP you should also acquire the DSP command port by calling \b snddriver_get_dsp_cmd_port()\b0 .  Most of the functions that access the DSP require the command port as an argument.  You can also set up streams to the DSP as you would to sound-in or sound-out.  Successfully setting the DSP\'27s owner port puts the DSP in its reset state.\
\fs16 \
\fs28 To relinquish ownership of a resource, you deallocate the owner port by calling \b port_deallocate():  \
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \b0 \fs24 \tx3729 \tx4334 \tx4939 \tx5544 \tx6148 \tx6753 \tx7358 \tx7963 \tx8568 \tx9172 \tx9777 \tx10382 \tx10987 \tx11592 \tx12196 \tx12801 err = port_deallocate(task_self(), ownerPort);\
\tx3729 \tx4334 \tx4939 \tx5544 \tx6148 \tx6753 \tx7358 \tx7963 \tx8568 \tx9172 \tx9777 \tx10382 \tx10987 \tx11592 \tx12196 \tx12801 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 Deallocating a resource\'27s owner unregisters the resource\'27s negotiation port.  All ports are automatically deallocated when your application exits.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28   RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_setup()\b0 , \b snddriver_get_dsp_cmd_port()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_set_ramp() \f3 \b0 \'ae\f1  \b snddriver_set_device_parms() \
\fs16 \
\fs36 \s6 \fs16 \fs36 snddriver_set_sndin_owner_port() \f3 \b0 \'ae\f1  \b snddriver_set_dsp_owner_port()\
\fs16 \
\fs36 \s32 \fs16 \
\
\
\
\fs36 snddriver_set_sndout_bufcount(), snddriver_set_sndout_bufsize(), snddriver_stream_ndma()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Configure stream transfer buffers \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_set_sndout_bufcount(\b0 port_t\b  \b0 \i devicePort\i0 ,\b \b0  port_t\b  \b0 \i sndoutPort\i0 , \b int \i count\i0 )\
\b0 kern_return_t \b snddriver_set_sndout_bufsize(\b0 port_t\b  \b0 \i devicePort\i0 ,\b \b0  port_t\b  \b0 \i sndoutPort\i0 , \b int \i size\i0 )\
\b0 kern_return_t \b snddriver_stream_ndma(\b0 port_t\b  \b0 \i streamPort\i0 ,\b \b0  int\b  \b0 \i tag\i0 , \b \b0 int\b \b0  \b \b0 \i count\b \i0 )\
\s9 \li2116 \fi503 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 These functions let you control the number and size of the buffers that are used to transfer data in a stream.   \
\fs16 \
\fs28 \b snddriver_set_sndout_bufcount()\b0  sets the number of buffers that are used when playing back sounds; the \i count\i0  argument, which must be greater than 0, establishes the buffer count.  Four buffers are used in the default configuration.  \
\fs16 \
\fs28 \b snddriver_set_sndout_bufsize() \b0 sets the size of the sound-out buffers (in bytes) to the value of the \i size\i0  argument.  This function is only needed if you\'27re using a linked stream to sound-out (see the \b snddriver_stream_setup()\b0  function for more on linked streams).  The value of \i size\i0  must be less than or equal to \b vm_page_size\b0 , the size of a page of virtual memory; the default is \b vm_page_size\b0 .  If you\'27re writing directly to the sound-out stream\'d0in other words if the stream to sound-out is configured as SNDDRIVER_STREAM_TO_SNDOUT_22 or SNDOUT_44\'d0then the size of the sound-out buffers is computed from the \i sampleCount\i0  argument to \b snddriver_stream_setup()\b0  and the size set here is ignored.\
\fs16 \
\fs28 For both of these functions, the\i  devicePort\i0  and \i sndoutPort\i0  arguments are ports to the sound driver device and to sound-out, respectively, as acquired through \b SNDAcquire()\b0 .\
\fs16 \
\fs28 \b snddriver_stream_ndma() \b0 sets the number of DMA transfer buffers that are used to transmit and receive data that\'27s sent to the DSP.  The DMA buffer count is settable on a region-by-region basis; the stream and region therein to which a particular setting applies are identified by the \i streamPort\i0  and \i tag\i0  arguments, respectively.   This function only applies to simple streams to or from the DSP; if you set up a linked stream to sound-out, then the DMA buffer count to and from the DSP is the same as the sound-out buffer count.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_setup(), snddriver_stream_ndma()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_set_sndout_bufsize() \f3 \b0 \'ae\f1  \b snddriver_set_sndout_bufcount()\
\fs16 \
\fs36 \s6 \fs16 \fs36 snddriver_set_sndout_owner_port() \f3 \b0 \'ae\f1  \b snddriver_set_dsp_owner_port()\
\fs16 \
\fs36 \fs16 \fs36 snddriver_set_volume() \f3 \b0 \'ae\f1  \b snddriver_set_device_parms()\
\fs16 \
\fs36 \s32 \fs16 \
\
\
\
\fs36 snddriver_stream_control(), snddriver_stream_nsamples()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Control and query a stream\
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_stream_control(\b0 port_t\b  \b0 \i streamPort\i0 ,\b \b0  int\b  \b0 \i tag\i0 , \b \b0 int\b \b0  \b \b0 \i control\b \i0 )\
\b0 kern_return_t \b snddriver_stream_nsamples(\b0 port_t\b  \b0 \i streamPort\i0 ,\b  \b0 int *\b \b0 \i byteCount\b \i0 )\
\s9 \li2116 \fi503 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_control()\b0  provides control over an active stream by allowing you to apply a controlling operation to one or more of the stream\'27s enqueued regions.  The stream and the regions\i  \i0 therein are identified by the function\'27s first two arguments:  \i  streamPort \i0 is the stream\'27s port, as created by \b snddriver_stream_setup()\b0 ; \i tag \i0 is the integer identifier that you gave the region (or regions) in a previous call to \b snddriver_stream_start_writing()\b0  or \b snddriver_stream_start_reading()\b0 .  A tag value of 0 causes the controlling operation to be applied to all regions enqueued on the stream.  \i control\i0  specifies the controlling operation by the following constants:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_PAUSE_STREAM causes the stream to pause.  If data is currently being read from or written to the specified region, the read or write is immediately suspended.  If the region isn\'27t yet active, the pause takes effect when the region comes to the top of the stream\'27s queue (it\'27s paused just before the first sample is read or written). \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_RESUME_STREAM resumes a previously paused stream.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_ABORT_STREAM terminates the stream\'27s activity when the specified region comes to the top of the queue; the queue is then cleared. If the region is currently being acted upon, the stream is terminated immediately.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	SNDDRIVER_AWAIT_STREAM is used to retrieve a partially-recorded region from a stream that\'27s reading data\'d0normally, you can\'27t retrieve such data until the entire region has been filled.  If the specified region is currently active, a data-recorded message is sent to the reply port that you registered in \b snddriver_stream_start_reading()\b0 .  You then pass the message to \b snddriver_reply_handler() \b0 which calls the \b recorded_data\b0  reply handler.  The unrecorded portion of the region continues.  If the specified region isn\'27t currently active, this has no effect.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 While you can use any of these four at the same time by \b or\b0 \'27ing them in \i control\i0 , the only combination that\'27s of use is SNDDRIVER_AWAIT_STREAM \b or\b0 \'27d with one of the other three.   For example, by setting \i tag\i0  to 0 and \i control\i0  to\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 SNDDRIVER_PAUSE_STREAM | SNDDRIVER_AWAIT_STREAM\
\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 you immediately pause the stream and can then bring back data from the current region.  \
\fs16 \
\fs28 You can request that a stream-paused, stream-resumed, or stream-aborted message be sent to the reply port when you pause, resume, or abort a stream, respectively, by setting the appropriate \i msg...\i0  flag to true in your call to\b  snddriver_stream_start_...()\b0 .  \
\fs16 \
\fs28 \b snddriver_stream_nsamples()\b0  returns the number of bytes (\i not\i0  samples, despite the name of the function) that have been read from or written to a particular stream.  The steam is specified by \i streamPort\i0 .  The byte count is returned by reference in the \i byteCount\i0  argument.\
\fs16 \
\fs28 \s9 \li2116 \fi503 \fi0 \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_setup(), snddriver_stream_start_writing(), snddriver_stream_start_writing(), snddriver_reply_handler()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_stream_nsamples() \f3 \b0 \'ae\f1  \b snddriver_stream_control()\
\fs16 \
\fs36 \fs16 \
\
\
\
\fs36 snddriver_stream_setup()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Configure a sound stream \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_stream_setup(\b0 port_t\b  \b0 \i devicePort\i0 , \b \b0 port_t\b  \b0 \i ownerPort\i0 ,\b \b0  \b \b0 \
\fi0 int\b  \b0 \i dataPath\i0 ,\b \b0  int\b  \b0 \i sampleCount, \b \i0 \b0 int\b \b0 \i  sampleSize, \b \i0 \b0 int\b \b0 \i  lowWater, \b \i0 \b0 int\b \b0 \i  highWater,\b \i0 \b0 \i \
\fi0 \i0 int \i *protocol\i0 , port_t \i *streamPort\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 A stream, as it applies to the sound driver, is a path through which an indefinitely long sequence of data passes.  One end of a sound driver stream lies, typically, in your application\'27s memory, while at the other end is a sound device.  For example, to record a sound from the microphone you create a stream from sound-in to your application.  Analogously, a stream from your application to sound-out is required to play back sound data.  A single stream of data can pass through more than one sound device; for example, you can send data from your application to the DSP from whence it issues directly to sound-out.  Thus you can DSP-process and play your sound data in one motion, without incurring the overhead of bringing the processed data back into your application.\
\fs16 \
\fs28 \b The snddriver_stream_setup() \b0 function creates a port to a sound stream.   The port, returned in the \i streamPort\i0  argument, is used as an identifier in subsequent calls to functions that write to, read from, and otherwise control the stream (as listed at the end of this description).    \
\fs16 \
\fs28 The function\'27s first two arguments are the usual capability ports: \i  devicePort\i0  is a port to the sound driver device and \i ownerPort\i0  is the owner port for \i all\i0  resources that are touched by the stream, as acquired through \b SNDAcquire()\b0 .\
\fs16 \
\fs28 You establish the stream\'27s course\'d0the souce and destination of its data\'d0by setting \i dataPath\i0  to one of constants listed below.  The \'aasimple\'ba data paths connect your application to a sound resource:  \
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	SNDDRIVER_STREAM_FROM_SNDIN; read samples from the CODEC microphone.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	 SNDDRIVER_STREAM_TO_SNDOUT_44; write samples to the stereo DAC at the high sampling rate (44.1 kHz).\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	 SNDDRIVER_STREAM_TO_SNDOUT_22; write samples to the stereo DAC at the low sampling rate (22.05 kHz).\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	SNDDRIVER_DMA_STREAM_TO_DSP; write data via DMA to the DSP.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	SNDDRIVER_DMA_STREAM_FROM_DSP; read data via DMA from the DSP.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 There are also four \'aalinked\'ba paths that connect the DSP directly to sound-out:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	SNDDRIVER_STREAM_DSP_TO_SNDOUT_44 and ...SNDOUT_22; DSP-processed samples are sent directly to sound-out at the low or high sampling rate.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	SNDDRIVER_DMA_STREAM_THROUGH_DSP_TO_SNDOUT_44 and ...SNDOUT_22; data flows from your application to the DSP and thence directly   to sound-out at the high or low sampling rate.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Data is transferred through a stream in buffers.  The \i sampleCount\i0  argument establishes the length of a single transfer buffer in samples (or data elements); the size of a single sample is set by the \i sampleSize\i0  argument.  The maximum size for a transfer buffer (in bytes) is that of a page of virtual memory, as given by the global read-only variable \b vm_page_size\b0 .  Typically, the transfer buffer size is set to this limit:  If, for example, the samples that you\'27re sending through the stream are two bytes wide, then, to follow this convention, you would set \i sampleCount\i0  to \b vm_page_size\b0 /2.  If the stream uses DMA, then the size of a transfer buffer (in bytes) must be a power of 2 greater than or equal 16.  \
\fs16 \
\fs28 For some applications\'d0particularly those in which latency is an issue\'d0setting the number of transfer buffers that are used can be as important as setting the size of the buffers.  This is done through the \b snddriver_set_sndout_bufcount()\b0  and \b snddriver_stream_ndma()\b0  functions.\
\fs16 \
\fs28 The range of acceptable values for the \i sampleSize\i0  argument depends on the stream\'27s data path:  \
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	If you\'27re reading from sound-in into your application (SNDDRIVER_STREAM_FROM_SNDIN), then \i sampleSize\i0  must be set to 1 to accommodate the 8-bit mu-law samples generated by the CODEC microphone input.  \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	If you\'27re writing from your application to sound-out (SNDDRIVER_STREAM_TO_SNDOUT_44/22) or from\i  \i0 the DSP\i  \i0 to sound-out\i  \i0 (SNDDRIVER_STREAM_DSP_TO_SNDOUT_44/22), then\i  sampleSize\i0  must be 2 since the DAC expects 16-bit interleaved-stereo samples.  Note that while the DAC only processes data at the high sampling rate, the sound driver performs the conversion from low to high for you.  This isn\'27t true for playback of CODEC-rate sounds for which you typically download a sampling-rate conversion program to the DSP, and then create a stream that goes through the DSP and then directly to sound-out.  This is what the \b SNDStartPlaying()\b0  function does, for example. \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4636 \tx6148 \fs16 \fs28 \'b7	In all the other paths, your application writes to or read from the DSP.  Here, \i sampleSize\i0  can be 1, 2, or 4, according to the sample size expected by or produced by your DSP program. \
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 The \i lowWater\i0  and \i highWater\i0  arguments are memory threshhold values, measured in bytes, that are inspected by the sound driver.  During an operation such as recording or playback, successive pages of sound data are locked into physical memory (or \'aawired down\'ba) during which time they\'27re read from or written to.  As a page is completed, it\'27s unwired.  The driver tries to maintain at least \i lowWater\i0  bytes of wired-down memory; if the amount drops below this threshhold, the driver wires down pages until it reaches the \i highWater\i0  mark. \
\fs16 \
\fs28 If your stream touches the DSP, then you need to\i  \i0 set the DSP protocol by passing the appropriate value to\b  snddriver_dsp_protocol()\b0 .\i   \i0 The\i  protocol\i0  argument found here helps you create this value:  The function \b or\b0 \'27s the appropriate protocol constants, as determined by the characteristics of the stream that you\'27re setting up, into \i protocol\i0  and returns the new value by reference.   You then pass the variable to \b snddriver_dsp_protocol()\b0 .  You should initialize your protocol variable to SNDDRIVER_DSP_PROTO_RAW before calling \b snddriver_stream_setup()\b0 , as shown in the following example:\
\fs16 \
\fs28 \pard \s24 \li3124 \fi0 \ri1007 \ql \f2 \fs24 /* Initialize the protocol variable. */\
\fi0     int protocol = SNDDRIVER_DSP_PROTO_RAW;\
\fi0     int err;\
\fi0 \
\fi0     /* Set up a stream to the DSP. */\
\fi0     err = snddriver_stream_setup(..., SNDDRIVER_STREAM_TO_DSP,\
\fi0                                     .., &protocol, ...);\
\fi0     if (err != 0) \
\fi0     . . .   \
\fi0 \
\fi0     /* Set up a stream from the DSP. */\
\fi0     err = snddriver_stream_setup(..., SNDDRIVER_STREAM_FROM_DSP,\
\fi0                                     ..., &protocol, ...);\
\fi0     if (err != 0) \
\fi0     . . .   \
\fi0 \
\fi0     /* Pass the protocol to the sound driver. */\
\fi0     err = snddriver_dsp_protocol(..., protocol);\
\fi0     if (err != 0) \
\fi0     . . .\
\fi0 \
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \f1 \fs28 The protocol constants are described as part of the \b snddriver_dsp_protocol()\b0  function.\
\fs16 \
\fs28 Having created a stream, you can read from it, write to it, and control it by passing the port returned in\i  streamPort\i0  to the following functions:\
\fs16 \
\fs28 \pard \s14 \li2620 \fi-503 \ri1007 \ql \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b snddriver_stream_start_reading()\b0  and\b  snddriver_stream_start_writing() \b0 read from and write to a stream, respectively.  Streams from sound-in or from the DSP can only be read; similarly, streams to sound-out or to the DSP can only be written. \
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b snddriver_stream_control() \b0 pauses, resumes, and aborts an active stream.\
\fs16 \
\fs28 \li2620 \fi0 \fi-503 \li3124 \fi-1007 \fi-503 \tx3124 \tx3628 \tx4132 \tx4636 \fs16 \fs28 \'b7	\b snddriver_stream_nsamples() \b0 measures the amount of data that has passed through the stream.\
\fs16 \
\fs28 \pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 For sound-in and sound-out, streams are the only way to travel.  This isn\'27t true of the DSP; the sound driver provides a one-shot, non-stream DSP read and write mechanism, embodied in \b snddriver_dsp_read()\b0 , \b snddriver_dsp_dma_read()\b0 , and analogous \b ...write()\b0  functions, that can be more efficient for short data transfers.   \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_stream_start_reading()\b0 , \b snddriver_stream_start_writing(), snddriver_set_sndout_bufcount(), snddriver_stream_ndma()\
\fs16 \
\fs28 \pard \s32 \li1108 \fi0 \ri1007 \ql \fs36 \fs16 \
\
\
\
\fs36 snddriver_stream_start_reading() \f3 \b0 \'ae\f1  \b snddriver_stream_start_writing()\
\fs16 \
\fs36 \fs16 \
\
\
\
\fs36 snddriver_stream_start_writing(), snddriver_stream_start_reading()\
\fs16 \
\fs36 \pard \s22 \li4636 \fi-2520 \ri1007 \ql \tx4636 \b0 \fs28 \fs16 \
\fs28 SUMMARY	Send data to and retrieve data fom a stream  \
\fs16 \
\fs28 \s0 \fs16 \fs28 LIBRARY	libsys_s.a\
\fs16 \
\fs28 \pard \s33 \li2116 \fi0 \ri1007 \ql \fs16 \fs28 SYNOPSIS\
\pard \s5 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b #import <sound/sounddriver.h>\
\fs16 \
\fs28 \pard \s11 \li3124 \fi-503 \ri1007 \ql \b0 \b kern_return_t snddriver_stream_start_writing(\b0 port_t \b \b0 \i streamPort\b \i0 \b0 ,\b \b0 \
\fi0 void \i *data\i0 ,\b  \b0 int\b  \b0 \i sampleCount\b \i0 , \b0 int \i tag\i0 ,\b  \
\fi0 \b0 boolean_t  \i preempt\i0 , boolean_t \i deallocateWhenDone\i0 ,\b  \
\fi0 \b0 boolean_t \i msgStarted, \i0 boolean_t \i msgCompleted\i0 , boolean_t \i msgAborted\i0 , \
\fi0 boolean_t \i msgPaused, \i0 boolean_t \i msgResumed, \i0 boolean_t \i msgUnderrun, \
\fi0 \i0 port_t \i replyPort\b \i0 )\
\fi-503 \b0 \b kern_return_t snddriver_stream_start_reading(\b0 port_t \b \b0 \i streamPort\b \i0 \b0 ,\b \b0 \
\fi0 char \i *filename\i0 ,\b  \b0 int\b  \b0 \i sampleCount\b \i0 , \b0 int \i tag\i0 ,\b  \
\fi0 \b0 boolean_t \i msgStarted, \i0 boolean_t \i msgCompleted\i0 , boolean_t \i msgAborted\i0 , \
\fi0 boolean_t \i msgPaused, \i0 boolean_t \i msgResumed, \i0 boolean_t \i msgOverrun, \
\fi0 \i0 port_t \i replyPort\b \i0 )\
\s9 \li2116 \fi0 \b0 \fs16 \
\
\fs28 DESCRIPTION\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 These two functions cause data to be written to or read from a sound stream identified by \i streamPort\i0 , which must have been created by a previous call to \b snddriver_stream_setup()\b0 .  The two functions operate in much the same manner:  Each invocation enqueues a single region of data that\'27s operated on (either read from or written to) asynchronously by the sound driver.  However, there\'27s a fundamental difference between the two functions in that  \b ...writing()\b0  enqueues a region that you pass as the \i data\i0  argument, while\b  ...reading()\b0  stores the data that it reads in a region that it allocates itself.  To bring the read data back into your application, you must create and register a reply-handler function that transfers the data when the read is complete.  The mechanism for doing this is explained (and an example given) in the \b snddriver_reply_handler()\b0  function description.   Note that the \b ...reading()\b0  argument \i filename\b \i0 \i \'d0\i0 which would imply that the read data is written to a file\'d0is currently unused.  Also note that \b0 \i data\i0  is copy-on-write protected:  Any changes that you make to the data after the region has been passed to \b ...writing()\b0  won\'27t be seen by the driver. \
\fs16 \
\fs28 \i sampleCount\i0  is the number of samples in the region that\'27s being written or read.  If you\'27re writing to the DSP, \i sampleCount\i0  must be a multiple of the \i sampleCount\i0  argument to\b  snddriver_stream_setup()\b0 .  In all other cases, \i sampleCount\i0  can be any value.\
\fs16 \
\fs28 \i tag \i0 is an integer that\'27s used to identify the region.  While you can give each region a distinct tag, you usually create a single tag value for each stream that you set up.  For example, if you have a stream that reads data from sound-in and another that writes to sound-out, you would create two tag values, one for either stream, and then tag each region with the value associated with its stream.   \
\fs16 \
\fs28 If the \i preempt\i0  flag (\b ...writing()\b0  only) is true, the sound driver starts writing \i data\i0  immediately after the current transfer buffer has been completely processed.  When it\'27s finished with the preempting region, the driver returns to its region queue, disregarding the rest of the partially-processed preempted region.\
\fs16 \
\fs28 If \i  deallocateWhenDone\i0  (\b ...writing()\b0  only) is true, the region\'27s data is deallocated after it\'27s written.\
\fs16 \
\fs28 The six\i  msg...\i0  flags register requests for stream-state messages to be sent asynchronously to the port \i replyPort\i0 .  The first flags, \i msgStarted\i0  and \i msgCompleted\i0 , if true, cause messages to be sent just as the driver begins its first and just after it finishes its last transfer of data from the region\i , \i0 respectively.  The conditions referred to by the next three arguments, \i msgAborted\i0 , \i msgPaused\i0 , and \i msgResumed\i0 , occur as a result of calls to \b snddriver_stream_control()\b0 .  The \i msgUnderrun\i0  (for \b ...writing()\b0 ) or \i msgOverrun \i0 (for \b ...reading()\b0 ) arguments, if true, causes a message to be sent if the driver can\'27t transfer data quickly enough to keep up with real time.  In general this is only signficant if data is being read from sound-in or written to sound-out:  Underrun results in brief pauses in playback; overrun causes incoming samples to be lost.  You normally process the asynchronous messages that you receive by passing them to the \b snddriver_reply_handler()\b0  function\
\fs16 \
\fs28 A working example that shows a typical set up for reading and writing streams is given in \b /NextDeveloper/Examples/DSP/SoundDSPDriver/dsp_example_3/\b0 . \
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28  RETURN\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 Returns an error code:  0 on success, nonzero on failure.\
\fs16 \
\fs28 \pard \s9 \li2116 \fi0 \ri1007 \ql \fs16 \
\fs28 SEE ALSO\
\pard \s2 \li2620 \fi0 \ri1007 \ql \tx3124 \tx3628 \tx4132 \b snddriver_reply_handler, snddriver_stream_setup\
\fs16 \
\fs28 \pard \s3 \li2116 \fi0 \ri1007 \ql \tx2116 \tx2620 \tx3124 \tx3628 \b0 \fs16 \fs28 \
\fs16 \
\fs28 }
