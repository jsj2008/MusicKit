/*
  $Id$
  
  Defined In: The MusicKit
  Description:
    See discussion. 

  Original Author: David A. Jaffe

  Copyright (c) 1996 Stanford University.
  Portions Copyright (c) 1999-2001, The MusicKit Project.
*/
// classgroup Envelope Handlers and Followers
/*!
  @class AsympenvUG
  @brief <b>AsympenvUG</b> is similar to <b>AsympUG</b>, except
  that it loads the entire envelope down to the DSP, providing better real-time performance.
  
AsympenvUG is an MKEnvelope handler that plays a MusicKit MKEnvelope on the DSP. It
is very similar to AsympUG and has almost the same Objective C protocol.
However, unlike AsympUG, which feeds the MKEnvelope to the DSP one segment at a
time, AsympenvUG loads the entire MKEnvelope (actually, tables derived from the
MKEnvelope data) into DSP memory. This means AsympenvUG is more well-suited to
critical interactive real-time applications, such as playing a MIDI keyboard and
hearing sound immediately. It also means that there is a limit to the length of
the envelopes it can handle, since there is a limited amount of DSP memory. In
practice, envelopes are not usually very long, so this restriction is usually
not a problem. In short, it is usually best to use AsympenvUG if critical
interactive real-time is a concern, but AsympUG is better for situations with
very long MKEnvelopes or where real-time response is not an issue.

AsympenvUG objects are normally used to provide dynamic scaling of a musical
attribute.  To this end, the output of an AsympenvUG is typically connected to
the frequency or amplitude input of an OscgafiUG object or used as input to an
InterpUG, Mul2UG, ScaleUG, etc. Although typically used to convey Envelopes,
AsympUG may also be used as a simple exponential ramper, without an explicit
MKEnvelope object. Methods are provided that let you set the rate directly, or as
a time limit (referred to as  &ldquo;T60&rdquo;) that defines when the target
will have been perceptually reached.  

For each MKEnvelope segment, AsympenvUG creates an exponential signal that
approaches a limit (the &ldquo;target&rdquo;) at a particular rate, where the
rate expresses the precentage of the remaining journey that's taken with each
step:
	
<i>output</i> = <i>previousOutput</i> + (<i>rate</i> * (<i>target - previousOutput</i>))	
<i>previousOutput</i> = <i>output</i>

For example, if the rate is 0.1 and the target is 1.0, the samples generated by
the AsympUG are
	
0.1, 0.19, 0.271, 0.343, 0.409, 0.4685, ...

Exponential envelopes have the advantage of being "self-limiting". That is, 
they seek their targets from any starting point. This allows for efficient
implementation of long connected MKEnvelope "phrases", one of the primary
advantages of the MusicKit's MKNote representation. In addition, if, for some
reason, the host processor gets a little bit behind, due to time-sharing, the
envelope will not continue unbounded toward disaster. 
 
MKEnvelope data is mapped onto the exponential representation as follows:

The MKEnvelope's yArray[n] is the target, considered to be in the infinite
future. The MKEnvelope's xArray[n] is the time of the right-hand side of the
segment (i.e. the time to interrupt the trajectory toward yArray[n]). The
MKEnvelope's smoothingArra[n] is the smoothing constant to get to yArray[n]. If
smoothingArra[n] is 0, the point  is reached immediately. If smoothingArra[n] is
1.0, the point is reached,  within about -48dB at the time of the next update.
If smoothingArra[n] is larger, the point is not reached within -48dB by the time
of the next update. A value of smoothingArra[n] of infinity will cause the
envelope to never change value. The first point, xArray[0], is assumed to be the
right-hand side of the non-existant first segment. yArray[0] is the initial
point (which may or may not be used, depending on the value of the instance
variable useInitialvalue (see below)). smoothingArra[0] is ignored. 

The envelope has a "stick point". When the envelope handler reaches the stick
point, it does not proceed to the next point until it receives the
<b>-finish</b> message. If there is no stick point, the <b>-finish</b> message
is ignored. If the envelope handler has not yet reached the stick point when the
<b>-finish</b> message is received, the envelope handler proceeds to the first
point after the stick point and continues from there.  

MusicKit MKEnvelopes are usually associated with a set of parameters, such as
attackTime, releaseTime, etc. The C function <b>MKUpdateAsymp()</b> is provided
to conveniently manage setting the AsympUG's attributes according to a given
MKEnvelope and a set of MKNote parameters. By using <b>MKUpdateAsymp()</b>, you need
only set the AsympenvUG's output patchpoint; all other methods are invoked for
you.  For more information, see the Class Description for the MKEnvelope
class.

As with AsympUG, you should not change the contents of a MusicKit MKEnvelope
object while an AsympenvUG is using it. Furthermore, MKEnvelope data is cached on
the DSP and referenced using the MKEnvelope object id for speed and efficiency.
This has the advantage of allowing several AsympenvUGs to share MKEnvelope data
and avoids wasting DSP memory. However, this also implies that if you change the
data in an MKEnvelope object, these changes may not take effect, because the MusicKit
continues to use the old representation. Therefore, if you do change an
MKEnvelope's data, you should send the message <b>+envelopeHasChanged:</b>,
passing the MKEnvelope object as the argument. Also, you should not free any
MKEnvelope objects that have been used in a MusicKit performance until the
MKOrchestra has been closed. Otherwise, a re-used id may cause the AsympenvUG to
use an incorrect cached MKEnvelope.

There are a few other differences between AsympUG and AsympenvUG:

<ul>
<li> The methods <b>-setYScale:yOffset:</b> and <b>-setReleaseXScale:</b> have
no effect. They are included only for compatability with <b>MKUpdateAsymp()</b>.
This implies that it is not possible to change the scale and offset of an
MKEnvelope that is in progress.</li>

<li> TransitionTime, which is specified in the method 
-<b>resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:</b>, is currently ignored.
It is included only for compatability with <b>MKUpdateAsymp()</b>.</li>
</ul>
 
<h2>Memory Spaces</h2>

<b>AsympenvUG<i>a</i></b>
<i>a</i>	output 
*/

#import <MusicKit/MusicKit.h>

@interface AsympenvUG: MKUnitGenerator
{
    id anEnv;
    double (*scalingFunc)(); 
    double timeScale;            
    double releaseTimeScale;      
    double yScale;                
    double yOffset;               
    double targetX;               
    char useInitialValue;         
    int stickPoint; 
    DSPDatum firstVal;
    double releaseTime;
    double envTriggerTime;
    MKSynthData *durMem,*targetMem,*rateMem; 
    double _transitionTime;
    double _samplingRate;
    double _smoothConstant;
    int _tickRate;
}

+ (void) envelopeHasChanged: (MKEnvelope *) env;  
+ (void) freeKeyObjects; 

/*!
  @brief Sets the output patchpoint to <i>aPatchPoint</i>.
  @param  aPatchPoint is an id.
  @return Returns <b>self</b>, or <b>nil</b> if the argument isn't a patchpoint.
*/
- setOutput: (id) aPatchPoint;

/*!
  @brief Sets the target to <i>target</i>, which should be between 0.0 and 1.0.

  The new target is simply inserted, overriding the current target.  
  If the object is already  processing an envelope, that envelope is not interrupted.
  @param  target is a double.
  @return Returns <b>self</b>.
*/
- setTargetVal: (double) target;

/*!
  @brief Sets the current value of the AsympenvUG to <i>value</i>.

  The new value overrides the previous sample as shown in the computation in
  the class description above.  If the object is already processing
  an envelope, that envelope is not interrupted.
  @param  value is a double.
  @return Returns <b>self</b>.
*/
- setCurVal: (double) value;

/*!
  @brief Sets the rate at which the AsympenvUG approaches its target, where
  <i>rate</i> is the percentage of the remaining journey that's
  stepped off at each sample.

  The value of <i>rate</i>, which should be between 0.0 and 0.125.
  (It should be between 0.0 and 1.0, but for historical reasons the
  outer limit stands at 0.125.  In any case, a rate of 0.125 means
  that the target is virtually reached in less than two ticks, which is quite fast).
  More precisely, this method sets the rate of the exponential. (1-e^T/tau), where T is
  sampling period and tau is the time constant.If the AsympenvUG is
  already processing an MKEnvelope, the new rate is simply inserted,
  overriding the current value, and the MKEnvelope proceeds otherwise
  unaffected.  
  @param  rate is a double.
  @return Returns <b>self</b>.
  @see -<b>setT60:</b>
*/
- setRate: (double) rate;

/*!
  @brief Computes the AsympUG's rate such that the target is perceptually
  reached (to within -60dB of the target) in <i>seconds</i> seconds.
  @param  seconds is a double.
  @return Returns <b>self</b>.
  @see -<b>setRate:</b>
*/
- setT60: (double) seconds;

/*!
  @brief Causes the AsympenvUG to head for the last breakpoint in its
  MKEnvelope, using a rate that's computed from the value set through
  the <b>MKSetPreemptDuration()</b> function (the default preempt
  duration is 0.006 seconds).

  This method is invoked automatically by a MKSynthInstrument object when
  it preempts a MKSynthPatch that contains AsympenvUG objects.
  @return Returns an id.
*/
- preemptEnvelope;

/*!
  @brief Associates the AsympenvUG with the given MKEnvelope and arguments.

  When the AsympenvUG is run, it automatically schedules the
  breakpoints from its MKEnvelope to be fed to itself through message
  requests with the clockConductor.  If this method is invoked while
  the AsympenvUG is running, the object's current value is immediately
  set to the (scaled and offset) y value of the first breakpoint in
  the new MKEnvelope.   When continuity is desired with the previous
  invocation, use the <b>resetEnvelope:...</b> method instead.
  
  The <i>yScaleValue</i> and <i>yOffsetValue</i>
  arguments scale and offset the AsympenvUG target values as each
  breakpoint is reached;  <i>xScaleValue</i> and <i>releaseXScaleValue</i>
  modify the rate before and after the MKEnvelope's stickpoint is reached, respectively.  
  
  The <i>yScaleFunction</i> argument is a pointer to an
  optional function that performs additional, possibly dynamic, target
  scaling.  The fuction takes two arguments, a <b>double</b> that
  gives the AsympenvUG's current value, and the object's <b>id</b>. 
  The function is called once for each breakpoint.  
  
  Typically, you call the <b>MKUpdateAsymp()</b>
  function rather than invoking this method.  The function provides a
  slightly easier interface to AsympenvUG management in the context of
  a MKSynthPatch.
 @param  anEnvelope is an id.
 @param  yScaleValue is a double.
 @param  yOffsetValue is a double.
 @param  xScaleValue is a double.
 @param  releaseXScaleValue is a double.
 @param  yScaleFunction is a pointer to a function returning a double (double(*)()).
 @return Returns an id.
*/
- setEnvelope: (id) anEnvelope
       yScale: (double) yScaleValue
      yOffset: (double) yOffsetValue
       xScale: (double) xScaleValue
releaseXScale: (double) releaseXScaleValue
      funcPtr: (double(*)()) yScaleFunction;
 
/*!
  @brief This method is similar to the <b>setEnvelope:...</b> method but for
  this difference:  If the AsympenvUG is running, its current value
  isn't reset to the new MKEnvelope's first y value; instead, the new
  MKEnvelope's first breakpoint is ignored and the Asymp's rate is
  reset such that it proceeds toward the second breakpoint.

  This affords are more graceful transition into the new MKEnvelope. 
  <i>transitionTime</i>is currently ignored. As with the
  <b>setEnvelope:...</b>  method, you typically call the
  <b>MKUpdateAsymp()</b> function rather than invoke this
  method.
 @param  anEnvelope is an id.
 @param  yScaleValue is a double.
 @param  yOffsetValue is a double.
 @param  xScaleValue is a double.
 @param  releaseXScaleValue is a double.
 @param  yScaleFunction is a pointer to a function returning a double.
 @param  transitionTime is a double.
 @return Returns an id.
*/
-resetEnvelope: (id) anEnvelope
        yScale: (double) yScaleValue
       yOffset: (double) yOffsetValue
        xScale: (double) xScaleValue
 releaseXScale: (double) releaseXScaleValue
       funcPtr: (double(*)()) yScaleFunction
transitionTime: (double) transitionTime;

/*!
  @param  yesOrNo is a BOOL.
  @return Returns an id.
  @brief Controls how the MKEnvelope is handled when it is "retriggered"
  (i.e. <b>run</b> is invoked before the preceeding MKEnvelope has
  finished).
 
  If <i>yesOrNo</i>, the first value of the MKEnvelope is
  set as the AsympenvUG's first output. Otherwise, the AsympenvUG
  continues from whatever its current value happens to be to the
  second point of the MKEnvelope. This method is rarely needed, since
  the same functionality is provided by 
  <b>resetEnvelope:yScale:yOffset:xScale:releaseXScale:funcPtr:transitionTime:</b>.
  It is included as an optimization, when it is known that all parameters are the same.
*/
- useInitialValue: (BOOL) yesOrNo;

/*!
  @brief Has no effect.

  Implemented for compatibility with <b>AsympUG</b>. 
  @param  yScaleValue is a double.
  @param  yOffsetValue is a double.
  @return Returns <b>self</b>.
 */
- setYScale: (double) yScaleValue yOffset: (double) yOffsetValue;

/*!
  @brief Has no effect.

  Implemented for compatability with <b>AsympUG</b>. 
  @param  releaseXScaleValue is a double.
  @return Returns <b>self</b>.
*/
- setReleaseXScale: (double) releaseXScaleValue;

/*!
  @brief Returns the MKEnvelope that's associated with the AsympenvUG, or <b>nil</b> if none.
  @return Returns an id.
*/
- envelope;

/*!
  @brief You never send this message.

  It's invoked by sending the <b>run</b> message to the object.
  Starts the MKEnvelope, if any, on its way.
  @return Returns <b>self</b>.
*/
- runSelf;

- abortSelf;

/*!
  @brief You never send this message.

  It's invoked by sending the <b>idle</b>message to the object.  
  Sets the output patchpoint to <i>sink</i>,<i></i> thus ensuring
  that the object does not produce any output.  Note that you must
  send <b>setOutput:</b> and <b>run</b> again to use the
  MKUnitGenerator after sending <b>idle</b>.
  @return Returns an id.
*/
- idleSelf;

/*!
  @return Returns a double.
  @brief You never invoke this method; it's invoked automatically when the
  AsympenvUG receives the <b>finish</b> message.

  If the object has
  yet to see or is waiting at its MKEnvelope's stickpoint, this causes
  it to head for the first breakpoint after the stickpoint, and then
  on the end of the MKEnvelope.  If the AsympenvUG's MKEnvelope
  contains no stickpoint, this method has no effect. Returns the time
  in seconds until the MKEnvelope is expected to finish, plus a small
  grace time given by <b>MKGetPreemptDuration()</b>. This time may be
  changed by calling  <b>MKSetPreemptDuration()</b>.
*/
-(double)finishSelf;

/*!
  @param arg is an unsigned.
  @return Returns an BOOL.
  @brief Specifies that all arguments are to be optimized if possible except the
  state variable.

  
*/
+ (BOOL) shouldOptimize: (unsigned) arg;

/*!
  @brief Disassociates the AsympenvUG from its MKEnvelope.

  The MKEnvelope sticks on its current value.  
  @return Returns <b>self</b>.
*/
- abortEnvelope;

/*!
  @brief Aborts any running MKEnvelope and sets the AsympenvUG to produce
  <i>val</i> as a constant value.

  Equivalent to invoking <b>abortEnvelope</b>, followed by <b>setTarget:</b><i>val</i>,
  followed by <b>setCurVal:</b><i>val</i>.
  @param  val is a double.
  @return Returns an id.
*/
- setConstant: (double) val;

extern id MKAsympUGxClass(void);
extern id MKAsympUGyClass(void);

/*!
  @brief Apply an Envelope on the DSP

  This is a fairly complicated function that, simply put, does the
  &ldquo;right thing&rdquo; in applying an MKEnvelope object to a
  DSP-synthesized musical attribute during a Music Kit performance.  It's
  designed to be called as part of the implementation of a MKSynthPatch
  subclass.
   
   The <i>asymp</i> argument is an AsympUG object that will handle the
  MKEnvelope on the DSP; <i>envelope</i> is the MKEnvelope object itself. 
  The arguments <i>valueAt0</i>, <i>valueAt1</i>, <i>attackDur</i>, <i>and
  releaseDur</i> scale and stretch the MKEnvelope; their values are
  expected to be taken from an associated group of MKNote parameters.  For
  example, to apply an MKEnvelope to the frequency of a synthesized
  MKNote, the values of these arguments would be retrieved as follows:
     
   <tt>MKEnvelope *envelope = [aNote parAsEnvelope:MK_freqEnv];</tt>
     <tt>double valueAt0 = [aNote parAsDouble:MK_freq0];</tt>
     <tt>double valueAt1 = [aNote parAsDouble:MK_freq1];</tt>
     <tt>double attackDur = [aNote parAsDouble:MK_freqAtt];</tt>
     <tt>double releaseDur = [aNote parAsDouble:MK_freqRel];</tt>
     
   The <i>portamentoTime</i> argument is taken as the MKNote's
  MK_portamentoTime value.  As the name implies, it sets the portamento or
  &ldquo;slur&rdquo; between MKNotes and is only applied if the MKNote to
  which the MKEnvelope belongs is a noteOn that's interrupting an existing
  MKNote.  If the note is a MKNoteUpdate, the value is changed abruptly.
     
   The final argument, <i>status</i>, is used to distinguish the state
  of the MKSynthPatch at the time that the envelope is applied.  You
  retrieve the phrase status through MKSynthPatch's <b>phraseStatus</b>
  method.  The use of portamento, for example, is determined by the value
  of this argument.
   
   The <i>asymp</i> and <i>status </i>arguments are essential; the
  parameter-valued arguments aren't.  The function tries to be intelligent
  with regard to missing parameter-valued arguments; if, for example,
  <i>envelope</i> is <b>nil</b>, the value of <i>valueAt1</i> is applied
  as a constant. .
   
   <b>MKUpdateAsymp()</b> handles all the MKEnvelope breakpoint
  scheduling - keep in mind that the breakpoint data in an MKEnvelope
  object isn't transferred to the DSP as a unit but, instead, the
  breakpoints are fed to the DSP through message requests scheduled with a
  MKConductor.  The function always schedules MKEnvelope breakpoint
  messages with the clockConductor. 
  @param  asymp is a AsympUG instance.
  @param  envelope is an MKEnvelope instance.
  @param  valueAt0 is a double.
  @param  valueAt1 is a double.
  @param  attackDur is a double.
  @param  releaseDur is a double.
  @param  portamentoTime is a double.
  @param  status is a MKPhraseStatus.
  @return Returns a void.
*/
extern void MKUpdateAsymp(id asymp,
			  id envelope,
			  double valueAt0,
			  double valueAt1,
			  double attackDur,
			  double releaseDur,
			  double portamentoTime,
			  MKPhraseStatus status);

@end

